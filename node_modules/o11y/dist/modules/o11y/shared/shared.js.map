{"version":3,"file":"shared.js","sources":["../../../../src/shared/LazyMapToList.ts","../../../../src/shared/MetricsUtility.ts","../../../../src/shared/Utility.ts","../../../../src/shared/PublicSafety.ts","../../../../src/shared/SchemaUtil.ts"],"sourcesContent":["export class LazyMapToList<Key, ElementType> {\n    private readonly _lazyMap = new Map<Key, Array<ElementType>>();\n\n    private _maxSize: number;\n    constructor(maxSize?: number) {\n        if (maxSize !== undefined) {\n            if (typeof maxSize === 'number' && maxSize > 0) {\n                this._maxSize = Math.ceil(maxSize);\n                return;\n            }\n            throw new Error('maxSize must be a positive number');\n        }\n    }\n\n    get maxSize(): number {\n        return this._maxSize;\n    }\n\n    get size(): number {\n        return this._lazyMap.size;\n    }\n\n    /**\n     * Adds the value to the list specific to the key. If the list doesn't exist,\n     * it will be lazily created as long as there are fewer keys than the max, if specified.\n     *\n     * @param key The key for the map\n     * @param value The value to be added to the list\n     */\n    push(key: Key, value: ElementType): boolean {\n        let buffer = this._lazyMap.get(key);\n        if (!buffer) {\n            if (this.maxSize !== undefined && this.size === this.maxSize) {\n                return false;\n            }\n            buffer = new Array<ElementType>();\n            this._lazyMap.set(key, buffer);\n        }\n        buffer.push(value);\n        return true;\n    }\n\n    getMessages(key: Key, extract?: boolean): Array<ElementType> {\n        const msgs = this._lazyMap.get(key);\n        if (extract && this._lazyMap.has(key)) {\n            this._lazyMap.set(key, []);\n        }\n        return msgs || [];\n    }\n\n    getAllMessages(extract?: boolean): Map<Key, Array<ElementType>> {\n        const map = new Map<Key, Array<ElementType>>();\n        for (const [key, value] of this._lazyMap.entries()) {\n            if (value.length) {\n                map.set(key, this.getMessages(key, extract));\n            }\n        }\n        return map;\n    }\n\n    // Convenience functions for backwards compatibility\n    extractMessages(key: Key): Array<ElementType> {\n        return this.getMessages(key, true);\n    }\n    extractAllMessages(): Map<Key, Array<ElementType>> {\n        return this.getAllMessages(true);\n    }\n\n    get totalItemCount(): number {\n        let count = 0;\n        for (const array of this._lazyMap.values()) {\n            count += array.length;\n        }\n        return count;\n    }\n}\n","import { BucketMetric, Metric } from '../interfaces';\nimport { BucketHistogram, MetricTag, UpCounter, ValueRecorder } from '../interfaces-private';\nimport { MetricsTags } from './TypeDefinitions';\n\nexport class MetricsUtility {\n    private _getMetricTags<T>(metric: Metric<T>): MetricTag[] {\n        const tags: MetricsTags = metric.getTags();\n        if (tags) {\n            return Object.entries(tags).map((entry) => {\n                const mt: MetricTag = {\n                    name: entry[0],\n                    value: entry[1].toString()\n                };\n                return mt;\n            });\n        }\n        return undefined;\n    }\n\n    getUpCounters(metrics: Metric<number>[], reset = true): UpCounter[] {\n        return metrics.map((metric) => {\n            const data: UpCounter = {\n                name: metric.getName(),\n                createdTimestamp: metric.getCreatedOn(),\n                lastUpdatedTimestamp: metric.getLastUpdatedOn(),\n                value: metric.getData(),\n                ownerName: metric.getOwnerName(),\n                ownerAppName: metric.getOwnerAppName(),\n                tags: this._getMetricTags(metric)\n            };\n            if (reset) {\n                metric.reset();\n            }\n            return data;\n        });\n    }\n\n    getValueRecorders(metrics: Metric<number[]>[], reset = true): ValueRecorder[] {\n        return metrics.map((metric) => {\n            const data: ValueRecorder = {\n                name: metric.getName(),\n                createdTimestamp: metric.getCreatedOn(),\n                lastUpdatedTimestamp: metric.getLastUpdatedOn(),\n                values: metric.getData(),\n                ownerName: metric.getOwnerName(),\n                ownerAppName: metric.getOwnerAppName(),\n                tags: this._getMetricTags(metric)\n            };\n            if (reset) {\n                metric.reset();\n            }\n            return data;\n        });\n    }\n\n    getBucketHistograms(metrics: BucketMetric<number[]>[], reset = true): BucketHistogram[] {\n        return metrics.map((metric) => {\n            const data: BucketHistogram = {\n                name: metric.getName(),\n                createdTimestamp: metric.getCreatedOn(),\n                lastUpdatedTimestamp: metric.getLastUpdatedOn(),\n                values: metric.getData(),\n                buckets: metric.getBuckets(),\n                ownerName: metric.getOwnerName(),\n                ownerAppName: metric.getOwnerAppName(),\n                tags: this._getMetricTags(metric)\n            };\n            if (reset) {\n                metric.reset();\n            }\n            return data;\n        });\n    }\n\n    getMetricsTags(array: MetricTag[]): MetricsTags {\n        // Assuming array is already sorted by name\n        const obj: MetricsTags = {};\n        array.forEach((tag) => {\n            obj[tag.name] = tag.value;\n        });\n        return obj;\n    }\n}\n\nexport const metricsUtility = Object.freeze(new MetricsUtility());\n","import { AllowedOrigins } from '../interfaces';\nimport { ObjectType } from './TypeDefinitions';\n\nclass Utility {\n    private static _isProduction = false;\n    public readonly notImplemented = 'Method not implemented.';\n    public readonly perfNow: () => number;\n    public readonly time: () => { tsNow: number; perfNow: number; timeOrigin: number };\n    private readonly _timeOrigin: number;\n\n    constructor() {\n        const performanceExists = typeof performance !== 'undefined';\n        if (performanceExists) {\n            if (performance.timeOrigin) {\n                this._timeOrigin = performance.timeOrigin;\n            } else {\n                // if we don't have any start time, we consider our init to be the time origin\n                this._timeOrigin = Date.now();\n            }\n        } else {\n            this._timeOrigin = Date.now();\n        }\n\n        const timeOrigin = this._timeOrigin;\n        if (performanceExists && typeof performance.now === 'function') {\n            this.perfNow = performance.now.bind(performance);\n            this.time = () => {\n                const perfNow = this.perfNow();\n                return { tsNow: timeOrigin + perfNow, perfNow, timeOrigin };\n            };\n        } else {\n            this.perfNow = () => {\n                return Date.now() - timeOrigin;\n            };\n            this.time = () => {\n                const perfNow = this.perfNow();\n                return { tsNow: Date.now(), perfNow, timeOrigin };\n            };\n        }\n    }\n\n    public get isProduction(): boolean {\n        return Utility._isProduction;\n    }\n\n    public markProduction(): void {\n        // Don't allow production to be set to false once set\n        Utility._isProduction = true;\n    }\n\n    // Returns false if check fails\n    // if argKind is a string, uses typeof.\n    // if argKind is a function, such as String, Number, HTMLElement, uses instanceof.\n    // if argKind is an array, expects at least one of the element types to match.\n    private _checkArgument<T>(argument: T, argKind: unknown): boolean {\n        if (typeof argKind === 'string') {\n            return typeof argument === argKind;\n        }\n        if (typeof argKind === 'function') {\n            return argument instanceof argKind;\n        }\n        if (Array.isArray(argKind)) {\n            return argKind.some((arg) => this._checkArgument(argument, arg));\n        }\n        throw new Error(`Invalid argKind ${argKind}`);\n    }\n\n    public requireArgument<T>(argument: T, argumentName: string, argKind?: unknown): void {\n        let disallowed =\n            argument === undefined || argument === null || (argument as unknown) === '';\n        const kindSpecified = argKind !== undefined;\n\n        if (!disallowed && kindSpecified) {\n            disallowed = !this._checkArgument(argument, argKind);\n        }\n\n        if (disallowed) {\n            throw new Error(\n                `${argumentName} argument is required${\n                    kindSpecified ? ' and must be of a supported type.' : '.'\n                }`\n            );\n        }\n    }\n\n    public requireArgumentIfDefined<T>(\n        argument: T,\n        argumentName: string,\n        argKind: unknown\n    ): boolean {\n        if (argument === undefined) {\n            return false;\n        }\n        const disallowed =\n            argument === null ||\n            (argument as unknown) === '' ||\n            !this._checkArgument(argument, argKind);\n\n        if (disallowed) {\n            throw new Error(`${argumentName} argument, if defined, must be of a supported type.`);\n        }\n\n        return true;\n    }\n\n    public checkForDenyListedValues<T>(\n        argument: T,\n        argumentName: string,\n        denyList: ReadonlyArray<T>\n    ): void {\n        if (denyList.some((x) => argument === x)) {\n            throw new Error(`The value ${argument} isn't allowed for ${argumentName} argument.`);\n        }\n    }\n\n    public checkForReservedCharacters(\n        argument: string,\n        argumentName: string,\n        reservedChars: ReadonlyArray<string>\n    ): void {\n        if (argument && reservedChars.some((c) => argument.indexOf(c) >= 0)) {\n            throw new Error(\n                `The argument ${argumentName} isn't allowed to contain characters from ['${reservedChars.join(\n                    ', '\n                )}']. Received: ${argument}.`\n            );\n        }\n    }\n\n    public generateUniqueId(length = 16): string {\n        const chars: string[] = [];\n        const digits = '0123456789abcdef';\n        if (!(length === undefined || length > 0)) {\n            throw new Error('If specified, the argument \"length\" must be a positive integer');\n        }\n        for (let i = 0; i < length; i++) {\n            const rand = Math.floor(Math.random() * 16);\n            chars.push(digits[rand]);\n        }\n        return chars.join('');\n    }\n\n    public getXpath(_element: HTMLElement): string {\n        //if the element has siblings with the same type we should return 1, otherwise not\n        function hasSameSibs(elm: Element): boolean {\n            const name = elm.localName;\n            while (elm.nextElementSibling) {\n                elm = elm.nextElementSibling;\n                if (elm.localName === name) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function idx(sib: Element, name?: string): number {\n            //we want to count the siblings of the same type for the xpath, otherwise it is just 1\n            if (sib) {\n                return (\n                    idx(sib.previousElementSibling, name || sib.localName) +\n                    (sib.localName === name ? 1 : 0)\n                );\n            }\n            return 1;\n        }\n        function segs(elm: HTMLElement): string[] {\n            // only run for element nodes\n            if (!elm || elm.nodeType !== 1) {\n                return [''];\n            }\n            //only add the number if it is over 1, or if it the first of siblings\n            const nodeValue =\n                idx(elm) > 1 || hasSameSibs(elm)\n                    ? `${elm.localName.toLowerCase()}[${idx(elm)}]`\n                    : elm.localName.toLowerCase();\n            //go up and add the element at the end of the path\n            return [...segs(elm.parentNode as HTMLElement), nodeValue];\n        }\n        //concat at the end\n        return segs(_element).join('/');\n    }\n\n    public getAge(timestamp: number): number {\n        return timestamp - this._timeOrigin;\n    }\n\n    public getConnectionType(): string {\n        let connectionType;\n        if (typeof navigator !== 'undefined') {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection\n            type NavigatorExperimental = {\n                connection: {\n                    effectiveType: string;\n                };\n            };\n            const expNav = navigator as unknown as NavigatorExperimental;\n            connectionType = expNav?.connection?.effectiveType;\n        }\n        return connectionType;\n    }\n\n    public clone<T>(value: T): T {\n        return JSON.parse(JSON.stringify(value));\n    }\n\n    public definedValueOrDefault<T>(value: T, defaultValue: T): T {\n        return value !== undefined ? value : defaultValue;\n    }\n\n    public getGlobal(): typeof globalThis {\n        if (typeof globalThis === 'object') {\n            return globalThis;\n        }\n        if (typeof self === 'object') {\n            return self;\n        }\n        throw new Error('Unable to locate globalThis or self');\n    }\n\n    public getIsBeaconSupported(): boolean {\n        const g = this.getGlobal();\n        return typeof g.navigator?.sendBeacon === 'function' && typeof g.Blob === 'function';\n    }\n\n    public estimateObjectSize(object: unknown): number {\n        const objectSet = new Set<ObjectType>();\n        const stack: Array<unknown> = [object];\n        let bytes = 0;\n\n        while (stack.length) {\n            const value: unknown = stack.pop();\n            if (typeof value === 'boolean') {\n                bytes += 4;\n            } else if (typeof value === 'string') {\n                bytes += value.length * 2;\n            } else if (typeof value === 'number') {\n                bytes += 8;\n            } else if (\n                value instanceof Uint8Array ||\n                value instanceof Uint8ClampedArray ||\n                value instanceof Uint16Array ||\n                value instanceof Uint32Array ||\n                value instanceof Int8Array ||\n                value instanceof Int16Array ||\n                value instanceof Int32Array ||\n                value instanceof Float32Array ||\n                value instanceof Float64Array\n            ) {\n                bytes += value.byteLength;\n            } else if (typeof value === 'object') {\n                const obj: ObjectType = value as ObjectType;\n                if (!objectSet.has(obj)) {\n                    objectSet.add(obj);\n                    for (const key in obj) {\n                        stack.push(obj[key]);\n                    }\n                }\n            }\n        }\n        return bytes;\n    }\n\n    // swallows exceptions on production.\n    // Ensure that code that follows this call is a proper no-op.\n    noProdThrow(e: unknown): void | never {\n        if (utility.isProduction) {\n            return;\n        }\n        throw e;\n    }\n\n    isAllowedOrigin(input: string, allowed: AllowedOrigins): boolean {\n        return (\n            Array.isArray(allowed) &&\n            allowed.some(\n                (origin) =>\n                    origin === '*' ||\n                    input === origin ||\n                    (origin instanceof RegExp && origin.test(input))\n            )\n        );\n    }\n}\n\nexport const utility = Object.freeze(new Utility());\n","import { UpCounter } from '../interfaces';\nimport { utility } from './Utility';\n\nexport class PublicSafety {\n    private _safeCatchMode = false;\n\n    constructor(private readonly _errorCounter?: UpCounter) {}\n\n    /**\n     * Instrumentation should never throw in production. Therefore, we need to include in\n     * all our public methods a top-most try/catch wrapper. Simply use this function\n     * as your first and only top-level call in the function block and sleep well at night.\n     *\n     * @param fn The body of the unsafe function that doesn't return a value but can throw\n     */\n    tryCatch(fn: () => void): void {\n        try {\n            fn();\n        } catch (err) {\n            this._prodSafeCatch(err);\n        }\n    }\n\n    /**\n     *\n     * @param fn The body of the unsafe function that returns a value and that can throw\n     * @param noopValue A static, noop instance of V (like a mock) that will be returned in case\n     * the function could not be called.\n     */\n    tryCatchReturn<V>(fn: () => V, noopValue: V): V {\n        try {\n            utility.requireArgument(noopValue, 'noopValue');\n            return fn();\n        } catch (err) {\n            this._prodSafeCatch(err);\n            return noopValue;\n        }\n    }\n\n    /**\n     * Safely handles exceptions. Suppresses throws in a production environment.\n     * This method is intended to be called inside a catch block.\n     *\n     * @param error The error that was caught\n     */\n    private _prodSafeCatch(error: unknown): void {\n        let allowThrow;\n        try {\n            allowThrow = !utility.isProduction;\n            if (allowThrow) {\n                // Just throw the error in development\n                throw error;\n            }\n\n            if (this._safeCatchMode) {\n                // If we're here, that means code in the try block of prodSafeCatch itself is throwing an error\n                // (i.e. prodSafeCatch is already on the stack). Break out now to prevent infinite loop.\n                this._safeCatchMode = false;\n\n                throw new Error('Internal error in prodSafeCatch.');\n            }\n\n            this._safeCatchMode = true;\n            if (this._errorCounter) {\n                this._errorCounter.increment();\n            }\n\n            if (!(error instanceof Error)) {\n                const errorText =\n                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n                    (error && (error as any).message) ||\n                    (typeof error.toString === 'function' ? error.toString() : '');\n                error = new Error(errorText);\n            }\n\n            // If not allowed to throw the error, at least try to log it\n            // TODO: This error should be attributed to the global Instrumentation (not to \"this\")\n            // this.error(error);\n            this._safeCatchMode = false;\n        } catch (internalError) {\n            // Do not call any methods in this catch block except for console.error\n\n            if (allowThrow) {\n                // pass it along\n                throw internalError;\n            }\n\n            // eslint-disable-next-line no-console\n            if (internalError && console && typeof console.error === 'function') {\n                try {\n                    // eslint-disable-next-line no-console\n                    console.error(internalError);\n                } catch {\n                    // Nothing we can do at this point\n                }\n            }\n            this._safeCatchMode = false;\n        }\n    }\n}\n","import { IField, INamespace, IType, Schema, SchematizedPayload, SchemaTokens } from '../interfaces';\nimport {\n    AnyNestedObject,\n    PbjsNestedObjectDescriptor,\n    ProtoOptions,\n    SchematizedData\n} from './TypeDefinitions';\nimport { utility } from './Utility';\n\nclass SchemaUtil {\n    public getSchemaId(schema: Schema): string {\n        return `${schema.namespace}.${schema.name}`;\n    }\n    public isInternal(schema: Schema): boolean {\n        return schema?.namespace === 'sf.instrumentation';\n    }\n\n    public makePayload(\n        schema: Schema,\n        data: SchematizedData,\n        onlyIfBoth = true\n    ): SchematizedPayload {\n        if (!onlyIfBoth || (schema !== undefined && data !== undefined)) {\n            return {\n                schema,\n                payload: data\n            };\n        }\n        return undefined;\n    }\n\n    public checkSchema(schema: Schema): SchemaTokens {\n        utility.requireArgument(schema, 'schema', 'object');\n        utility.requireArgument(schema.namespace, 'schema.namespace', 'string');\n        utility.requireArgument(schema.name, 'schema.name', 'string');\n        utility.requireArgument(schema.pbjsSchema, 'schema.pbjsSchema', 'object');\n        const parts: string[] = schema.namespace.split('.');\n        if (parts.length !== 2) {\n            throw new Error(\n                `Schema \"${this.getSchemaId(\n                    schema\n                )}\" must have a namespace of the form \"domain.feature\".`\n            );\n        }\n        return {\n            domain: parts[0],\n            feature: parts[1],\n            message: schema.name\n        };\n    }\n\n    private _getAnyNestedObject(schema: Schema, scopes: string[]): AnyNestedObject {\n        return scopes.reduce((prev: INamespace, currentScope: string) => {\n            const descriptor: PbjsNestedObjectDescriptor = prev.nested;\n            if (descriptor) {\n                const ano: AnyNestedObject = descriptor[currentScope];\n                if (ano) {\n                    return ano;\n                }\n            }\n            throw new Error(\n                `Cannot locate ${scopes.join('.')} in schema with ID ${this.getSchemaId(schema)}`\n            );\n        }, schema.pbjsSchema);\n    }\n\n    public getTypes(schema: Schema): PbjsNestedObjectDescriptor {\n        const schemaTokens: SchemaTokens = this.checkSchema(schema);\n        const namespace: INamespace = this._getAnyNestedObject(schema, [\n            schemaTokens.domain,\n            schemaTokens.feature\n        ]);\n        const descriptor: PbjsNestedObjectDescriptor = namespace.nested;\n        if (!descriptor) {\n            throw new Error(`Cannot parse schema with ID ${this.getSchemaId(schema)}`);\n        }\n        return descriptor;\n    }\n\n    public getType(schema: Schema, messageName: string): IType {\n        utility.requireArgument(messageName, 'messageName', 'string');\n        const descriptor: PbjsNestedObjectDescriptor = this.getTypes(schema);\n\n        const message = descriptor[messageName] as IType;\n        if (!message) {\n            throw new Error(\n                `Cannot locate message ${messageName} in schema with ID ${this.getSchemaId(schema)}`\n            );\n        }\n        return message;\n    }\n\n    public getOptions(schema: Schema, messageName?: string, fieldName?: string): ProtoOptions {\n        if (fieldName) {\n            utility.requireArgument(messageName, 'messageName', 'string');\n        }\n        const schemaTokens: SchemaTokens = this.checkSchema(schema);\n\n        if (!messageName) {\n            const namespace: INamespace = this._getAnyNestedObject(schema, [\n                schemaTokens.domain,\n                schemaTokens.feature\n            ]);\n            return namespace.options;\n        }\n\n        const type: IType = this.getType(schema, messageName);\n        if (!fieldName) {\n            return type.options;\n        }\n\n        const field: IField = type.fields[fieldName];\n        if (!field) {\n            const schemaId = this.getSchemaId(schema);\n            throw new Error(\n                `Cannot locate field ${fieldName} in message ${messageName} in schema with ID ${schemaId}`\n            );\n        }\n        return field.options;\n    }\n}\n\nexport const schemaUtil = new SchemaUtil();\n"],"names":[],"mappings":"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"}