{"version":3,"file":"collectors.js","sources":["../../../../src/collectors/protobuf-util.ts","../../../../src/collectors/core-collector/CoreEnvelopeProtobufUtility.ts","../../../../src/collectors/core-collector/UploadMode.ts","../../../../src/collectors/core-collector/CoreCollector.ts","../../../../src/collectors/hybrid-collector/HybridCollector.ts"],"sourcesContent":["import { Message, Root, Type } from 'protobufjs';\nimport { SchematizedData, schemaUtil, utility } from 'o11y/shared';\n\nimport { LogMeta, Schema, SchematizedPayload } from '../interfaces';\nimport { EncodedSchematizedPayload, LogMessage, LogMessageRaw } from '../core_envelope/interfaces';\n\nclass ProtobufUtil {\n    private readonly _typeStore = new Map<string, Type>();\n\n    public getSchemaType(schema: Schema): Type {\n        utility.requireArgument(schema, 'schema');\n        const schemaPath = schemaUtil.getSchemaId(schema);\n        let type = this._typeStore.get(schemaPath);\n\n        if (!type) {\n            // Lazy add to the type store\n            const schemaInstance = Root.fromJSON(schema.pbjsSchema);\n            // this will throw if it can't find it\n            type = schemaInstance.lookupType(schemaPath);\n            this._typeStore.set(schemaPath, type);\n        }\n\n        return type;\n    }\n\n    public validate(schema: Schema, data: SchematizedData): Type {\n        utility.requireArgument(schema, 'schema');\n        utility.requireArgument(data, 'data');\n        const type: Type = this.getSchemaType(schema);\n\n        const errorText = type.verify(data);\n        if (errorText) {\n            throw new Error(`Data is invalid for ${type.fullName}: ${errorText}`);\n        }\n        return type;\n    }\n\n    // Note: In a Node environment, this actually returns an instance of Buffer.\n    public encode(schema: Schema, data: SchematizedData): Uint8Array {\n        const type: Type = this.validate(schema, data);\n        const message: Message = type.fromObject(data);\n        const encoded: Uint8Array = type.encode(message).finish();\n        return encoded;\n    }\n\n    public encodePayload(rawPayload: SchematizedPayload): EncodedSchematizedPayload {\n        if (rawPayload?.schema && rawPayload.payload) {\n            return {\n                schemaName: schemaUtil.getSchemaId(rawPayload.schema),\n                payload: this.encode(rawPayload.schema, rawPayload.payload)\n            };\n        }\n        return undefined;\n    }\n\n    //  This method generates a LogMessage (used in the CoreEnvelope) from the provided arguments.\n    public getLogMessage(schema: Schema, data: SchematizedData, logMeta: LogMeta): LogMessage {\n        return {\n            timestamp: logMeta.timestamp,\n            data: this.encode(schema, data),\n            age: logMeta.age,\n            rootId: logMeta.rootId,\n            seq: logMeta.sequence,\n            sseq: logMeta.schemaSequence,\n            loggerName: logMeta.loggerName,\n            pagePayload: this.encodePayload(logMeta.pagePayload),\n            loggerAppName: logMeta.loggerAppName,\n            connectionType: logMeta.connectionType,\n            appPayload: this.encodePayload(logMeta.appPayload),\n            csId: logMeta.clientSessionId,\n            recCsId: logMeta.receiverClientSessionId,\n            recRootId: logMeta.receiverRootId\n        };\n    }\n\n    public processRawLogMessage(schema: Schema, raw: LogMessageRaw): LogMessage {\n        const dataClone = raw.data ? Object.assign({}, raw.data) : {};\n        if (schemaUtil.isInternal(schema) && dataClone.userPayload) {\n            dataClone.userPayload = this.encodePayload(dataClone.userPayload);\n        }\n\n        return Object.assign({}, raw, {\n            data: this.encode(schema, dataClone),\n            pagePayload: this.encodePayload(raw.pagePayload),\n            appPayload: this.encodePayload(raw.appPayload)\n        });\n    }\n}\n\nexport const protobufUtil = new ProtobufUtil();\n","import { Root, Type } from 'protobufjs';\nimport {\n    CoreEnvelope,\n    CoreEnvelopeContents,\n    CoreEnvelopeContentsRaw,\n    LogMessage,\n    CoreEnvelopeBuilder\n} from 'o11y/core_envelope';\nimport { coreEnvelopeSchema } from 'o11y_schema/sf_instrumentation';\nimport { Schema } from '../../interfaces';\nimport { protobufUtil } from '../protobuf-util';\n\nconst root: Root = Root.fromJSON(coreEnvelopeSchema.pbjsSchema);\nconst _coreEnvelopeType: Type = root.lookupType('CoreEnvelope');\n\nexport function processRawContents(contentsRaw: CoreEnvelopeContentsRaw): CoreEnvelopeContents {\n    const processed: CoreEnvelopeContents = Object.assign({}, contentsRaw, {\n        messages: new Map<Schema, LogMessage[]>()\n    });\n    // Encode individual messages\n    contentsRaw.messages.forEach(function (rawMessages, schema) {\n        processed.messages.set(\n            schema,\n            rawMessages.map((msg) => protobufUtil.processRawLogMessage(schema, msg))\n        );\n    });\n    return processed;\n}\n\nexport function envelopeContents(contents: CoreEnvelopeContents): CoreEnvelope {\n    return CoreEnvelopeBuilder.buildFrom(contents);\n}\n\nexport function encodeCoreEnvelope(coreEnvelope: CoreEnvelope): Uint8Array {\n    const errorMessage = _coreEnvelopeType.verify(coreEnvelope);\n    if (errorMessage) {\n        throw new Error(`Invalid CoreEnvelope: ${errorMessage}`);\n    }\n\n    const encodedCoreEnvelope = _coreEnvelopeType.encode(coreEnvelope).finish();\n    return encodedCoreEnvelope;\n}\n\nexport function encodeCoreEnvelopeContentsRaw(contentsRaw: CoreEnvelopeContentsRaw): Uint8Array {\n    const contents: CoreEnvelopeContents = processRawContents(contentsRaw);\n    const coreEnvelope: CoreEnvelope = envelopeContents(contents);\n    const encoded: Uint8Array = encodeCoreEnvelope(coreEnvelope);\n    return encoded;\n}\n","export enum UploadMode {\n    fetchBinary, // application/octet-stream\n    fetchFile, // multipart/form-data\n    noUpload\n}\n","import {\n    Environment,\n    LogCollector,\n    LogMeta,\n    MetricsCollector,\n    MetricsExtractorMethods,\n    Schema\n} from '../../interfaces';\nimport { LazyMapToList, SchematizedData, schemaUtil, utility } from 'o11y/shared';\nimport {\n    CoreEnvelope,\n    CoreEnvelopeBuilder,\n    CoreEnvelopeContents,\n    LogMessage,\n    StaticAttributes\n} from 'o11y/core_envelope';\n\nimport { protobufUtil } from '../protobuf-util';\n\nimport { envelopeContents, encodeCoreEnvelope } from './CoreEnvelopeProtobufUtility';\nimport { UploadResult } from './interfaces/UploadResult';\nimport { CoreCollectorOptions } from './interfaces/CoreCollectorOptions';\nimport { UploadMode } from './UploadMode';\n\nconst defaultFormDataKey = 'telemetry';\nconst defaultMaxUniqueSchemas = 10000;\nconst defaultMaxDelayBeforeUpload = 10000;\nconst defaultMessagesLimit = 10;\nconst defaultMetricsLimit = 10;\nconst defaultUploadMode = UploadMode.fetchBinary;\n\nexport type UploadOptionsCallback = () => RequestInit;\n\nexport class CoreCollector implements LogCollector, MetricsCollector {\n    private readonly _messageBuffers: LazyMapToList<Schema, LogMessage>;\n    private _intervalHandle: NodeJS.Timeout;\n    private _metricsExtractors: MetricsExtractorMethods;\n    private readonly _staticAttributes: StaticAttributes;\n    private _immediateUpload: boolean;\n    private readonly _messagesLimit: number = defaultMessagesLimit;\n    /*\n     Known limitation:\n     Unlike _messagesLimit, _metricsLimit is not a strict limit in all cases, as the CoreCollector\n     doesn't get notified every time a new metric is added. Instead, it takes metrics into account\n     when a message is logged or the upload timer is elapsed. If the _metricsLimit is exceeded \n     with no messages logged and upload time not yet elapsed, upload will not occur.\n    */\n    private readonly _metricsLimit: number = defaultMetricsLimit;\n    private readonly _formDataKey: string = defaultFormDataKey;\n    private readonly _uploadFailedListener: (ur: UploadResult) => unknown;\n    private _uploadInterval: number = defaultMaxDelayBeforeUpload;\n    private _uploadEndpoint: string;\n    private _uploadMode: UploadMode;\n    private readonly _emptySize: number;\n    private _messageSize = 0;\n    private _uploadOptionsCallback: UploadOptionsCallback;\n\n    constructor(\n        uploadEndpoint?: string,\n        uploadMode?: UploadMode,\n        environment?: Environment,\n        options?: CoreCollectorOptions\n    ) {\n        this.uploadEndpoint = uploadEndpoint;\n        this.uploadMode = uploadMode == undefined ? defaultUploadMode : uploadMode;\n\n        if (environment) {\n            this._staticAttributes = {\n                appName: environment.appName,\n                appVersion: environment.appVersion,\n                appExperience: environment.appExperience,\n                deviceId: environment.deviceId,\n                deviceModel: environment.deviceModel,\n                sdkVersion: environment.sdkVersion\n            };\n        }\n\n        let maxUniqueSchemas = defaultMaxUniqueSchemas;\n        if (options) {\n            const mus: number = options.maxUniqueSchemas;\n            if (mus !== undefined) {\n                if (typeof mus !== 'number' || !(mus > 0)) {\n                    throw new Error('options.maxUniqueSchemas, if defined, must be > 0');\n                }\n                maxUniqueSchemas = mus;\n            }\n\n            const msglim: number = options.messagesLimit;\n            if (msglim !== undefined) {\n                if (typeof msglim !== 'number' || !(msglim > 0)) {\n                    throw new Error('options.messagesLimit, if defined, must be > 0');\n                }\n                this._messagesLimit = msglim;\n            }\n\n            const metlim: number = options.metricsLimit;\n            if (metlim !== undefined) {\n                if (typeof metlim !== 'number' || !(metlim > 0)) {\n                    throw new Error('options.metricsLimit, if defined, must be > 0');\n                }\n                this._metricsLimit = metlim;\n            }\n\n            if (\n                utility.requireArgumentIfDefined(\n                    options.formDataKeyName,\n                    'options.formDataKeyName',\n                    'string'\n                )\n            ) {\n                this._formDataKey = options.formDataKeyName;\n            }\n\n            if (\n                utility.requireArgumentIfDefined(\n                    options.uploadFailedListener,\n                    'options.uploadFailedListener',\n                    'function'\n                )\n            ) {\n                this._uploadFailedListener = options.uploadFailedListener;\n            }\n        }\n        this._messageBuffers = new LazyMapToList<Schema, LogMessage>(maxUniqueSchemas);\n\n        this._emptySize = this.getByteSize(1);\n        this._restartTimer();\n    }\n\n    get uploadInterval(): number {\n        return this._uploadInterval;\n    }\n    set uploadInterval(uploadInterval: number) {\n        if (uploadInterval === undefined) {\n            uploadInterval = defaultMaxDelayBeforeUpload;\n        }\n        if (typeof uploadInterval !== 'number' || !(uploadInterval > 0)) {\n            throw new Error('uploadInterval, if defined, must be > 0');\n        }\n        if (uploadInterval !== this._uploadInterval) {\n            this._uploadInterval = uploadInterval;\n            // Now that the interval has changed, restart the timer\n            this._restartTimer();\n        }\n    }\n\n    get uploadEndpoint(): string {\n        return this._uploadEndpoint;\n    }\n    set uploadEndpoint(uploadEndpoint: string) {\n        utility.requireArgumentIfDefined(uploadEndpoint, 'uploadEndpoint', 'string');\n        this._uploadEndpoint = uploadEndpoint;\n    }\n\n    get uploadOptionsCallback(): UploadOptionsCallback {\n        return this._uploadOptionsCallback;\n    }\n    set uploadOptionsCallback(uploadOptionsCallback: UploadOptionsCallback) {\n        utility.requireArgumentIfDefined(\n            uploadOptionsCallback,\n            'uploadOptionsCallback',\n            'function'\n        );\n\n        this._uploadOptionsCallback = uploadOptionsCallback;\n    }\n\n    get uploadMode(): UploadMode {\n        return this._uploadMode;\n    }\n    set uploadMode(uploadMode: UploadMode) {\n        utility.requireArgumentIfDefined(uploadMode, 'uploadMode', 'number');\n        if (uploadMode === undefined) {\n            uploadMode = defaultUploadMode;\n        }\n        if (!(uploadMode in UploadMode)) {\n            throw new Error(`Unsupported upload mode: ${uploadMode}`);\n        }\n        this._uploadMode = uploadMode;\n    }\n\n    // Note: If making changes to this method, please locally test using SizeEstimation.test.js\n    getByteSize(accuracy?: number): number {\n        // This method provides an estimate.\n        // Accuracy is specified as 1 = most accurate\n        return accuracy >= 1\n            ? this._buildProtoEncodedCoreEnvelope(false).byteLength\n            : accuracy >= 0.5\n            ? this._emptySize + this._messageSize + this.metricsCount * 8\n            : this._emptySize + this._messageSize;\n    }\n\n    private _stopTimer(): void {\n        if (this._intervalHandle !== undefined) {\n            clearInterval(this._intervalHandle);\n            this._intervalHandle = undefined;\n        }\n    }\n\n    private _restartTimer(): void {\n        this._stopTimer();\n        this._intervalHandle = setInterval(() => {\n            if (this.hasData) {\n                this._upload();\n            }\n        }, this._uploadInterval);\n    }\n\n    // This method is implementing the LogCollector interface, but needs to return (not swallow)\n    // the async result in order for direct call to it from test to handle failure cases properly.\n    async collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): Promise<UploadResult> {\n        if (schemaUtil.isInternal(schema) && data.userPayload) {\n            data.userPayload = protobufUtil.encodePayload(data.userPayload);\n        }\n        const msg: LogMessage = protobufUtil.getLogMessage(schema, data, logMeta);\n\n        if (!this._messageBuffers.push(schema, msg)) {\n            throw new Error(`Buffer is full. Refusing schemaId ${schemaUtil.getSchemaId(schema)}`);\n        }\n        // Get an estimate\n        this._messageSize += utility.estimateObjectSize(msg);\n        if (this._shouldUpload()) {\n            return this._upload();\n        }\n        return undefined;\n    }\n\n    private _shouldUpload(): boolean {\n        return (\n            (this._immediateUpload && this.hasData) ||\n            this.messagesCount >= this._messagesLimit ||\n            this.metricsCount >= this._metricsLimit\n        );\n    }\n\n    private async _upload(userInitiated?: boolean): Promise<UploadResult> {\n        this._restartTimer();\n        if (!this._uploadEndpoint || this._uploadMode === UploadMode.noUpload) {\n            return undefined;\n        }\n\n        const contents: CoreEnvelopeContents = this._getContentsOfCoreEnvelope(true);\n        return this._uploadContents(contents, userInitiated);\n    }\n\n    private async _uploadContents(\n        contents: CoreEnvelopeContents,\n        userInitiated: boolean\n    ): Promise<UploadResult> {\n        let requestInit: RequestInit = this._getRequestInit(contents);\n        const ur: UploadResult = {\n            envelopeContents: contents\n        };\n        try {\n            if (this._uploadOptionsCallback) {\n                const options: RequestInit = this._uploadOptionsCallback() || {};\n                if (options) {\n                    if (options.headers && requestInit.headers) {\n                        // According to lib.dom.d.ts:\n                        // type HeadersInit = [string, string][] | Record<string, string> | Headers;\n                        if (options.headers instanceof Headers) {\n                            for (const key in requestInit.headers) {\n                                if (\n                                    Object.prototype.hasOwnProperty.call(requestInit.headers, key)\n                                ) {\n                                    options.headers.set(\n                                        key,\n                                        (requestInit.headers as Record<string, string>)[key]\n                                    );\n                                }\n                            }\n                        } else if (Array.isArray(options.headers)) {\n                            // This doesn't seem valid according to https://developer.mozilla.org/en-US/docs/Web/API/fetch\n                            throw new Error('Headers as array is not supported.');\n                        } else {\n                            Object.assign(options.headers, requestInit.headers);\n                        }\n                    }\n                    options.method = requestInit.method;\n                    options.body = requestInit.body;\n                    requestInit = options;\n                }\n            }\n\n            ur.response = await fetch(this._uploadEndpoint, requestInit);\n            // fetch only throws on network errors, not HTTP errors, so handle that here\n            if (!ur.response.ok) {\n                throw new Error('HTTP Not OK');\n            }\n            return ur;\n        } catch (err) {\n            ur.error = err;\n            if (!userInitiated && this._uploadFailedListener) {\n                try {\n                    this._uploadFailedListener(ur);\n                } catch {}\n            }\n            throw ur;\n        }\n    }\n\n    private _getRequestInit(contents: CoreEnvelopeContents): RequestInit {\n        const coreEnvelope: CoreEnvelope = envelopeContents(contents);\n        const coreEnvelopeEncoded: Uint8Array = encodeCoreEnvelope(coreEnvelope);\n\n        let requestInit: RequestInit;\n        switch (this._uploadMode) {\n            case UploadMode.fetchBinary:\n                requestInit = {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/octet-stream'\n                    },\n                    body: coreEnvelopeEncoded\n                };\n                break;\n            case undefined:\n            case UploadMode.fetchFile:\n                if (typeof FormData !== 'function') {\n                    throw new Error('FormData is not a function in the global namespace.');\n                }\n                const formData = new FormData();\n                formData.append(\n                    this._formDataKey || defaultFormDataKey,\n                    new Blob([coreEnvelopeEncoded])\n                );\n                // Per [this article](https://muffinman.io/uploading-files-using-fetch-multipart-form-data/)\n                // make sure not to set the Content-Type header.\n                // The browser will set it for you, including the boundary parameter.\n                requestInit = {\n                    method: 'POST',\n                    body: formData\n                };\n                break;\n            case UploadMode.noUpload:\n            default:\n                throw new Error('Invalid uploadMode');\n        }\n        return requestInit;\n    }\n\n    private _checkUploadState(): void {\n        if (this._uploadEndpoint === undefined) {\n            throw new Error('Upload endpoint is unset');\n        }\n        if (this._uploadMode === UploadMode.noUpload) {\n            throw new Error('Upload mode is unset');\n        }\n    }\n\n    // User initiated method\n    public async upload(contents?: CoreEnvelopeContents): Promise<UploadResult> {\n        this._checkUploadState();\n        if (utility.requireArgumentIfDefined(contents, 'contents', 'object')) {\n            return this._uploadContents(contents, true);\n        }\n\n        return this.hasData ? this._upload(true) : undefined;\n    }\n\n    get hasData(): boolean {\n        return this.messagesCount > 0 || this.metricsCount > 0;\n    }\n\n    get messagesCount(): number {\n        return this._messageBuffers.totalItemCount;\n    }\n\n    get metricsCount(): number {\n        let count = 0;\n\n        if (this._metricsExtractors) {\n            count += this._metricsExtractors.getAllUpCounters().length || 0;\n            count += this._metricsExtractors.getAllValueRecorders().length || 0;\n            count += this._metricsExtractors.getAllBucketHistograms().length || 0;\n        }\n\n        return count;\n    }\n\n    getProtoEncodedCoreEnvelope(): Uint8Array {\n        return this._buildProtoEncodedCoreEnvelope(true);\n    }\n\n    getContentsOfCoreEnvelope(): CoreEnvelopeContents {\n        return this._getContentsOfCoreEnvelope(true);\n    }\n\n    private _getContentsOfCoreEnvelope(extract: boolean): CoreEnvelopeContents {\n        // 1. extract=true is for most use cases.\n        // 2. extract=false is for peeking into the contents without affecting them\n        //    (i.e. messages are kept in the buffers and metrics are not reset.)\n        //    Message arrays are references to the originals and should be handled carefully.\n\n        const contents: CoreEnvelopeContents = {\n            staticAttributes: this._staticAttributes,\n            messages: this._messageBuffers.getAllMessages(extract)\n        };\n\n        if (this._metricsExtractors) {\n            contents.upCounters = CoreEnvelopeBuilder.getUpCounters(\n                this._metricsExtractors.getAllUpCounters(),\n                extract\n            );\n            contents.valueRecorders = CoreEnvelopeBuilder.getValueRecorders(\n                this._metricsExtractors.getAllValueRecorders(),\n                extract\n            );\n            contents.bucketHistograms = CoreEnvelopeBuilder.getBucketHistograms(\n                this._metricsExtractors.getAllBucketHistograms(),\n                extract\n            );\n        }\n\n        if (extract) {\n            this._messageSize = 0;\n        }\n        return contents;\n    }\n\n    private _buildProtoEncodedCoreEnvelope(extract: boolean): Uint8Array {\n        const contents: CoreEnvelopeContents = this._getContentsOfCoreEnvelope(extract);\n        const coreEnvelope: CoreEnvelope = envelopeContents(contents);\n        return encodeCoreEnvelope(coreEnvelope);\n    }\n\n    receiveMetricsExtractors(metricsExtractors: MetricsExtractorMethods): void {\n        this._metricsExtractors = metricsExtractors;\n    }\n}\n","import {\n    BucketMetric,\n    LogCollector,\n    LogMeta,\n    Metric,\n    MetricsCollector,\n    MetricsExtractorMethods,\n    Schema\n} from '../../interfaces';\nimport { SchematizedData, MetricsTags, schemaUtil, utility } from 'o11y/shared';\nimport { protobufUtil } from '../protobuf-util';\nimport {\n    BucketHistogram,\n    EncodedSchematizedPayload,\n    LogMessage,\n    Metrics,\n    MetricTag,\n    UpCounter,\n    ValueRecorder\n} from 'o11y/core_envelope';\n\nconst metricsCollectionMilliseconds = 30000;\n\n// The observability plugin expects encoded payloads, so can't use LogMeta as-is.\ninterface LogMetaObservability {\n    timestamp: number;\n    rootId: string;\n    sequence: number;\n    schemaSequence: number;\n    loggerName: string;\n    pagePayload: EncodedSchematizedPayload;\n    loggerAppName: string;\n    connectionType: string;\n    appPayload: EncodedSchematizedPayload;\n    clientSessionId: string;\n    age: number;\n    receiverClientSessionId?: string;\n    receiverRootId?: string;\n}\n\n// The following interface is expected to be fulfilled by the\n// observability plugin in Lightning SDK.\ndeclare type NimbusObservabilityPlugin = {\n    // Called to send a collected message to native for handling\n    log: (schema: string, encodedMessage: Uint8Array, logMeta: LogMetaObservability) => void;\n\n    // Called to send metrics to native for handling\n    logMetrics: (metrics: Metrics) => void;\n\n    // Called to listen for root activity changes in native.\n    //\n    // The startListener is called with the id of the root activity when an activity is started\n    // The stopListener is called when a root activity is stopped\n    addRootActivityListeners: (\n        startListener: (activityInfo: { id: string }) => void,\n        stopListener: () => void\n    ) => void;\n\n    // Called to inform native that the web view has detected an idle state.\n    idleDetected: (timestamp: number) => void;\n};\n\n// The `HybridCollector` uses nimbus to send log data immediately across\n// to be handled by the native observability library.\nexport class HybridCollector implements LogCollector, MetricsCollector {\n    private readonly _observability: NimbusObservabilityPlugin;\n    private _metricsExtractors: MetricsExtractorMethods;\n\n    constructor() {\n        if (typeof __nimbus === 'undefined') {\n            throw new Error('Nimbus is unavailable');\n        }\n        if (!__nimbus.plugins || !__nimbus.plugins.observability) {\n            throw new Error('Observability plugin not found in Nimbus plugins');\n        }\n        this._observability = __nimbus.plugins.observability as NimbusObservabilityPlugin;\n        setInterval(() => {\n            this._collectMetrics();\n        }, metricsCollectionMilliseconds);\n    }\n\n    collect(schema: Schema, data: SchematizedData, logMeta: LogMeta): void {\n        if (schemaUtil.isInternal(schema) && data.userPayload) {\n            data.userPayload = protobufUtil.encodePayload(data.userPayload);\n        }\n        const logMessage: LogMessage = protobufUtil.getLogMessage(schema, data, logMeta);\n        const logMetaObs: LogMetaObservability = {\n            timestamp: logMeta.timestamp,\n            rootId: logMeta.rootId,\n            sequence: logMeta.sequence,\n            schemaSequence: logMeta.schemaSequence,\n            loggerName: logMeta.loggerName,\n            pagePayload: logMessage.pagePayload,\n            loggerAppName: logMeta.loggerAppName,\n            connectionType: logMeta.connectionType,\n            appPayload: logMessage.appPayload,\n            clientSessionId: logMeta.clientSessionId,\n            age: logMeta.age,\n            receiverClientSessionId: logMeta.receiverClientSessionId,\n            receiverRootId: logMeta.receiverRootId\n        };\n        this._observability.log(schemaUtil.getSchemaId(schema), logMessage.data, logMetaObs);\n    }\n\n    receiveMetricsExtractors(metricsExtractors: MetricsExtractorMethods): void {\n        this._metricsExtractors = metricsExtractors;\n    }\n\n    // An app can call this method to listen for root activities that start and stop\n    // on the native side, in order to associate web activities with the same root id.\n    addRootActivityListeners(\n        activityStarted: (info: { id: string }) => void,\n        activityEnded: () => void\n    ): void {\n        utility.requireArgument(activityStarted, 'activityStarted', 'function');\n        utility.requireArgument(activityEnded, 'activityEnded', 'function');\n\n        this._observability.addRootActivityListeners(activityStarted, activityEnded);\n    }\n\n    // An app should call this method when it detects idle in the web view in order\n    // to inform the native app of the idle state.\n    notifyIdleDetected(timestamp: number): void {\n        this._observability.idleDetected(timestamp);\n    }\n\n    private _collectMetrics(): void {\n        if (this._metricsExtractors) {\n            const upCounters: Metric<number>[] = this._metricsExtractors.getAllUpCounters();\n            const valueRecorders: Metric<number[]>[] =\n                this._metricsExtractors.getAllValueRecorders();\n            const bucketHistograms: BucketMetric<number[]>[] =\n                this._metricsExtractors.getAllBucketHistograms();\n            const recorders: ValueRecorder[] = [];\n            const counters: UpCounter[] = [];\n            const histograms: BucketHistogram[] = [];\n\n            for (const valueRecorder of valueRecorders) {\n                const vr: ValueRecorder = {\n                    name: valueRecorder.getName(),\n                    createdTimestamp: valueRecorder.getCreatedOn(),\n                    lastUpdatedTimestamp: valueRecorder.getLastUpdatedOn(),\n                    values: valueRecorder.getData(),\n                    ownerName: valueRecorder.getOwnerName(),\n                    ownerAppName: valueRecorder.getOwnerAppName(),\n                    tags: this._getMetricTags(valueRecorder)\n                };\n                recorders.push(vr);\n                valueRecorder.reset();\n            }\n\n            for (const upCounter of upCounters) {\n                const uc: UpCounter = {\n                    name: upCounter.getName(),\n                    createdTimestamp: upCounter.getCreatedOn(),\n                    lastUpdatedTimestamp: upCounter.getLastUpdatedOn(),\n                    value: upCounter.getData(),\n                    ownerName: upCounter.getOwnerName(),\n                    ownerAppName: upCounter.getOwnerAppName(),\n                    tags: this._getMetricTags(upCounter)\n                };\n                counters.push(uc);\n                upCounter.reset();\n            }\n\n            for (const bucketHistogram of bucketHistograms) {\n                const bh: BucketHistogram = {\n                    name: bucketHistogram.getName(),\n                    createdTimestamp: bucketHistogram.getCreatedOn(),\n                    lastUpdatedTimestamp: bucketHistogram.getLastUpdatedOn(),\n                    values: bucketHistogram.getData(),\n                    buckets: bucketHistogram.getBuckets(),\n                    ownerName: bucketHistogram.getOwnerName(),\n                    ownerAppName: bucketHistogram.getOwnerAppName(),\n                    tags: this._getMetricTags(bucketHistogram)\n                };\n                histograms.push(bh);\n                bucketHistogram.reset();\n            }\n\n            if (recorders.length > 0 || counters.length > 0) {\n                const metrics: Metrics = {\n                    upCounters: counters,\n                    valueRecorders: recorders,\n                    bucketHistograms: histograms\n                };\n                this._observability.logMetrics(metrics);\n            }\n        }\n    }\n\n    private _getMetricTags<T>(metric: Metric<T>): MetricTag[] {\n        const metricsTags: MetricsTags = metric.getTags();\n\n        if (metricsTags) {\n            return Object.entries(metricsTags).map((entry) => {\n                const mt: MetricTag = {\n                    name: entry[0],\n                    value: entry[1].toString()\n                };\n                return mt;\n            });\n        }\n        return [];\n    }\n}\n"],"names":[],"mappings":"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"}