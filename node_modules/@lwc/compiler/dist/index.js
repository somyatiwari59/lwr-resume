/**
 * Copyright (C) 2023 salesforce.com, inc.
 */
import * as path from 'path';
import { isUndefined, isObject, getAPIVersionFromNumber, isBoolean, isAPIFeatureEnabled, isString } from '@lwc/shared';
import { invariant, CompilerValidationErrors, normalizeToCompilerError, TransformerErrors, DiagnosticLevel, CompilerError, generateCompilerError } from '@lwc/errors';
import * as styleCompiler from '@lwc/style-compiler';
import { compile } from '@lwc/template-compiler';
import * as babel from '@babel/core';
import babelClassPropertiesPlugin from '@babel/plugin-proposal-class-properties';
import babelObjectRestSpreadPlugin from '@babel/plugin-proposal-object-rest-spread';
import lwcClassTransformPlugin from '@lwc/babel-plugin-component';
import lockerBabelPluginTransformUnforgeables from '@locker/babel-plugin-transform-unforgeables';
import babelAsyncToGenPlugin from '@babel/plugin-transform-async-to-generator';
import babelAsyncGeneratorFunctionsPlugin from '@babel/plugin-proposal-async-generator-functions';

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const DEFAULT_OPTIONS = {
    isExplicitImport: false,
    preserveHtmlComments: false,
    enableStaticContentOptimization: true,
    // TODO [#3370]: remove experimental template expression flag
    experimentalComplexExpressions: false,
    disableSyntheticShadowSupport: false,
    enableLightningWebSecurityTransforms: false,
};
const DEFAULT_DYNAMIC_IMPORT_CONFIG = {
    loader: '',
    strictSpecifier: true,
};
const DEFAULT_STYLESHEET_CONFIG = {
    customProperties: {
        resolution: { type: 'native' },
    },
};
const DEFAULT_OUTPUT_CONFIG = {
    minify: false,
    sourcemap: false,
};
function validateTransformOptions(options) {
    validateOptions(options);
    return normalizeOptions(options);
}
function validateOptions(options) {
    invariant(!isUndefined(options), CompilerValidationErrors.MISSING_OPTIONS_OBJECT, [options]);
    if (!isUndefined(options.enableLwcSpread)) {
        // eslint-disable-next-line no-console
        console.warn(`"enableLwcSpread" property is deprecated. The value doesn't impact the compilation and can safely be removed.`);
    }
    if (!isUndefined(options.stylesheetConfig)) {
        validateStylesheetConfig(options.stylesheetConfig);
    }
    if (!isUndefined(options.outputConfig)) {
        validateOutputConfig(options.outputConfig);
    }
}
function validateStylesheetConfig(config) {
    const { customProperties } = config;
    if (!isUndefined(customProperties)) {
        const { resolution } = customProperties;
        if (!isUndefined(resolution)) {
            invariant(isObject(resolution), CompilerValidationErrors.INVALID_RESOLUTION_PROPERTY, [
                resolution,
            ]);
            const { type } = resolution;
            invariant(type === 'native' || type === 'module', CompilerValidationErrors.INVALID_TYPE_PROPERTY, [type]);
        }
    }
}
function isUndefinedOrBoolean(property) {
    return isUndefined(property) || isBoolean(property);
}
function validateOutputConfig(config) {
    invariant(isUndefinedOrBoolean(config.sourcemap), CompilerValidationErrors.INVALID_SOURCEMAP_PROPERTY, [config.sourcemap]);
    if (!isUndefined(config.minify)) {
        // eslint-disable-next-line no-console
        console.warn(`"OutputConfig.minify" property is deprecated. The value doesn't impact the compilation and can safely be removed.`);
    }
}
function normalizeOptions(options) {
    const outputConfig = Object.assign(Object.assign({}, DEFAULT_OUTPUT_CONFIG), options.outputConfig);
    const stylesheetConfig = {
        customProperties: Object.assign(Object.assign({}, DEFAULT_STYLESHEET_CONFIG.customProperties), (options.stylesheetConfig && options.stylesheetConfig.customProperties)),
    };
    const experimentalDynamicComponent = Object.assign(Object.assign({}, DEFAULT_DYNAMIC_IMPORT_CONFIG), options.experimentalDynamicComponent);
    const apiVersion = getAPIVersionFromNumber(options.apiVersion);
    return Object.assign(Object.assign(Object.assign({}, DEFAULT_OPTIONS), options), { stylesheetConfig,
        outputConfig,
        experimentalDynamicComponent,
        apiVersion });
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function styleTransform(src, filename, config) {
    const { customProperties } = config.stylesheetConfig;
    const styleCompilerConfig = {
        customProperties: {
            resolverModule: customProperties.resolution.type === 'module'
                ? customProperties.resolution.name
                : undefined,
        },
        scoped: config.scopedStyles,
        disableSyntheticShadowSupport: config.disableSyntheticShadowSupport,
        apiVersion: config.apiVersion,
    };
    let res;
    try {
        res = styleCompiler.transform(src, filename, styleCompilerConfig);
    }
    catch (e) {
        throw normalizeToCompilerError(TransformerErrors.CSS_TRANSFORMER_ERROR, e, { filename });
    }
    // Rollup only cares about the mappings property on the map. Since producing a source map for
    // the styles doesn't make sense, the transform returns an empty mappings.
    return {
        code: res.code,
        map: { mappings: '' },
    };
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Transforms a HTML template into module exporting a template function.
 * The transform also add a style import for the default stylesheet associated with
 * the template regardless if there is an actual style or not.
 */
function templateTransform(src, filename, options) {
    const { experimentalDynamicComponent, 
    // TODO [#3370]: remove experimental template expression flag
    experimentalComplexExpressions, preserveHtmlComments, enableStaticContentOptimization, customRendererConfig, enableDynamicComponents, experimentalDynamicDirective: deprecatedDynamicDirective, instrumentation, namespace, name, apiVersion, } = options;
    const experimentalDynamicDirective = deprecatedDynamicDirective !== null && deprecatedDynamicDirective !== void 0 ? deprecatedDynamicDirective : Boolean(experimentalDynamicComponent);
    let result;
    try {
        result = compile(src, {
            experimentalDynamicDirective,
            // TODO [#3370]: remove experimental template expression flag
            experimentalComplexExpressions,
            preserveHtmlComments,
            enableStaticContentOptimization,
            customRendererConfig,
            enableDynamicComponents,
            instrumentation,
            apiVersion,
        });
    }
    catch (e) {
        throw normalizeToCompilerError(TransformerErrors.HTML_TRANSFORMER_ERROR, e, { filename });
    }
    const fatalError = result.warnings.find((warning) => warning.level === DiagnosticLevel.Error);
    if (fatalError) {
        throw CompilerError.from(fatalError, { filename });
    }
    // The "Error" diagnostic level makes no sense to include here, because it would already have been
    // thrown above. As for "Log" and "Fatal", they are currently unused.
    const warnings = result.warnings.filter((_) => _.level === DiagnosticLevel.Warning);
    const scopeToken = generateScopeToken(filename, namespace, name, apiVersion);
    // Rollup only cares about the mappings property on the map. Since producing a source map for
    // the template doesn't make sense, the transform returns an empty mappings.
    return {
        code: serialize(result.code, filename, scopeToken),
        map: { mappings: '' },
        warnings,
        cssScopeTokens: [
            scopeToken,
            `${scopeToken}-host`, // implicit scope token created by `makeHostToken()` in `@lwc/engine-core`
        ],
    };
}
// The reason this hash code implementation [1] is chosen is because:
// 1. It has a very low hash collision rate - testing a list of 466,551 English words [2], it generates no collisions
// 2. It is fast - it can hash those 466k words in 70ms (Node 16, 2020 MacBook Pro)
// 3. The output size is reasonable (32-bit - this can be base-32 encoded at 10-11 characters)
//
// Also note that the reason we're hashing rather than generating a random number is because
// we want the output to be predictable given the input, which helps with caching.
//
// [1]: https://stackoverflow.com/a/52171480
// [2]: https://github.com/dwyl/english-words/blob/a77cb15f4f5beb59c15b945f2415328a6b33c3b0/words.txt
function generateHashCode(str) {
    const seed = 0;
    let h1 = 0xdeadbeef ^ seed;
    let h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
function escapeScopeToken(input) {
    // Minimal escape for strings containing the "@" and "#" characters, which are disallowed
    // in certain cases in attribute names
    return input.replace(/@/g, '___at___').replace(/#/g, '___hash___');
}
function generateScopeToken(filename, namespace, name, apiVersion) {
    const uniqueToken = `${namespace}-${name}_${path.basename(filename, path.extname(filename))}`;
    if (isAPIFeatureEnabled(0 /* APIFeature.LOWERCASE_SCOPE_TOKENS */, apiVersion)) {
        const hashCode = generateHashCode(uniqueToken);
        // This scope token is all lowercase so that it works correctly in case-sensitive namespaces (e.g. SVG).
        // It is deliberately designed to discourage people from relying on it by appearing somewhat random.
        // (But not totally random, because it's nice to have stable scope tokens for our own tests.)
        // Base-32 is chosen because it is not case-sensitive (0-v), and generates short strings with the given hash
        // code implementation (10-11 characters).
        return `lwc-${hashCode.toString(32)}`;
    }
    else {
        // This scope token is based on the namespace and name, and contains a mix of uppercase/lowercase chars
        return escapeScopeToken(uniqueToken);
    }
}
function serialize(code, filename, scopeToken) {
    const cssRelPath = `./${path.basename(filename, path.extname(filename))}.css`;
    const scopedCssRelPath = `./${path.basename(filename, path.extname(filename))}.scoped.css`;
    let buffer = '';
    buffer += `import { freezeTemplate } from "lwc";\n\n`;
    buffer += `import _implicitStylesheets from "${cssRelPath}";\n\n`;
    buffer += `import _implicitScopedStylesheets from "${scopedCssRelPath}?scoped=true";\n\n`;
    buffer += code;
    buffer += '\n\n';
    buffer += 'if (_implicitStylesheets) {\n';
    buffer += `  tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);\n`;
    buffer += `}\n`;
    buffer += 'if (_implicitScopedStylesheets) {\n';
    buffer += `  tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);\n`;
    buffer += `}\n`;
    buffer += `tmpl.stylesheetToken = "${scopeToken}";\n`;
    // Note that `renderMode` and `slots` are already rendered in @lwc/template-compiler and appear
    // as `code` above. At this point, no more expando props should be added to `tmpl`.
    buffer += 'freezeTemplate(tmpl);\n';
    return buffer;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function scriptTransform(code, filename, options) {
    const { isExplicitImport, experimentalDynamicComponent: dynamicImports, outputConfig: { sourcemap }, enableLightningWebSecurityTransforms, namespace, name, instrumentation, apiVersion, } = options;
    const lwcBabelPluginOptions = {
        isExplicitImport,
        dynamicImports,
        namespace,
        name,
        instrumentation,
        apiVersion,
    };
    const plugins = [
        [lwcClassTransformPlugin, lwcBabelPluginOptions],
        [babelClassPropertiesPlugin, { loose: true }],
        // This plugin should be removed in a future version. The object-rest-spread is
        // already a stage 4 feature. The LWC compile should leave this syntax untouched.
        babelObjectRestSpreadPlugin,
    ];
    if (enableLightningWebSecurityTransforms) {
        plugins.push(lockerBabelPluginTransformUnforgeables, babelAsyncToGenPlugin, babelAsyncGeneratorFunctionsPlugin);
    }
    let result;
    try {
        result = babel.transformSync(code, {
            filename,
            sourceMaps: sourcemap,
            // Prevent Babel from loading local configuration.
            babelrc: false,
            configFile: false,
            // Force Babel to generate new line and white spaces. This prevent Babel from generating
            // an error when the generated code is over 500KB.
            compact: false,
            plugins,
        });
    }
    catch (e) {
        throw normalizeToCompilerError(TransformerErrors.JS_TRANSFORMER_ERROR, e, { filename });
    }
    return {
        code: result.code,
        map: result.map,
    };
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Transforms the passed code. Returning a Promise of an object with the generated code, source map
 * and gathered metadata.
 *
 * @deprecated Use transformSync instead.
 */
function transform(src, filename, options) {
    validateArguments(src, filename);
    return new Promise((resolve, reject) => {
        try {
            const res = transformSync(src, filename, options);
            resolve(res);
        }
        catch (error) {
            reject(error);
        }
    });
}
/**
 * Transform the passed source code. Returning an object with the generated code, source map and
 * gathered metadata.
 */
function transformSync(src, filename, options) {
    validateArguments(src, filename);
    const normalizedOptions = validateTransformOptions(options);
    return transformFile(src, filename, normalizedOptions);
}
function validateArguments(src, filename) {
    invariant(isString(src), TransformerErrors.INVALID_SOURCE, [src]);
    invariant(isString(filename), TransformerErrors.INVALID_ID, [filename]);
}
function transformFile(src, filename, options) {
    let transformer;
    switch (path.extname(filename)) {
        case '.html':
            transformer = templateTransform;
            break;
        case '.css':
            transformer = styleTransform;
            break;
        case '.ts':
        case '.js':
            transformer = scriptTransform;
            break;
        default:
            throw generateCompilerError(TransformerErrors.NO_AVAILABLE_TRANSFORMER, {
                messageArgs: [filename],
                origin: { filename },
            });
    }
    return transformer(src, filename, options);
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const version = "3.0.0";

export { transform, transformSync, version };
/** version: 3.0.0 */
//# sourceMappingURL=index.js.map
