var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/lwr/src/cli/commands/build.ts
__markAsModule(exports);
__export(exports, {
  createBuildCommand: () => createBuildCommand
});
var import_commander = __toModule(require("commander"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_path = __toModule(require("path"));
var import_utils = __toModule(require("../utils.cjs"));
var import_config = __toModule(require("@lwrjs/config"));
function createBuildCommand() {
  return new import_commander.Command("build").description("Build an LWR application").addOption((0, import_utils.getTargetOption)()).addOption((0, import_utils.getModeOption)().choices(["prod", "prod-compat"])).option("-o, --output <directory>", `[string] output directory`).option("--clean", `[boolean] delete the output directory`, false).option("-r, --routes <routes...>", `routes`).option("-m, --modules <modules...>", `modules`).option("-l, --locales <locales...>", `locales`).option("--minify", "[boolean] minifies build output", false).action(async (options, cmd) => {
    import_shared_utils.logger.info("[build] Building lwr application");
    const {rootDir, config, output, mode, clean, target, minify, routes, modules, locales} = cmd.optsWithGlobals();
    const outputDir = output ? output : (0, import_utils.getDefaultBuildDirectory)(rootDir, config, target);
    const aConfig = (0, import_config.loadConfig)({rootDir, lwrConfigFile: config});
    let ssrFunctionNodeVersion;
    if (target === "mrt") {
      ssrFunctionNodeVersion = getSuggestedNodeVersion();
    }
    if (clean) {
      import_shared_utils.logger.info(`[build] Clearing output directory: ${outputDir}`);
      import_fs_extra.default.rmSync(outputDir, {recursive: true, force: true});
    } else {
      if (import_fs_extra.default.existsSync(`${outputDir}`)) {
        import_shared_utils.logger.warn(`[build] Output directory already exists. Previously generated files will not be deleted. If you did not intend to do this, re-run with --clean true`);
      }
    }
    const generatedSitePath = target === "mrt" ? import_path.default.join(outputDir, "site") : outputDir;
    const {generateStaticSite} = await Promise.resolve().then(() => __toModule(require("@lwrjs/core")));
    try {
      const _additionalRoutes = routes || aConfig.appConfig.staticSiteGenerator._additionalRoutePaths || [];
      const _additionalModules = modules || aConfig.appConfig.staticSiteGenerator._additionalModules || [];
      const theLocales = locales || aConfig.appConfig.staticSiteGenerator.locales || [];
      if (target === "mrt") {
        _additionalModules.push("@lwc/engine-server");
      }
      const staticSiteGenerator = {
        outputDir: generatedSitePath,
        skipCleanOutputDir: true,
        _additionalRoutes,
        _additionalModules,
        locales: theLocales
      };
      await generateStaticSite({
        serverMode: mode,
        staticSiteGenerator
      });
    } catch (error) {
      import_shared_utils.logger.error(error);
    }
    if (target === "mrt") {
      const config2 = aConfig.appConfig;
      const rootDir2 = config2.rootDir;
      try {
        process.env.SSR_STATIC_BUNDLES = "true";
        import_shared_utils.logger.info("[build] Generating ssr.js");
        const {buildServer} = await Promise.resolve().then(() => __toModule(require("@lwrjs/tools")));
        const castMinify = minify == "false" ? false : !!minify;
        await buildServer({rootDir: rootDir2, serverMode: mode, staticSiteGenerator: {outputDir: "site"}}, {outputDir, minify: castMinify});
      } catch (error) {
        import_shared_utils.logger.error(error);
      }
      const dirsInConfig = [];
      try {
        import_fs_extra.default.writeFileSync(import_path.default.join(outputDir, "loader.js"), "");
        const packageJson = JSON.parse(import_fs_extra.default.readFileSync(import_path.default.join(rootDir2, "package.json"), "utf-8"));
        import_fs_extra.default.writeFileSync(import_path.default.join(outputDir, "package.json"), JSON.stringify({
          name: packageJson.name ? packageJson.name : "lwr-app",
          version: packageJson.version ? packageJson.version : "1.0.0"
        }, null, 4));
        import_shared_utils.logger.info("[build] copying source files");
        const contentDir = config2.contentDir;
        if (import_fs_extra.default.existsSync(contentDir)) {
          const relPath = contentDir.substring(rootDir2.length);
          dirsInConfig.push(import_path.default.join(".", relPath, "**"));
          const contentOutputDir = import_path.default.join(outputDir, relPath);
          import_fs_extra.default.copySync(contentDir, contentOutputDir);
        }
        const layoutDir = config2.layoutsDir;
        if (import_fs_extra.default.existsSync(layoutDir)) {
          const relPath = layoutDir.substring(rootDir2.length);
          dirsInConfig.push(import_path.default.join(".", relPath, "**"));
          const layoutOutputDir = import_path.default.join(outputDir, relPath);
          import_fs_extra.default.copySync(layoutDir, layoutOutputDir);
        }
        const globalDataDir = config2.globalDataDir;
        if (import_fs_extra.default.existsSync(globalDataDir)) {
          const relPath = globalDataDir.substring(rootDir2.length);
          dirsInConfig.push(import_path.default.join(".", relPath, "**"));
          const globalDataOutputDir = import_path.default.join(outputDir, relPath);
          import_fs_extra.default.copySync(globalDataDir, globalDataOutputDir);
        }
      } catch (e) {
        import_shared_utils.logger.error(e);
      }
      import_shared_utils.logger.info("[build] generating default.json");
      try {
        const configFile = import_path.default.join(rootDir2, "config", "default.json");
        const outputConfigFile = import_path.default.join(outputDir, "config", "default.json");
        import_fs_extra.default.ensureDirSync(import_path.default.join(outputDir, "config"));
        if (import_fs_extra.default.existsSync(configFile)) {
          import_shared_utils.logger.warn("[build] You have a config file already defined, using that rather than generating one.");
          import_fs_extra.default.copyFileSync(configFile, outputConfigFile);
        } else {
          const defaultConfigContent = {
            ssrEnabled: true,
            ssrOnly: [
              "config/**",
              "loader.js",
              "package.json",
              "ssr.js",
              "site/.metadata/**"
            ],
            ssrShared: [],
            ssrParameters: {
              ssrFunctionNodeVersion,
              proxyConfigs: []
            }
          };
          defaultConfigContent.ssrOnly.push(...dirsInConfig);
          if (process.env.SSR_ONLY_DIRS) {
            defaultConfigContent.ssrOnly.push(...process.env.SSR_ONLY_DIRS.split(",").map((value) => value.trim()));
          }
          defaultConfigContent.ssrShared = process.env.ASSETS_ON_LAMBDA ? ["site/**"] : ["site/1/bundle/**", "site/1/resource/**"];
          if (process.env.SSR_SHARED_DIRS) {
            defaultConfigContent.ssrShared.push(...process.env.SSR_SHARED_DIRS.split(",").map((value) => value.trim()));
          }
          import_fs_extra.default.writeFileSync(outputConfigFile, JSON.stringify(defaultConfigContent, null, 4));
        }
      } catch (e) {
        import_shared_utils.logger.error(e);
      }
      import_shared_utils.logger.info("[build] complete");
    }
  });
}
var MRT_VERSIONS = [16, 18];
function getSuggestedNodeVersion() {
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split(".")[0]);
  if (!MRT_VERSIONS.includes(majorVersion)) {
    import_shared_utils.logger.error(`Node Version ${nodeVersion} is not one of LWR Lambda's supported versions ${MRT_VERSIONS.join(", ")}`);
    process.exit(1);
  }
  return `${majorVersion}.x`;
}
