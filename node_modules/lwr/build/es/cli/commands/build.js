import { Command } from 'commander';
import { logger } from '@lwrjs/shared-utils';
import fs from 'fs-extra';
import path from 'path';
import { getDefaultBuildDirectory, getModeOption, getTargetOption } from '../utils.js';
import { loadConfig } from '@lwrjs/config';
export function createBuildCommand() {
    return new Command('build')
        .description('Build an LWR application')
        .addOption(getTargetOption())
        .addOption(getModeOption().choices(['prod', 'prod-compat']))
        .option('-o, --output <directory>', `[string] output directory`)
        .option('--clean', `[boolean] delete the output directory`, false)
        .option('-r, --routes <routes...>', `routes`)
        .option('-m, --modules <modules...>', `modules`)
        .option('-l, --locales <locales...>', `locales`)
        .option('--minify', '[boolean] minifies build output', false)
        .action(async (options, cmd) => {
        logger.info('[build] Building lwr application');
        const { rootDir, config, output, mode, clean, target, minify, routes, modules, locales } = cmd.optsWithGlobals();
        const outputDir = output ? output : getDefaultBuildDirectory(rootDir, config, target);
        const aConfig = loadConfig({ rootDir, lwrConfigFile: config });
        let ssrFunctionNodeVersion;
        if (target === 'mrt') {
            // Check the node version (to fail early)
            ssrFunctionNodeVersion = getSuggestedNodeVersion();
        }
        if (clean) {
            logger.info(`[build] Clearing output directory: ${outputDir}`);
            fs.rmSync(outputDir, { recursive: true, force: true });
        }
        else {
            if (fs.existsSync(`${outputDir}`)) {
                logger.warn(`[build] Output directory already exists. Previously generated files will not be deleted. If you did not intend to do this, re-run with --clean true`);
            }
        }
        const generatedSitePath = target === 'mrt' ? path.join(outputDir, 'site') : outputDir;
        const { generateStaticSite } = await import('@lwrjs/core');
        try {
            // Use existing staticSiteGenerator config as defaults for now until we finish spikes on new design
            const _additionalRoutes = routes || aConfig.appConfig.staticSiteGenerator._additionalRoutePaths || [];
            const _additionalModules = modules || aConfig.appConfig.staticSiteGenerator._additionalModules || [];
            const theLocales = locales || aConfig.appConfig.staticSiteGenerator.locales || [];
            if (target === 'mrt') {
                // Pre-generate the LWC SSR package for MRT
                _additionalModules.push('@lwc/engine-server');
            }
            const staticSiteGenerator = {
                outputDir: generatedSitePath,
                skipCleanOutputDir: true,
                _additionalRoutes,
                _additionalModules,
                locales: theLocales,
            };
            await generateStaticSite({
                serverMode: mode,
                staticSiteGenerator,
            });
        }
        catch (error) {
            logger.error(error);
        }
        // If target === MRT - we will always deploy to "app" dir
        if (target === 'mrt') {
            const config = aConfig.appConfig;
            const rootDir = config.rootDir;
            try {
                // copy over source files we need on the server
                process.env.SSR_STATIC_BUNDLES = 'true';
                logger.info('[build] Generating ssr.js');
                const { buildServer } = await import('@lwrjs/tools');
                // Catch minify flag is the literal 'false'
                const castMinify = minify == 'false' ? false : !!minify;
                await buildServer(
                // TODO not sure why but we reference staticSiteGenerator.outputDir somewhere in our buildServer plugin
                // hardcoding outputDir to 'site' since this no longer changes
                { rootDir, serverMode: mode, staticSiteGenerator: { outputDir: 'site' } }, { outputDir: outputDir, minify: castMinify });
            }
            catch (error) {
                logger.error(error);
            }
            // Keep track of directories to add to mrt config
            const dirsInConfig = [];
            try {
                // TODO - hack for loader.js
                fs.writeFileSync(path.join(outputDir, 'loader.js'), '');
                // No longer needed if we aren't modifying package.json
                const packageJson = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf-8'));
                // write the new package.json into the MRT output directory
                fs.writeFileSync(path.join(outputDir, 'package.json'), JSON.stringify({
                    name: packageJson.name ? packageJson.name : 'lwr-app',
                    version: packageJson.version ? packageJson.version : '1.0.0',
                }, null, 4));
                // Copy needed source files
                logger.info('[build] copying source files');
                // Content
                const contentDir = config.contentDir;
                if (fs.existsSync(contentDir)) {
                    const relPath = contentDir.substring(rootDir.length);
                    dirsInConfig.push(path.join('.', relPath, '**'));
                    const contentOutputDir = path.join(outputDir, relPath);
                    fs.copySync(contentDir, contentOutputDir);
                }
                // Layouts
                const layoutDir = config.layoutsDir;
                if (fs.existsSync(layoutDir)) {
                    const relPath = layoutDir.substring(rootDir.length);
                    dirsInConfig.push(path.join('.', relPath, '**'));
                    const layoutOutputDir = path.join(outputDir, relPath);
                    fs.copySync(layoutDir, layoutOutputDir);
                }
                // Data
                const globalDataDir = config.globalDataDir;
                if (fs.existsSync(globalDataDir)) {
                    const relPath = globalDataDir.substring(rootDir.length);
                    dirsInConfig.push(path.join('.', relPath, '**'));
                    const globalDataOutputDir = path.join(outputDir, relPath);
                    fs.copySync(globalDataDir, globalDataOutputDir);
                }
            }
            catch (e) {
                logger.error(e);
            }
            // generate config/default.js/json
            logger.info('[build] generating default.json');
            try {
                // TODO we could add some kind of merging later, but I think its too complex and not really worth it
                const configFile = path.join(rootDir, 'config', 'default.json');
                const outputConfigFile = path.join(outputDir, 'config', 'default.json');
                fs.ensureDirSync(path.join(outputDir, 'config'));
                if (fs.existsSync(configFile)) {
                    // If they have defined their own config, use that, but display a warning
                    logger.warn('[build] You have a config file already defined, using that rather than generating one.');
                    fs.copyFileSync(configFile, outputConfigFile);
                }
                else {
                    // Otherwise create a new config
                    const defaultConfigContent = {
                        // Enables building the files necessary for server-side rendering.
                        ssrEnabled: true,
                        // Files available to the server-side rendering system and NOT through the /mobify/bundle/ path.
                        ssrOnly: [
                            'config/**',
                            'loader.js',
                            'package.json',
                            'ssr.js',
                            'site/.metadata/**',
                        ],
                        // Files available to the server-side rendering system AND through the /mobify/bundle/ path.
                        // The site metadata folder starts with a ".", so it is automatically excluded
                        ssrShared: [],
                        // Additional parameters that configure Express app behavior.
                        ssrParameters: {
                            ssrFunctionNodeVersion,
                            proxyConfigs: [],
                        },
                    };
                    // Add our source directories to the ssrOnly config
                    defaultConfigContent.ssrOnly.push(...dirsInConfig);
                    // Allow unofficial configuration of ssrOnly dirs via environment variable for now until we settle the official api
                    if (process.env.SSR_ONLY_DIRS) {
                        defaultConfigContent.ssrOnly.push(...process.env.SSR_ONLY_DIRS.split(',').map((value) => value.trim()));
                    }
                    // Configure ssrShared for assets
                    defaultConfigContent.ssrShared = process.env.ASSETS_ON_LAMBDA
                        ? ['site/**']
                        : ['site/1/bundle/**', 'site/1/resource/**'];
                    // Allow unofficial configuration of ssrShared dirs via environment variable for now until we settle the official api
                    if (process.env.SSR_SHARED_DIRS) {
                        defaultConfigContent.ssrShared.push(...process.env.SSR_SHARED_DIRS.split(',').map((value) => value.trim()));
                    }
                    // If not, lets create them a default config that works with LWR
                    fs.writeFileSync(outputConfigFile, JSON.stringify(defaultConfigContent, null, 4));
                }
            }
            catch (e) {
                logger.error(e);
            }
            logger.info('[build] complete');
        }
    });
}
const MRT_VERSIONS = [16, 18];
function getSuggestedNodeVersion() {
    const nodeVersion = process.version;
    const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
    if (!MRT_VERSIONS.includes(majorVersion)) {
        logger.error(`Node Version ${nodeVersion} is not one of LWR Lambda's supported versions ${MRT_VERSIONS.join(', ')}`);
        process.exit(1);
    }
    return `${majorVersion}.x`;
}
//# sourceMappingURL=build.js.map