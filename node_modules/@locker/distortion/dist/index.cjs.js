/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var shared$LWS = require('@locker/shared');
var sharedDom$LWS = require('@locker/shared-dom');
var internalPolicy$LWS = require('@locker/internal-policy');
var trustedTypes$LWS = require('@locker/trusted-types');
var sharedUrl$LWS = require('@locker/shared-url');
var htmlSanitizer$LWS = require('@locker/html-sanitizer');
const ERR_ILLEGAL_CONSTRUCTOR$LWS = 'Illegal constructor';
const ERR_ILLEGAL_INVOCATION$LWS = 'Illegal invocation.';
const ERR_NO_NEW_OP_HTML_ELEMENT$LWS = "Failed to construct 'HTMLElement': Please use the 'new' operator, this DOM object constructor cannot be called as a function.";
let currentRegistry$LWS;
let currentUpgradingInstance$LWS;
const definitionCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
const globalRegistryCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
const pivotCtorCache$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
const sandboxRegistryCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
/* eslint-disable no-underscore-dangle */
class VirtualRegistry$LWS {
  constructor(document$LWS, originalHTMLElementCtor$LWS = shared$LWS.getUnmaskedFunction(shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDefaultViewGetter, document$LWS, []).HTMLElement)) {
    this._awaitingUpgrade = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
    this._definedCtors = shared$LWS.toSafeSet(new shared$LWS.SetCtor());
    this._definitionByElement = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
    this._definitionByTag = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
    this._pendingRegistryByElement = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
    this._document = document$LWS;
    this._originalHTMLElementCtor = originalHTMLElementCtor$LWS;
  }
  applyDefine(cer$LWS, args$LWS) {
    const {
      0: tagName$LWS,
      1: LocalCtor$LWS,
      2: options$LWS
    } = args$LWS;
    if (options$LWS && options$LWS.extends) {
      throw new DOMException("NotSupportedError: 'extends' key in customElements.define() options is not supported.");
    }
    if (this._definitionByTag.has(tagName$LWS)) {
      throw new DOMException(`Failed to execute 'define' on 'CustomElementRegistry': the name "${tagName$LWS}" has already been used with this registry.`);
    }
    if (this._definedCtors.has(LocalCtor$LWS)) {
      throw new DOMException("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry.");
    }
    const definition$LWS = getDefinitionForConstructor$LWS(LocalCtor$LWS);
    let PivotCtor$LWS = pivotCtorCache$LWS.get(tagName$LWS);
    if (PivotCtor$LWS === undefined) {
      PivotCtor$LWS = createPivotingClass$LWS(this._document, this._originalHTMLElementCtor, definition$LWS, tagName$LWS);
      // Register a pivoting class which will handle global registry initializations.
      shared$LWS.ReflectApply(sharedDom$LWS.CustomElementRegistryProtoDefine, cer$LWS, [tagName$LWS, PivotCtor$LWS]);
    }
    // We MUST keep track of the constructor used to define custom elements
    // to prevent accidental re-use of constructors in userland code.
    //
    // Only cache AFTER `CustomElementRegistryProtoDefine` has been called
    // because if it throws an error (e.g. for an invalid tag name), then we
    // don't want to cache anything.
    definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
    pivotCtorCache$LWS.set(tagName$LWS, PivotCtor$LWS);
    this._definitionByTag.set(tagName$LWS, definition$LWS);
    this._definedCtors.add(LocalCtor$LWS);
    // For globally defined custom elements, the definition associated
    // with the `LocalCtor` has a back-pointer to `PivotCtor` in case the
    // user new's the `LocalCtor`, so we know how to create the underlying
    // element.
    definition$LWS.PivotCtor = PivotCtor$LWS;
    // Immediately upgrade any elements created in this scope before define was called,
    // e.g. LWC using a tagName in a template before the same tagName is
    // registered.
    const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
    if (awaiting$LWS) {
      awaiting$LWS.forEach(element$LWS => {
        const originalDefinition$LWS = this._pendingRegistryByElement.get(element$LWS);
        // istanbul ignore else: it is unnecessary to cover the else path here
        if (originalDefinition$LWS) {
          this._pendingRegistryByElement.delete(element$LWS);
          this.upgrade(element$LWS, originalDefinition$LWS, definition$LWS);
        }
      });
    }
  }
  applyGet(cer$LWS, args$LWS) {
    const {
      0: tagName$LWS
    } = args$LWS;
    const definition$LWS = this._definitionByTag.get(tagName$LWS);
    return definition$LWS && definition$LWS.LocalCtor || shared$LWS.ReflectApply(sharedDom$LWS.CustomElementRegistryProtoGet, cer$LWS, [tagName$LWS]);
  }
  applyWhenDefined(cer$LWS, args$LWS) {
    const {
      0: tagName$LWS
    } = args$LWS;
    const promise$LWS = shared$LWS.ReflectApply(sharedDom$LWS.CustomElementRegistryProtoWhenDefined, cer$LWS, args$LWS);
    return new shared$LWS.PromiseCtor((resolve$LWS, reject$LWS) => {
      shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, promise$LWS, [() => {
        const definition$LWS = this._definitionByTag.get(tagName$LWS);
        if (definition$LWS) {
          resolve$LWS(definition$LWS.LocalCtor);
        }
      }, reject$LWS]);
    });
  }
  getDefinition(instance$LWS) {
    return this._definitionByElement.get(instance$LWS);
  }
  newCtor(instance$LWS, newTarget$LWS, originalHTMLElementCtor$LWS) {
    // Upgrading case: the pivoting class constructor was run by the
    // browser's native custom elements and we're in the process of running
    // the "constructor call trick" on the natively constructed instance,
    // so just return that here.
    const pendingUpgrade$LWS = currentUpgradingInstance$LWS;
    if (pendingUpgrade$LWS) {
      currentUpgradingInstance$LWS = undefined;
      return pendingUpgrade$LWS;
    }
    // NOTE: This precaution is necessary because custom elements created outside
    // of the sandbox are not discoverable, which would result in a failure.
    // In case the custom element is not found, the code will automatically
    // resort to using the global custom element registry.
    // Construction case: We need to construct the pivoting instance and
    // return it. This is possible when the user instantiate it via
    // `new LocalCtor()`.
    const {
      constructor: LocalCtor$LWS
    } = instance$LWS;
    const definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
    if (definition$LWS === undefined || typeof definition$LWS.PivotCtor !== 'function') {
      // If we can get the tag name without triggering "Illegal invocation", then
      // it's plausible that this is an instance of a registered custom element
      // that was defined _before_ LWS was run. Attempting to invoke the getter
      // on an instance that wasn't constructed from a registered definition
      // will not have the Element prototype in its chain and will fail with
      // an "Illegal invocation" exception.
      try {
        shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoTagNameGetter, this, []);
        return instance$LWS;
      } catch (_unused$LWS) {
        return shared$LWS.ReflectConstruct(originalHTMLElementCtor$LWS, [], newTarget$LWS);
      }
    }
    // This constructor is ONLY invoked when it is the user instantiating
    // an element via `new LocalCtor(`) while `LocalCtor` is a locally
    // registered constructor.
    return new definition$LWS.PivotCtor(this, definition$LWS);
  }
  scheduleConnectedCallback(instance$LWS, tagName$LWS) {
    // Register for upgrade when defined (only when connected, so we don't leak).
    let awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
    if (awaiting$LWS === undefined) {
      awaiting$LWS = shared$LWS.toSafeSet(new shared$LWS.SetCtor());
      this._awaitingUpgrade.set(tagName$LWS, awaiting$LWS);
    }
    awaiting$LWS.add(instance$LWS);
  }
  scheduleDisconnectedCallback(instance$LWS, tagName$LWS) {
    // Un-register for upgrade when defined (so we don't leak).
    const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
    // istanbul ignore else: currently unreachable via tests
    if (awaiting$LWS) {
      awaiting$LWS.delete(instance$LWS);
    }
  }
  scheduleOrUpgrade(instance$LWS, tagName$LWS, originalDefinition$LWS) {
    const definition$LWS = this._definitionByTag.get(tagName$LWS);
    if (definition$LWS) {
      // Browser's initiated a controlled instantiation where we
      // were able to set up the internal registry and the definition.
      this.upgrade(instance$LWS, originalDefinition$LWS, definition$LWS);
    } else {
      // This is the case in which there is no definition yet, and we
      // need to add it to the pending queue just in case it eventually
      // gets defined locally.
      this._pendingRegistryByElement.set(instance$LWS, originalDefinition$LWS);
      // We need to install the minimum HTMLElement prototype so that
      // this instance works like a regular element without a registered
      // definition. `this.instanceRegistry.upgrade()` will eventually
      // install the full custom element prototype.
      shared$LWS.ReflectSetPrototypeOf(instance$LWS, this._originalHTMLElementCtor.prototype);
    }
  }
  setDefinition(instance$LWS, pivotDefinition$LWS) {
    shared$LWS.ReflectSetPrototypeOf(instance$LWS, pivotDefinition$LWS.LocalCtor.prototype);
    this._definitionByElement.set(instance$LWS, pivotDefinition$LWS);
  }
  // Helper to upgrade an instance with a custom element definition using the
  // "constructor call trick".
  upgrade(instance$LWS, originalDefinition$LWS, pivotDefinition$LWS) {
    const {
      LocalCtor: LocalCtor$LWS,
      connectedCallback: connectedCallback$LWS
    } = pivotDefinition$LWS;
    this.setDefinition(instance$LWS, pivotDefinition$LWS);
    // This path will be taken when any _globally_ registered tag name has
    // more than one possible definition. See explanation at `patchAttributes()`.
    if (pivotDefinition$LWS !== originalDefinition$LWS) {
      patchAttributes$LWS(instance$LWS, originalDefinition$LWS, pivotDefinition$LWS);
    }
    // Tricking the construction path to believe that a new instance is being
    // created, that way it will execute the super initialization mechanism
    // but the HTMLElement constructor will reuse the instance by returning
    // the `currentUpgradingInstance`. This is by far the most important piece
    // of the puzzle.
    currentUpgradingInstance$LWS = instance$LWS;
    shared$LWS.ReflectConstruct(LocalCtor$LWS, []);
    const tagName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoTagNameGetter, instance$LWS, []);
    const tagNameLowerCased$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, tagName$LWS, []);
    const awaiting$LWS = this._awaitingUpgrade.get(tagNameLowerCased$LWS);
    if (awaiting$LWS && awaiting$LWS.size) {
      triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS);
      // @TODO: Maybe this should only be done when there is something
      // awaiting upgrade?
      // `awaiting` is a safe Set.
      const needsConnectedCallback$LWS = awaiting$LWS.has(instance$LWS);
      // istanbul ignore else: currently unreachable via tests
      if (needsConnectedCallback$LWS && shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoIsConnectedGetter, instance$LWS, [])) {
        if (connectedCallback$LWS) {
          shared$LWS.ReflectApply(connectedCallback$LWS, instance$LWS, []);
        }
        awaiting$LWS.delete(instance$LWS);
        if (!awaiting$LWS.size) {
          this._awaitingUpgrade.delete(tagNameLowerCased$LWS);
        }
      }
    }
  }
}
/* eslint-enable no-underscore-dangle */
function createDefinitionRecord$LWS(LocalCtor$LWS) {
  const {
    connectedCallback: connectedCallback$LWS,
    disconnectedCallback: disconnectedCallback$LWS,
    adoptedCallback: adoptedCallback$LWS,
    attributeChangedCallback: attributeChangedCallback$LWS
  } = LocalCtor$LWS.prototype;
  const observedAttributes$LWS = shared$LWS.toSafeSet(new shared$LWS.SetCtor(LocalCtor$LWS.observedAttributes || []));
  return {
    adoptedCallback: adoptedCallback$LWS,
    attributeChangedCallback: attributeChangedCallback$LWS,
    connectedCallback: connectedCallback$LWS,
    disconnectedCallback: disconnectedCallback$LWS,
    LocalCtor: LocalCtor$LWS,
    observedAttributes: observedAttributes$LWS,
    PivotCtor: undefined
  };
}
// Helper to create stand-in element for each tagName registered that delegates out to the
// registry for the given element.
function createPivotingClass$LWS(document$LWS, originalHTMLElementCtor$LWS,
// This is the definition that user code provided to customElements.define(tagName, definition)
originalDefinition$LWS, tagName$LWS) {
  var _a$LWS;
  return _a$LWS = class PivotCtor$LWS extends originalHTMLElementCtor$LWS {
    constructor(localRegistry$LWS, definition$LWS) {
      // This constructor can only be invoked by:
      // a) The browser instantiating  an element from parsing or via
      //    `document.createElement()`.
      // b) A `new LocalCtor()` call from the blue realm (system mode).
      // c) A `new LocalCtor()` call from the red realm (sandbox).
      super();
      if (localRegistry$LWS && definition$LWS) {
        this.instanceRegistry = localRegistry$LWS;
        localRegistry$LWS.setDefinition(this, definition$LWS);
      } else {
        this.instanceRegistry =
        // Usually `el.innerHTML` or any other parsing driven
        // initialization.
        getNodeRegistry$LWS(document$LWS, this) ||
        // Usually `document.createElement()`,
        // or any DOM API that has been patched to call
        // `setCustomElementsRegistry(globalObject, key)`
        // prior to element creation.
        getCurrentRegistry$LWS() ||
        // Global stuff.
        getGlobalCustomElementRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS);
        this.instanceRegistry.scheduleOrUpgrade(this, tagName$LWS, originalDefinition$LWS);
      }
    }
    connectedCallback() {
      const {
        instanceRegistry: instanceRegistry$LWS
      } = this;
      const definition$LWS = instanceRegistry$LWS.getDefinition(this);
      if (definition$LWS) {
        const {
          connectedCallback: connectedCallback$LWS
        } = definition$LWS;
        if (connectedCallback$LWS) {
          shared$LWS.ReflectApply(connectedCallback$LWS, this, []);
        }
      } else {
        instanceRegistry$LWS.scheduleConnectedCallback(this, tagName$LWS);
      }
    }
    disconnectedCallback() {
      const {
        instanceRegistry: instanceRegistry$LWS
      } = this;
      const definition$LWS = instanceRegistry$LWS.getDefinition(this);
      if (definition$LWS) {
        const {
          disconnectedCallback: disconnectedCallback$LWS
        } = definition$LWS;
        if (disconnectedCallback$LWS) {
          shared$LWS.ReflectApply(disconnectedCallback$LWS, this, []);
        }
      } else {
        instanceRegistry$LWS.scheduleDisconnectedCallback(this, tagName$LWS);
      }
    }
    adoptedCallback() {
      const definition$LWS = this.instanceRegistry.getDefinition(this);
      // istanbul ignore else: currently unreachable via tests
      if (definition$LWS) {
        const {
          adoptedCallback: adoptedCallback$LWS
        } = definition$LWS;
        // istanbul ignore else: currently unreachable via tests
        if (adoptedCallback$LWS) {
          shared$LWS.ReflectApply(adoptedCallback$LWS, this, []);
        }
      }
    }
    attributeChangedCallback(name$LWS, oldValue$LWS, newValue$LWS) {
      const definition$LWS = this.instanceRegistry.getDefinition(this);
      // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
      const attributeChangedCallback$LWS = definition$LWS == null ? void 0 : definition$LWS.attributeChangedCallback;
      // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
      const observedAttributes$LWS = definition$LWS == null ? void 0 : definition$LWS.observedAttributes;
      // If both definitions are the same, then the observedAttributes is the same,
      // but if they are different and only if the runtime definition has the attribute
      // marked as observed, then it should invoke attributeChangedCallback.
      if (typeof attributeChangedCallback$LWS === 'function' && (originalDefinition$LWS === definition$LWS || observedAttributes$LWS != null && observedAttributes$LWS.has(name$LWS))) {
        shared$LWS.ReflectApply(attributeChangedCallback$LWS, this, [name$LWS, oldValue$LWS, newValue$LWS]);
      }
    }
  }, _a$LWS.observedAttributes = [...originalDefinition$LWS.observedAttributes], _a$LWS;
}
function deleteGlobalCustomElementRegistry$LWS(document$LWS) {
  globalRegistryCache$LWS.delete(document$LWS);
}
function getCurrentRegistry$LWS() {
  const registry$LWS = currentRegistry$LWS;
  currentRegistry$LWS = undefined;
  return registry$LWS;
}
function getDefinitionForConstructor$LWS(LocalCtor$LWS) {
  const proto$LWS = typeof LocalCtor$LWS === 'function' ? LocalCtor$LWS.prototype : undefined;
  if (!shared$LWS.isObject(proto$LWS)) {
    throw new shared$LWS.TypeErrorCtor('Invalid custom element constructor.');
  }
  let definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
  if (definition$LWS === undefined) {
    definition$LWS = createDefinitionRecord$LWS(LocalCtor$LWS);
    definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
  }
  return definition$LWS;
}
function getGlobalCustomElementRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS) {
  let registry$LWS = globalRegistryCache$LWS.get(document$LWS);
  if (registry$LWS) {
    return registry$LWS;
  }
  registry$LWS = new VirtualRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS);
  globalRegistryCache$LWS.set(document$LWS, registry$LWS);
  return registry$LWS;
}
function getNodeRegistry$LWS(document$LWS, node$LWS) {
  const key$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, node$LWS, [sharedDom$LWS.CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME]);
  if (key$LWS === null) {
    return undefined;
  }
  shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttribute, node$LWS, [sharedDom$LWS.CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME]);
  const ownerDoc$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, node$LWS, []);
  // istanbul ignore if: it's unclear how this could actually happen, if the node is coming from parsed/sanitized html.
  if (ownerDoc$LWS !== document$LWS) {
    // This is an extra restriction when the node is coming from a different
    // document. @TODO: We're sure how they can achieve this, but just being
    // defensive.
    return undefined;
  }
  const registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
  return registries$LWS ? registries$LWS.get(key$LWS) : undefined;
}
function getObservedAttributesList$LWS(baseDefinition$LWS, sourceDefinition$LWS) {
  // Natively, the attributes observed by the original definition are going to
  // be taken care of by the browser, only the difference between the two sets
  // has to be taken care by the patched version.
  return shared$LWS.toSafeSet(new shared$LWS.SetCtor([...sourceDefinition$LWS.observedAttributes].filter(
  // `baseDefinition.observedAttributes` is a safe Set.
  attrName$LWS => !baseDefinition$LWS.observedAttributes.has(attrName$LWS))));
}
// Patches removeAttribute, setAttribute, toggleAttribute to ensure correctness
// of attributeChangedCallback when more than one definition is registered for a
// given tag name. There can be only one tag name + definition per sandbox, but
// multiple sandboxes may define custom elements with the same tag name. Since
// the first definition locks up the observedAttributes with its list, all
// following definitions must have their instances patched to correctly fire
// attributeChangedCallback on attributes that are listed in those subsequent
// custom elements observedAttributes.
function patchAttributes$LWS(instance$LWS, originalDefinition$LWS, pivotDefinition$LWS) {
  const {
    observedAttributes: observedAttributes$LWS,
    attributeChangedCallback: attributeChangedCallback$LWS
  } = pivotDefinition$LWS;
  // istanbul ignore if: there is no way to test that nothing happens when these conditions are met
  if (observedAttributes$LWS.size === 0 || typeof attributeChangedCallback$LWS !== 'function') {
    return;
  }
  const observedAttributesList$LWS = getObservedAttributesList$LWS(originalDefinition$LWS, pivotDefinition$LWS);
  // If there are no unique attributes to observe, then there is no need to
  // patch removeAttribute, setAttribute and toggleAttribute
  // istanbul ignore if: there is no way to test that nothing happens when these conditions are met
  if (!observedAttributesList$LWS.size) {
    return;
  }
  instance$LWS.removeAttribute = shared$LWS.maskFunction(function removeAttribute$LWS(name$LWS) {
    const args$LWS = [name$LWS];
    // `observedAttributesList` is a safe Set.
    if (observedAttributesList$LWS.has(name$LWS)) {
      const old$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, args$LWS);
      shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttribute, this, args$LWS);
      args$LWS[1] = old$LWS;
      args$LWS[2] = null;
      shared$LWS.ReflectApply(attributeChangedCallback$LWS, this, args$LWS);
    } else {
      shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttribute, this, args$LWS);
    }
  }, sharedDom$LWS.ElementProtoRemoveAttribute);
  instance$LWS.setAttribute = shared$LWS.maskFunction(function setAttribute$LWS(name$LWS, value$LWS) {
    const args$LWS = [name$LWS];
    const stringifiedValue$LWS = shared$LWS.toString(value$LWS);
    const setAttributeArgs$LWS = [name$LWS, stringifiedValue$LWS];
    // `observedAttributesList` is a safe Set.
    if (observedAttributesList$LWS.has(name$LWS)) {
      const old$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, args$LWS);
      shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoSetAttribute, this, setAttributeArgs$LWS);
      args$LWS[1] = old$LWS;
      args$LWS[2] = stringifiedValue$LWS;
      shared$LWS.ReflectApply(attributeChangedCallback$LWS, this, args$LWS);
    } else {
      shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoSetAttribute, this, setAttributeArgs$LWS);
    }
  }, sharedDom$LWS.ElementProtoSetAttribute);
  instance$LWS.toggleAttribute = shared$LWS.maskFunction(function toggleAttribute$LWS(name$LWS) {
    const args$LWS = [name$LWS];
    let returnValue$LWS;
    // `observedAttributesList` is a safe Set.
    if (observedAttributesList$LWS.has(name$LWS)) {
      const hasAttribute$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, this, args$LWS);
      const old$LWS = hasAttribute$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, args$LWS) : null;
      returnValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoToggleAttribute, this, args$LWS);
      args$LWS[1] = old$LWS;
      if (hasAttribute$LWS) {
        args$LWS[2] = null;
      }
      shared$LWS.ReflectApply(attributeChangedCallback$LWS, this, args$LWS);
    } else {
      returnValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoToggleAttribute, this, args$LWS);
    }
    return returnValue$LWS;
  }, sharedDom$LWS.ElementProtoToggleAttribute);
  // `observedAttributesList` is a safe Set.
  observedAttributesList$LWS.forEach(originalAttributeName$LWS => {
    var _ref$LWS, _sharedDom$HTMLElemen$LWS;
    // Here we're ensuring support for attributes which have very explicit names that
    // differ from their property name:
    //
    // "accesskey" -> "accessKey"
    // "contenteditable" -> "contentEditable"
    // "tabindex" -> "tabIndex"
    //
    // As well as all of the aria-* properties
    //
    const attributePropertyName$LWS = (_ref$LWS = (_sharedDom$HTMLElemen$LWS = sharedDom$LWS.HTMLElementGlobalAttributesToPropertyName[originalAttributeName$LWS]) != null ? _sharedDom$HTMLElemen$LWS : sharedDom$LWS.ElementAriaAttributesToPropertyName[originalAttributeName$LWS]) != null ? _ref$LWS : originalAttributeName$LWS;
    if (attributePropertyName$LWS in instance$LWS) {
      const descriptor$LWS = {
        __proto__: null,
        enumerable: true,
        configurable: true,
        get() {
          // @ts-ignore this.__proto__
          // eslint-disable-next-line no-proto
          return shared$LWS.ReflectGet(this.__proto__, attributePropertyName$LWS, this);
        },
        set(value$LWS) {
          // This is necessary for both comparing the old attribute value to the new
          // attribute value and then for use in the arguments that are passed to
          // attributeChangedCallback
          const oldValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, [originalAttributeName$LWS]);
          // Because property assignment to special built-in setters
          // may have "magic" behavior to determine the actual value
          // that gets set, we need to invoke the original setter,
          // then get the new attribute value for comparison.
          // If _that_ value is different from the old value, then we
          // trigger the attributeChangedCallback
          // ReflectApply(originalSetter, this, [value]);
          // @ts-ignore this.__proto__
          // eslint-disable-next-line no-proto
          shared$LWS.ReflectSet(this.__proto__, attributePropertyName$LWS, value$LWS, this);
          const newValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, [originalAttributeName$LWS]);
          if (oldValue$LWS !== newValue$LWS) {
            shared$LWS.ReflectApply(attributeChangedCallback$LWS, this, [originalAttributeName$LWS, oldValue$LWS, newValue$LWS]);
          }
        }
      };
      shared$LWS.ReflectDefineProperty(instance$LWS, attributePropertyName$LWS, descriptor$LWS);
    }
  });
}
function patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS) {
  const {
    CustomElementRegistry: {
      prototype: CustomElementRegistryProto$LWS
    },
    customElements: customElements$LWS
  } = globalObject$LWS;
  const {
    define: originalDefine$LWS,
    get: originalGet$LWS,
    whenDefined: originalWhenDefined$LWS
  } = CustomElementRegistryProto$LWS;
  CustomElementRegistryProto$LWS.get = shared$LWS.maskFunction(function get$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because
      // in native this is going to leak constructors from
      // another windows. But right now, we don't know the
      // implications yet, the safe bet is to throw here.
      // @TODO: This could leak pivots from another document,
      // that's the concern.
      throw new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_INVOCATION$LWS);
    }
    return registry$LWS.applyGet(this, args$LWS);
  }, originalGet$LWS, shared$LWS.createUnmaskableTraps(originalGet$LWS));
  CustomElementRegistryProto$LWS.define = shared$LWS.maskFunction(function define$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because
      // in native this is normally a runtime error when
      // attempting to define a class that setDefinition from a
      // constructor from another window. But right now, we
      // don't know how to do this runtime check, the safe bet
      // is to throw here.
      throw new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_INVOCATION$LWS);
    }
    return registry$LWS.applyDefine(this, args$LWS);
  }, originalDefine$LWS, shared$LWS.createUnmaskableTraps(originalDefine$LWS));
  CustomElementRegistryProto$LWS.whenDefined = shared$LWS.maskFunction(function whenDefined$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because in native
      // this is going to leak constructors from another windows when
      // defined. But right now, we don't know the implications yet, the
      // safe bet is to throw here.
      // @TODO: Maybe returning a promise that never fulfills is better.
      return shared$LWS.PromiseReject(new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_INVOCATION$LWS));
    }
    return registry$LWS.applyWhenDefined(this, args$LWS);
  }, originalWhenDefined$LWS, shared$LWS.createUnmaskableTraps(originalWhenDefined$LWS));
}
function patchHTMLElement$LWS(globalObject$LWS, registry$LWS) {
  const {
    HTMLElement: originalHTMLElementCtor$LWS
  } = globalObject$LWS;
  globalObject$LWS.HTMLElement = shared$LWS.maskFunction(function HTMLElement$LWS() {
    if (new.target === undefined) {
      throw new shared$LWS.TypeErrorCtor(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
    }
    if (new.target === HTMLElement$LWS) {
      throw new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_CONSTRUCTOR$LWS);
    }
    return registry$LWS.newCtor(this, new.target, originalHTMLElementCtor$LWS);
  }, originalHTMLElementCtor$LWS, shared$LWS.createUnmaskableTraps(originalHTMLElementCtor$LWS));
}
function triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS) {
  // The below case patches observed attributes for the case where the HTML
  // element is upgraded from a pre-existing one in the DOM.
  const {
    observedAttributes: observedAttributes$LWS
  } = originalDefinition$LWS;
  const attributeChangedCallback$LWS = observedAttributes$LWS.size ? originalDefinition$LWS.attributeChangedCallback : undefined;
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (attributeChangedCallback$LWS) {
    // Approximate observedAttributes from the user class, but only for the
    // new observed attributes.
    observedAttributes$LWS.forEach(name$LWS => {
      if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, instance$LWS, [name$LWS])) {
        const newValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, instance$LWS, [name$LWS]);
        shared$LWS.ReflectApply(attributeChangedCallback$LWS, instance$LWS, [name$LWS, null, newValue$LWS]);
      }
    });
  }
}
function unpatchCustomElementRegistry$LWS(globalObject$LWS) {
  const {
    CustomElementRegistry: {
      prototype: CustomElementRegistryProto$LWS
    }
  } = globalObject$LWS;
  CustomElementRegistryProto$LWS.get = shared$LWS.getUnmaskedFunction(CustomElementRegistryProto$LWS.get);
  CustomElementRegistryProto$LWS.define = shared$LWS.getUnmaskedFunction(CustomElementRegistryProto$LWS.define);
  CustomElementRegistryProto$LWS.whenDefined = shared$LWS.getUnmaskedFunction(CustomElementRegistryProto$LWS.whenDefined);
}
function unpatchHTMLElement$LWS(globalObject$LWS) {
  globalObject$LWS.HTMLElement = shared$LWS.getUnmaskedFunction(globalObject$LWS.HTMLElement);
}
function getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS) {
  let registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
  if (registries$LWS === undefined) {
    registries$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
    sandboxRegistryCache$LWS.set(document$LWS, registries$LWS);
  }
  let registry$LWS = registries$LWS.get(key$LWS);
  if (registry$LWS) {
    return registry$LWS;
  }
  registry$LWS = new VirtualRegistry$LWS(document$LWS);
  registries$LWS.set(key$LWS, registry$LWS);
  return registry$LWS;
}
function patchGlobalObject$LWS(globalObject$LWS, document$LWS = globalObject$LWS.document) {
  const {
    HTMLElement: HTMLElementCtor$LWS
  } = globalObject$LWS;
  const isHTMLElementCtorPatched$LWS = shared$LWS.isMaskedFunction(HTMLElementCtor$LWS);
  const isCustomElementRegistryPatched$LWS = shared$LWS.isMaskedFunction(globalObject$LWS.CustomElementRegistry.prototype.get);
  const registry$LWS = !isHTMLElementCtorPatched$LWS || !isCustomElementRegistryPatched$LWS ? getGlobalCustomElementRegistry$LWS(document$LWS, shared$LWS.getUnmaskedFunction(HTMLElementCtor$LWS)) : undefined;
  if (!isHTMLElementCtorPatched$LWS) {
    patchHTMLElement$LWS(globalObject$LWS, registry$LWS);
  }
  if (!isCustomElementRegistryPatched$LWS) {
    patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS);
  }
}
function unpatchGlobalObject$LWS(globalObject$LWS, document$LWS = globalObject$LWS.document) {
  deleteGlobalCustomElementRegistry$LWS(document$LWS);
  unpatchCustomElementRegistry$LWS(globalObject$LWS);
  unpatchHTMLElement$LWS(globalObject$LWS);
}
// This function is to be used by other distortions to prepare this library
// before creating a custom element using a native mechanism, so the key is in
// place for the internal registry.
function setCustomElementsRegistry$LWS(document$LWS, key$LWS) {
  currentRegistry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
}
const attributeDistortionFactoriesCache$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
const sandboxAttributeDistortionRegistryCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
function finalizeAttributeDistortions$LWS(record$LWS) {
  const attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (attributeFactories$LWS === undefined) {
    return;
  }
  attributeDistortionFactoriesCache$LWS.delete(record$LWS);
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  let sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    sandboxAttributeDistortionRegistry$LWS = {
      __proto__: null
    };
    sandboxAttributeDistortionRegistryCache$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
  }
  const attributeDistortionRegistry$LWS = {
    __proto__: null
  };
  sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = attributeFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    attributeFactories$LWS[i$LWS](attributeDistortionRegistry$LWS);
  }
}
function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = sharedDom$LWS.NAMESPACE_DEFAULT) {
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  const sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }
  const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS];
  // istanbul ignore if: currently unreachable via tests
  if (attributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }
  const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, attrName$LWS, [])];
  if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
    return undefined;
  }
  const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
  if (elementCtorMap$LWS === undefined) {
    return undefined;
  }
  const mapIterator$LWS = elementCtorMap$LWS.entries();
  for (const {
    0: Ctor$LWS,
    1: distortion$LWS
  } of mapIterator$LWS) {
    // Element can inherit from Ctor but Ctor may not be the first entry in
    // the proto chain thus element.prototype checks are not sufficient.
    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }
  return undefined;
}
// Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').
function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? sharedDom$LWS.NAMESPACE_DEFAULT : ns$LWS;
}
function registerAttributeDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  let attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
  if (attributeFactories$LWS === undefined) {
    attributeFactories$LWS = [];
    attributeDistortionFactoriesCache$LWS.set(record$LWS, attributeFactories$LWS);
  }
  const loweredAttributeName$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, attributeName$LWS, []);
  attributeFactories$LWS[attributeFactories$LWS.length] = attributeDistortionRegistry$LWS => {
    let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];
    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      elementCtorMapByAttributeNamespaceRegistry$LWS = {
        __proto__: null
      };
      attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
    }
    let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
    if (elementCtorMap$LWS === undefined) {
      elementCtorMap$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
      elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
    }
    elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
  };
}
function initDistortionAttrValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS
  }
}) {
  const originalAttrValueSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Attr$LWS.prototype, 'value');
  return function distortionAttrValueSetter$LWS(record$LWS) {
    return [originalAttrValueSetter$LWS, function value$LWS(val$LWS) {
      const ownerElement$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, this, []);
      // istanbul ignore else: needs default platform behavior test
      if (ownerElement$LWS) {
        const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, this, []);
        const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore if: coverage missing, needs investigation
        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, ownerElement$LWS, [val$LWS]);
          return;
        }
      }
      shared$LWS.ReflectApply(originalAttrValueSetter$LWS, this, [val$LWS]);
    }];
  };
}
function initDistortionAuraUtilGlobalEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: globalObject$LWS
}) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval;
  // istanbul ignore else: external is the default sandbox type for coverage runs
  if (typeof originalGlobalEval$LWS !== 'function') {
    return shared$LWS.noop;
  }
  // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only
  return function distortionAuraUtilGlobalEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
    return [originalGlobalEval$LWS, function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
      let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;
      if (typeof descriptor$LWS === 'string') {
        const split$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, descriptor$LWS, ['://']);
        const {
          length: length$LWS
        } = split$LWS;
        const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
        wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, name$LWS, ['.', '/'])}` : `/components/${shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, name$LWS, [':', '/'])}.js`);
      }
      return sandboxEvaluator$LWS(sharedDom$LWS.transformSourceText(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageDelete$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;
  if (typeof originalDelete$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCacheStorageDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function patchedDelete$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;
        if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
          args$LWS[0] = shared$LWS.prependNamespaceMarker(cacheName$LWS, key$LWS);
        }
      }
      return shared$LWS.ReflectApply(originalDelete$LWS, this, args$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageHas$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy2$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;
  if (typeof originalHas$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCacheStorageHas$LWS({
    key: key$LWS
  }) {
    return [originalHas$LWS, function has$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;
        if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
          args$LWS[0] = shared$LWS.prependNamespaceMarker(cacheName$LWS, key$LWS);
        }
      }
      return shared$LWS.ReflectApply(originalHas$LWS, this, args$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageKeys$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy3$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;
  if (typeof originalKeys$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCacheStorageKeys$LWS({
    key: key$LWS
  }) {
    return [originalKeys$LWS, function keys$LWS() {
      const keysResultPromise$LWS = shared$LWS.ReflectApply(originalKeys$LWS, this, []);
      return shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, keysResultPromise$LWS, [result$LWS => {
        const sandboxedCacheNames$LWS = [];
        for (let i$LWS = 0, j$LWS = 0, {
            length: length$LWS
          } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cacheName$LWS = result$LWS[i$LWS];
          if (shared$LWS.startsWithNamespaceMarker(cacheName$LWS, key$LWS)) {
            sandboxedCacheNames$LWS[j$LWS++] = shared$LWS.removeNamespaceMarker(cacheName$LWS, key$LWS);
          }
        }
        return sandboxedCacheNames$LWS;
      }]);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageMatch$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy4$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;
  if (typeof originalMatch$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCacheStorageMatch$LWS({
    key: key$LWS
  }) {
    return [originalMatch$LWS, function match$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // Let the native method handle missing parameters.
      if (!length$LWS) {
        return shared$LWS.ReflectApply(originalMatch$LWS, this, args$LWS);
      }
      // Next we check `length` is at least 2, which means options are present.
      const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined;
      // In order to enforce the sandbox partition, we must REQUIRE the
      // `options.cacheName` value. The value of `options.cacheName` must
      // also be safely convertible to a string.
      if (shared$LWS.isObjectLike(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
        const {
          cacheName: cacheName$LWS
        } = matchOptions$LWS;
        if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
          const clonedOptions$LWS = shared$LWS.shallowCloneOptions(matchOptions$LWS);
          clonedOptions$LWS.cacheName = shared$LWS.prependNamespaceMarker(cacheName$LWS, key$LWS);
          args$LWS[1] = clonedOptions$LWS;
          return shared$LWS.ReflectApply(originalMatch$LWS, this, args$LWS);
        }
      }
      return shared$LWS.PromiseReject(new shared$LWS.LockerSecurityError("caches.match() expects 'options.cacheName' to be present."));
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageOpen$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy5$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;
  if (typeof originalOpen$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCacheStorageOpen$LWS({
    key: key$LWS
  }) {
    return [originalOpen$LWS, function open$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: cacheName$LWS
        } = args$LWS;
        if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
          args$LWS[0] = shared$LWS.prependNamespaceMarker(cacheName$LWS, key$LWS);
        }
      }
      return shared$LWS.ReflectApply(originalOpen$LWS, this, args$LWS);
    }];
  };
}
const COOKIE_DELIMITER$LWS = '; ';
/* istanbul ignore next: only available in secure context */
function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, namespace$LWS) {
  if (shared$LWS.isObjectLike(detailsOrName$LWS)) {
    const clonedDetails$LWS = shared$LWS.shallowCloneOptions(detailsOrName$LWS);
    clonedDetails$LWS.name = shared$LWS.prependNamespaceMarker(clonedDetails$LWS.name, namespace$LWS);
    return clonedDetails$LWS;
  }
  return shared$LWS.prependNamespaceMarker(detailsOrName$LWS, namespace$LWS);
}
function unprefixCookie$LWS(cookieEntry$LWS, namespace$LWS) {
  // First check that this cookie belongs to this sandbox,
  // if not then return `null`.
  if (!shared$LWS.startsWithNamespaceMarker(cookieEntry$LWS, namespace$LWS)) {
    return null;
  }
  // If this cookie belongs to this sandbox, remove the marker.
  const marker$LWS = shared$LWS.getNamespaceMarker(namespace$LWS);
  const {
    length: markerLength$LWS
  } = marker$LWS;
  const pos$LWS = cookieEntry$LWS.length > markerLength$LWS && cookieEntry$LWS[markerLength$LWS] === '=' ? markerLength$LWS + 1 : markerLength$LWS;
  return shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, cookieEntry$LWS, [pos$LWS]);
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreDelete$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp$LWS;
  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;
  if (typeof originalDelete$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCookieStoreDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function deleteValue$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }
      return shared$LWS.ReflectApply(originalDelete$LWS, this, args$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreGet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp2$LWS;
  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;
  if (typeof originalGet$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCookieStoreGet$LWS({
    key: key$LWS
  }) {
    return [originalGet$LWS, function get$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }
      const getResultPromise$LWS = shared$LWS.ReflectApply(originalGet$LWS, this, args$LWS);
      return shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, getResultPromise$LWS, [cookieListItem$LWS => {
        if (cookieListItem$LWS) {
          const {
            name: name$LWS
          } = cookieListItem$LWS;
          if (shared$LWS.startsWithNamespaceMarker(name$LWS, key$LWS)) {
            cookieListItem$LWS.name = shared$LWS.removeNamespaceMarker(name$LWS, key$LWS);
            return cookieListItem$LWS;
          }
        }
        return null;
      }]);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreGetAll$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp3$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;
  if (typeof originalGetAll$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCookieStoreGetAll$LWS({
    key: key$LWS
  }) {
    return [originalGetAll$LWS, function getAll$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
      }
      const getAllResultPromise$LWS = shared$LWS.ReflectApply(originalGetAll$LWS, this, args$LWS);
      return shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, getAllResultPromise$LWS, [result$LWS => {
        const sandboxedCookies$LWS = [];
        let sandboxedCookiesOffset$LWS = 0;
        for (let i$LWS = 0, {
            length: length$LWS
          } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cookieListItem$LWS = result$LWS[i$LWS];
          if (cookieListItem$LWS) {
            const {
              name: name$LWS
            } = cookieListItem$LWS;
            if (shared$LWS.startsWithNamespaceMarker(name$LWS, key$LWS)) {
              cookieListItem$LWS.name = shared$LWS.removeNamespaceMarker(name$LWS, key$LWS);
              sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
            }
          }
        }
        return sandboxedCookies$LWS;
      }]);
    }];
  };
}
const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
  __proto__: null
};
function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }
  return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
}
function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
  // istanbul ignore if: this is a safety precaution that is unreachable via tests
  if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
    return;
  }
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS = {
      __proto__: null
    }
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  const {
    [eventName$LWS]: restrictedEventTargetCtors$LWS = shared$LWS.toSafeWeakSet(new shared$LWS.WeakSetCtor())
  } = restrictedEventTargetRegistry$LWS;
  restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
  restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
  restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
}
// This is for use with DOM-0 style "event handler" distortions, eg.
// - window.onsecuritypolicyviolation
// - window.onstorage
function createEventHandlerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
  let exceptionMessage$LWS = `Cannot set '${eventName$LWS}' event handler`;
  const safeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(instanceOrProto$LWS.constructor, 'name');
  // istanbul ignore else: needs default platform behavior test
  if (safeDesc$LWS) {
    shared$LWS.ReflectSetPrototypeOf(safeDesc$LWS, null);
    const {
      value: name$LWS
    } = safeDesc$LWS;
    // istanbul ignore else: needs default platform behavior test
    if (typeof name$LWS === 'string') {
      exceptionMessage$LWS += ` on ${name$LWS} object`;
    }
  }
  return `${exceptionMessage$LWS}.`;
}
// This is for use with DOM-2 style "event listener" distortions, eg.
// - window.addEventListener('securitypolicyviolation', ...)
// - window.addEventListener('storage', ...)
function createEventListenerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
  let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;
  const safeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(instanceOrProto$LWS.constructor, 'name');
  // istanbul ignore else: needs default platform behavior test
  if (safeDesc$LWS) {
    shared$LWS.ReflectSetPrototypeOf(safeDesc$LWS, null);
    const {
      value: name$LWS
    } = safeDesc$LWS;
    // istanbul ignore else: needs default platform behavior test
    if (typeof name$LWS === 'string') {
      exceptionMessage$LWS += ` to ${name$LWS} object`;
    }
  }
  return `${exceptionMessage$LWS}.`;
}
function createEventDistortionFactory$LWS(eventHandlerTarget$LWS, eventListenerTarget$LWS, eventName$LWS) {
  const onEventHandlerName$LWS = `on${eventName$LWS}`;
  const originalEventHandlerSetter$LWS = shared$LWS.ObjectLookupOwnSetter(eventHandlerTarget$LWS, onEventHandlerName$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalEventHandlerSetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const eventExceptionMessage$LWS = createEventHandlerExceptionMessage$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
  const distortionMapEntry$LWS = [originalEventHandlerSetter$LWS, function () {
    throw new shared$LWS.LockerSecurityError(eventExceptionMessage$LWS);
  }];
  return function distortionEventHandler$LWS(record$LWS) {
    registerEventTargetRestriction$LWS(record$LWS, eventListenerTarget$LWS, eventName$LWS);
    return distortionMapEntry$LWS;
  };
}
function initDistortionCookieStoreOnChange$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  return createEventDistortionFactory$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, CookieStore$LWS, 'change');
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreSet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp4$LWS;
  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;
  if (typeof originalSet$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCookieStoreSet$LWS({
    key: key$LWS
  }) {
    return [originalSet$LWS, function set$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS > 1) {
        args$LWS[0] = shared$LWS.prependNamespaceMarker(args$LWS[0], key$LWS);
      } else if (length$LWS) {
        const {
          0: details$LWS
        } = args$LWS;
        if (shared$LWS.isObjectLike(details$LWS)) {
          const clonedDetails$LWS = shared$LWS.shallowCloneOptions(details$LWS);
          clonedDetails$LWS.name = shared$LWS.prependNamespaceMarker(clonedDetails$LWS.name, key$LWS);
          args$LWS[0] = clonedDetails$LWS;
        }
      }
      return shared$LWS.ReflectApply(originalSet$LWS, this, args$LWS);
    }];
  };
}
function initDistortionCSSStyleRuleStyleGetter$LWS({
  globalObject: {
    CSSStyleRule: CSSStyleRule$LWS
  }
}) {
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(CSSStyleRule$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return shared$LWS.trackAsLiveTarget(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }];
  return function distortionCSSStyleRuleStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionCustomElementRegistryDefine$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsDefine$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.define;
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalCustomElementsDefine$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCustomElementRegistryDefine$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsDefine$LWS, function define$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in native
        // this is normally a runtime error when attempting to define a
        // class that inherit from a constructor from another window.
        // But right now, we don't know how to do this runtime check,
        // the safe bet is to throw here.
        throw new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyDefine(this, args$LWS);
    }];
  };
}
function initDistortionCustomElementRegistryGet$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr2$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr2$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr2$LWS.get;
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalCustomElementsGet$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCustomElementRegistryGet$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsGet$LWS, function get$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in
        // native this is going to leak constructors from another
        // windows. But right now, we don't know the implications yet,
        // the safe bet is to throw here.
        // @TODO: this could leak pivots from another document,
        // that's the concern.
        throw new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyGet(this, args$LWS);
    }];
  };
}
function initDistortionCustomElementRegistryWhenDefined$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr3$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsWhenDefined$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr3$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr3$LWS.whenDefined;
  // istanbul ignore if: this is just a safeguard and not reachable in the test environment
  if (typeof originalCustomElementsWhenDefined$LWS !== 'function') {
    return shared$LWS.noop;
  }
  return function distortionCustomElementRegistryWhenDefined$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsWhenDefined$LWS, function whenDefined$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in
        // native this is going to leak constructors from another
        // windows when defined. But right now, we don't know the
        // implications yet, the safe bet is to throw here.
        // @TODO: Maybe returning a promise that never fulfills is
        // better.
        return shared$LWS.PromiseReject(new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_INVOCATION$LWS));
      }
      return registry$LWS.applyWhenDefined(this, args$LWS);
    }];
  };
}
function initDistortionDocumentCookieGetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieGetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieGetter$LWS, function get$LWS() {
      const documentCookieValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCookieGetter, this, []);
      const cookies$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;
      for (let i$LWS = 0, {
          length: length$LWS
        } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);
        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }
      return shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
    }];
  };
}
function initDistortionDocumentCookieSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieSetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieSetter$LWS, function set$LWS(value$LWS) {
      const cookieEntries$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, value$LWS, [COOKIE_DELIMITER$LWS]);
      let {
        0: newCookieEntry$LWS
      } = cookieEntries$LWS;
      if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
        newCookieEntry$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, newCookieEntry$LWS, [1]);
      }
      cookieEntries$LWS[0] = shared$LWS.prependNamespaceMarker(newCookieEntry$LWS, key$LWS);
      const cookie$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
      shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCookieSetter, this, [cookie$LWS]);
    }];
  };
}
function initDistortionDocumentCreateElement$LWS({
  document: document$LWS,
  globalObject: {
    Document: {
      prototype: {
        createElement: originalDocumentCreateElement$LWS
      }
    }
  }
}) {
  return function distortionDocumentCreateElement$LWS({
    key: key$LWS
  }) {
    return [originalDocumentCreateElement$LWS, function (...args$LWS) {
      const {
        0: tagName$LWS
      } = args$LWS;
      // Slow path for potential custom elements that might be registered
      // in the sandbox's virtual custom element registry.
      if (shared$LWS.ReflectApply(shared$LWS.StringProtoIncludes, tagName$LWS, ['-'])) {
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created will be
        // a custom element and it must be marked for association to
        // this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      }
      return shared$LWS.ReflectApply(originalDocumentCreateElement$LWS, this, args$LWS);
    }];
  };
}
function initDistortionDocumentCreateElementNS$LWS({
  document: document$LWS,
  globalObject: {
    Document: {
      prototype: {
        createElementNS: originalDocumentCreateElementNS$LWS
      }
    }
  }
}) {
  return function distortionDocumentCreateElementNS$LWS({
    key: key$LWS
  }) {
    return [originalDocumentCreateElementNS$LWS, function (...args$LWS) {
      const {
        1: tagName$LWS
      } = args$LWS;
      // Slow path for potential custom elements that might
      // be registered in the sandbox's virtual custom element registry.
      if (shared$LWS.ReflectApply(shared$LWS.StringProtoIncludes, tagName$LWS, ['-'])) {
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created will be
        // a custom element and it must be marked for association to
        // this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      }
      return shared$LWS.ReflectApply(originalDocumentCreateElementNS$LWS, this, args$LWS);
    }];
  };
}
function domain$LWS() {
  throw new shared$LWS.LockerSecurityError('Cannot set document.domain.');
}
function initDistortionDocumentDomainSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalDomainSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Document$LWS.prototype, 'domain');
  const distortionEntry$LWS = [originalDomainSetter$LWS, domain$LWS];
  return function distortionDocumentDomainSetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$m$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionDocumentExecCommand$LWS({
  document: document$LWS,
  globalObject: {
    Document: {
      prototype: {
        execCommand: originalExecCommand$LWS
      }
    },
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalActiveElement$LWS = shared$LWS.ObjectLookupOwnGetter(Document.prototype, 'activeElement');
  const originalIsContentEditable$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'isContentEditable');
  return function distortionDocumentExecCommand$LWS({
    key: key$LWS,
    type: type$LWS
  }) {
    return [originalExecCommand$LWS, function execCommand$LWS(...args$LWS) {
      if (args$LWS.length > 2) {
        const {
          2: unsanitizedValue$LWS
        } = args$LWS;
        // istanbul ignore else: needs default platform behavior test
        if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
          const command$LWS = shared$LWS.toString(args$LWS[0]);
          // istanbul ignore else: LWS does not test for all possible commands
          if (shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, command$LWS, []) === 'inserthtml') {
            // istanbul ignore else: external is the default sandbox type for coverage runs
            if (type$LWS === 0 /* SandboxType.External */) {
              const activeElement$LWS = shared$LWS.ReflectApply(originalActiveElement$LWS, this, []);
              if (isSharedElement$m$LWS(activeElement$LWS) && shared$LWS.ReflectApply(originalIsContentEditable$LWS, activeElement$LWS, [])) {
                throw new shared$LWS.LockerSecurityError(`Cannot execute command '${command$LWS}' on ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, activeElement$LWS, [])}.`);
              }
            }
            // This must be called to signal to the virtual
            // CustomElementRegistry that the next thing created
            // MAY CONTAIN a custom element, which must be marked
            // for association to this sandbox.
            setCustomElementsRegistry$LWS(document$LWS, key$LWS);
            args$LWS[0] = command$LWS;
            args$LWS[2] = internalPolicy$LWS.lwsInternalPolicy.createHTML(unsanitizedValue$LWS, key$LWS, internalPolicy$LWS.ContentType.HTML);
          }
        }
      }
      return shared$LWS.ReflectApply(originalExecCommand$LWS, this, args$LWS);
    }];
  };
}
function initDistortionDocumentOnsecuritypolicyviolation$LWS({
  globalObject: {
    Document: {
      prototype: DocumentProto$LWS
    },
    HTMLDocument: HTMLDocument$LWS
  }
}) {
  return createEventDistortionFactory$LWS(DocumentProto$LWS, HTMLDocument$LWS, 'securitypolicyviolation');
}
function initDistortionDocumentOpen$LWS({
  globalObject: {
    Document: {
      prototype: {
        open: originalDocumentOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalDocumentOpen$LWS, function open$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;
    // @ts-ignore: document.open() can be called with no arguments.
    if (this === sharedDom$LWS.rootDocument && length$LWS === 0) {
      throw new shared$LWS.LockerSecurityError(`Cannot open top level document.`);
    }
    // istanbul ignore else: needs default platform behavior test
    if (length$LWS >= 3) {
      // Distort three-argument document.open calls which is an alias
      // for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const normalizedArgs$LWS = sharedDom$LWS.normalizeWindowOpenArguments(args$LWS);
      const childWindow$LWS = shared$LWS.ReflectApply(originalDocumentOpen$LWS, this, normalizedArgs$LWS);
      if (childWindow$LWS) {
        sharedDom$LWS.initWindowOpenChildWindow(childWindow$LWS, normalizedArgs$LWS[0]);
      }
      return childWindow$LWS;
    }
    // istanbul ignore next: needs default platform behavior test
    return shared$LWS.ReflectApply(originalDocumentOpen$LWS, this, args$LWS);
  }];
  return function distortionDocumentOpen$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionDocumentReplaceChildren$LWS({
  globalObject: {
    Document: {
      prototype: {
        replaceChildren: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChildren$LWS(...args$LWS) {
    if (this === sharedDom$LWS.rootDocument) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace children of document.`);
    }
    // istanbul ignore next: needs default platform behavior test
    return shared$LWS.ReflectApply(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionDocumentReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionDOMParserParseFromString$LWS({
  document: document$LWS,
  globalObject: {
    DOMParser: {
      prototype: {
        parseFromString: originalParseFromString$LWS
      }
    }
  }
}) {
  return function distortionDOMParserParseFromString$LWS({
    key: key$LWS
  }) {
    return [originalParseFromString$LWS, function parseFromString$LWS(...args$LWS) {
      // DOMParser.prototype.parseFromString can only be called with
      // exactly two arguments. If it receives one argument, it will fail.
      // Some implementations will also fail if it receives more than two
      // arguments. Since any call that does not have at least two arguments
      // will fail no matter what, we only need to expend effort to sanitize
      // when we know that the operation is definitely NOT going to fail.
      if (args$LWS.length >= 2) {
        // Override the value of the first argument with a sanitized version
        // of that argument.
        const string$LWS = shared$LWS.toString(args$LWS[0]);
        const mimeType$LWS = shared$LWS.toString(args$LWS[1]);
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        let contentType$LWS;
        switch (mimeType$LWS) {
          case 'application/xhtml+xml':
          case 'application/xml':
          case 'text/xml':
            contentType$LWS = internalPolicy$LWS.ContentType.XML;
            break;
          case 'image/svg+xml':
            contentType$LWS = internalPolicy$LWS.ContentType.SVG;
            break;
          default:
            contentType$LWS = internalPolicy$LWS.ContentType.HTML;
        }
        args$LWS[0] = internalPolicy$LWS.lwsInternalPolicy.createHTML(string$LWS, key$LWS, contentType$LWS);
      }
      return shared$LWS.ReflectApply(originalParseFromString$LWS, this, args$LWS);
    }];
  };
}
const {
  isSharedElement: isSharedElement$l$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$6$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementAfter$LWS({
  globalObject: {
    Element: {
      prototype: {
        after: originalAfter$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAfter$LWS, function after$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$l$LWS(this)) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        if (!isAllowedSharedElementChild$6$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */shared$LWS.toString(argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot insert ${nodeNameOrString$LWS} after ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
        }
      }
    }
    return shared$LWS.ReflectApply(originalAfter$LWS, this, args$LWS);
  }];
  return function distortionElementAfter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$k$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$5$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementAppend$LWS({
  globalObject: {
    Element: {
      prototype: {
        append: originalAppend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAppend$LWS, function append$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$k$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number
      // of arguments which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        // ...If any of the provided arguments is NOT a valid shared
        // element child which is limited to script and link, an
        // exception is thrown.
        if (!isAllowedSharedElementChild$5$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */shared$LWS.toString(argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot append ${nodeNameOrString$LWS} to ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
        }
      }
    }
    return shared$LWS.ReflectApply(originalAppend$LWS, this, args$LWS);
  }];
  return function distortionElementAppend$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementAttachShadow$LWS({
  globalObject: {
    Element: {
      prototype: {
        attachShadow: originalAttachShadow$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAttachShadow$LWS, function attachShadow$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;
        if (mode$LWS !== 'closed') {
          throw new shared$LWS.LockerSecurityError("Shadow root mode cannot be 'open.'");
        }
        // Assign own properties and set prototype of shadowRootInit
        // because attachShadow() accepts inherited shadowRootInit
        // properties.
        const shadowRootInit$LWS = shared$LWS.ObjectAssign({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        });
        // Set the prototype of shadowRootInit after assignment
        // of mode to avoid complications with inherited
        // non-configurable/non-writable mode properties.
        const originalShadowRootInitProto$LWS = shared$LWS.ReflectGetPrototypeOf(originalShadowRootInit$LWS);
        shared$LWS.ReflectSetPrototypeOf(shadowRootInit$LWS, originalShadowRootInitProto$LWS);
        // Replace shadowRootInit parameter.
        args$LWS[0] = shadowRootInit$LWS;
      }
    }
    return shared$LWS.ReflectApply(originalAttachShadow$LWS, this, args$LWS);
  }];
  return function distortionElementAttachShadow$LWS() {
    return distortionEntry$LWS;
  };
}
const namedNodeMapToElementCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
function pairElement$LWS(attrInstance$LWS, element$LWS) {
  namedNodeMapToElementCache$LWS.set(attrInstance$LWS, element$LWS);
}
function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
  const element$LWS = namedNodeMapToElementCache$LWS.get(nodeNameMap$LWS);
  // istanbul ignore else: nothing to do if there's no element
  if (element$LWS) {
    const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, attr$LWS, []);
    const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS);
    // istanbul ignore else: nothing to do if there's no distortion
    if (distortion$LWS) {
      const attrValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, attr$LWS, []);
      return shared$LWS.ReflectApply(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  }
  // istanbul ignore next: needs default platform behavior test
  return shared$LWS.ReflectApply(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}
function initDistortionElementAttributesGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalAttributesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Element$LWS.prototype, 'attributes');
  const distortionEntry$LWS = [originalAttributesGetter$LWS, function attributes$LWS() {
    const attrs$LWS = shared$LWS.ReflectApply(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }];
  return function distortionElementAttributesGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$j$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$4$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementBefore$LWS({
  globalObject: {
    Element: {
      prototype: {
        before: originalBefore$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalBefore$LWS, function before$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$j$LWS(this)) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        // istanbul ignore else: needs default platform behavior test
        if (!isAllowedSharedElementChild$4$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */shared$LWS.toString(argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot insert ${nodeNameOrString$LWS} before ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
        }
      }
    }
    return shared$LWS.ReflectApply(originalBefore$LWS, this, args$LWS);
  }];
  return function distortionElementBefore$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementGetInnerHTML$LWS({
  globalObject: {
    Element: {
      prototype: {
        getInnerHTML: originalGetInnerHTML$LWS
      }
    }
  }
}) {
  if (typeof originalGetInnerHTML$LWS !== 'function') {
    // istanbul ignore next: only runs in browsers without property
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalGetInnerHTML$LWS, function getInnerHTML$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: options$LWS
      } = args$LWS;
      if (shared$LWS.isObjectLike(options$LWS)) {
        const clonedOptions$LWS = shared$LWS.shallowCloneOptions(options$LWS);
        clonedOptions$LWS.includeShadowRoots = false;
        args$LWS[0] = clonedOptions$LWS;
      }
    } else {
      args$LWS[0] = {
        __proto__: null,
        includeShadowRoots: false
      };
    }
    return shared$LWS.ReflectApply(originalGetInnerHTML$LWS, this, args$LWS);
  }];
  return function distortionElementGetInnerHTML$LWS() {
    return distortionEntry$LWS;
  };
}
function scriptPropertySetters$LWS(incomingThis$LWS, property$LWS, valueAsTrustedString$LWS, originalScriptPropertyGetter$LWS, originalScriptPropertySetter$LWS, distortions$LWS, sandboxEvaluator$LWS, signedScriptHookSourceText$LWS) {
  const valueAsString$LWS = shared$LWS.toString(valueAsTrustedString$LWS);
  if (!sharedDom$LWS.isScriptPropertyEvaluatorHookDefined(incomingThis$LWS)) {
    const distortedScriptPropertyGetter$LWS = distortions$LWS.get(originalScriptPropertyGetter$LWS);
    sharedDom$LWS.defineScriptAccessorProperty(incomingThis$LWS, property$LWS, distortedScriptPropertyGetter$LWS, originalScriptPropertySetter$LWS);
  }
  sharedDom$LWS.setOriginalScriptScriptProperty(incomingThis$LWS, valueAsString$LWS);
  if (!sharedDom$LWS.isScriptEvaluated(incomingThis$LWS)) {
    // Skip script property evaluation if script URL is already
    // specified.
    if (!sharedDom$LWS.isScriptURLEvaluatorHookDefined(incomingThis$LWS)) {
      sharedDom$LWS.defineScriptEvaluatorProperty(incomingThis$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
        sharedDom$LWS.deleteOriginalScriptProperty(incomingThis$LWS);
        shared$LWS.ReflectDeleteProperty(incomingThis$LWS, property$LWS);
        // Set the script property immediately
        // after the evaluator hook fires to overwrite
        // the evaluator hook source text.
        shared$LWS.ReflectApply(originalScriptPropertySetter$LWS, incomingThis$LWS, [valueAsTrustedString$LWS]);
        sandboxEvaluator$LWS(sharedDom$LWS.transformSourceText(valueAsString$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
      });
      // Set the script property to the evaluator
      // hook which will run once the node is inserted
      // into a document. Subsequent changes to script
      // property are not evaluated.
      shared$LWS.ReflectApply(originalScriptPropertySetter$LWS, incomingThis$LWS, [signedScriptHookSourceText$LWS]);
    }
    return true;
  }
  return false;
}
const {
  isSharedElement: isSharedElement$i$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementInnerHTMLSetter$LWS({
  document: document$LWS,
  globalObject: {
    Element: Element$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  const {
    get: originalInnerHTMLGetter$LWS,
    set: originalInnerHTMLSetter$LWS
  } = shared$LWS.ReflectGetOwnPropertyDescriptor(Element$LWS.prototype, 'innerHTML');
  return function distortionElementInnerHTMLSetter$LWS({
    key: key$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
      const isOwnerXMLDocument$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, this, []) instanceof XMLDocument$LWS;
      if (!isOwnerXMLDocument$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$i$LWS(this)) {
          throw new shared$LWS.LockerSecurityError(`Cannot set innerHTML of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
        }
        if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement) {
          const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'innerHTML', trustedTypes$LWS.trusted.createScript(value$LWS), originalInnerHTMLGetter$LWS, originalInnerHTMLSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trustedTypes$LWS.trusted.createScript(sharedDom$LWS.SCRIPT_HOOK_SOURCE_TEXT));
          if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
            return;
          }
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        const contentType$LWS = this instanceof SVGElement$LWS ? internalPolicy$LWS.ContentType.SVG : internalPolicy$LWS.ContentType.HTML;
        value$LWS = internalPolicy$LWS.lwsInternalPolicy.createHTML(value$LWS, key$LWS, contentType$LWS);
      }
      shared$LWS.ReflectApply(originalInnerHTMLSetter$LWS, this, [value$LWS]);
    }];
  };
}
const {
  isSharedElement: isSharedElement$h$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$3$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementInsertAdjacentElement$LWS({
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentElement: originalInsertAdjacentElement$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertAdjacentElement$LWS, function insertAdjacentElement$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$h$LWS(this) && !isAllowedSharedElementChild$3$LWS(element$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, element$LWS, [])} adjacent to ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
      }
    }
    return shared$LWS.ReflectApply(originalInsertAdjacentElement$LWS, this, args$LWS);
  }];
  return function distortionElementInsertAdjacentElement$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$g$LWS
} = sharedDom$LWS.rootValidator;
const allowedElementHTMLRegExp$LWS = /^\s*<(link|script|style)/i;
function initDistortionElementInsertAdjacentHTML$LWS({
  document: document$LWS,
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentHTML: originalInsertAdjacentHTML$LWS
      }
    }
  }
}) {
  return function distortionElementInsertAdjacentHTML$LWS({
    key: key$LWS
  }) {
    return [originalInsertAdjacentHTML$LWS, function insertAdjacentHTML$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length > 1) {
        const match$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoMatch, args$LWS[1], [allowedElementHTMLRegExp$LWS]);
        if (isSharedElement$g$LWS(this) && match$LWS === null) {
          throw new shared$LWS.LockerSecurityError(`Cannot insert adjacent HTML to ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}`);
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        const contentType$LWS = this instanceof SVGElement ? internalPolicy$LWS.ContentType.SVG : internalPolicy$LWS.ContentType.HTML;
        args$LWS[1] = internalPolicy$LWS.lwsInternalPolicy.createHTML(args$LWS[1], key$LWS, contentType$LWS);
      }
      shared$LWS.ReflectApply(originalInsertAdjacentHTML$LWS, this, args$LWS);
    }];
  };
}
const {
  isSharedElement: isSharedElement$f$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementOuterHTMLSetter$LWS({
  document: document$LWS,
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalOuterHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Element$LWS.prototype, 'outerHTML');
  return function distortionElementOuterHTMLSetter$LWS({
    key: key$LWS
  }) {
    return [originalOuterHTMLSetter$LWS, function outerHTML$LWS(value$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$f$LWS(this)) {
        throw new shared$LWS.LockerSecurityError(`Cannot set outerHTML of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
      }
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      shared$LWS.ReflectApply(originalOuterHTMLSetter$LWS, this, [internalPolicy$LWS.lwsInternalPolicy.createHTML(value$LWS, key$LWS, internalPolicy$LWS.ContentType.HTML)]);
    }];
  };
}
const {
  isSharedElement: isSharedElement$e$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$2$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementPrepend$LWS({
  globalObject: {
    Element: {
      prototype: {
        prepend: originalPrepend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalPrepend$LWS, function prepend$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$e$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary
      // number of arguments which can be comprised of Nodes and
      // DOMStrings.
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        // ...If any of the provided arguments is NOT a valid shared
        // element child, which is limited to script and link, an
        // exception is thrown.
        if (!isAllowedSharedElementChild$2$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */shared$LWS.toString(argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot prepend ${nodeNameOrString$LWS} to ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
        }
      }
    }
    return shared$LWS.ReflectApply(originalPrepend$LWS, this, args$LWS);
  }];
  return function distortionElementPrepend$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$d$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementRemove$LWS({
  globalObject: {
    Element: {
      prototype: {
        remove: originalRemove$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemove$LWS, function remove$LWS() {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$d$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot remove ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
    }
    shared$LWS.ReflectApply(originalRemove$LWS, this, []);
  }];
  return function distortionElementRemove$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$c$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementReplaceChildren$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceChildren: originalReplaceChildren$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChildren$LWS, function replaceChildren$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$c$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace children of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
    }
    return shared$LWS.ReflectApply(originalReplaceChildren$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$b$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementReplaceWith$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceWith: originalReplaceWith$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceWith$LWS, function replaceWith$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$b$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
    }
    return shared$LWS.ReflectApply(originalReplaceWith$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceWith$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementSetAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttribute$LWS(record$LWS) {
    return [originalSetAttribute$LWS, function setAttribute$LWS(...args$LWS) {
      if (args$LWS.length > 1) {
        const attrName$LWS = sharedDom$LWS.normalizeNamespacedAttributeName(shared$LWS.toString(args$LWS[0]));
        const attrValue$LWS = shared$LWS.toString(args$LWS[1]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
          return;
        }
        // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        args$LWS[0] = attrName$LWS;
        args$LWS[1] = attrValue$LWS;
      }
      shared$LWS.ReflectApply(originalSetAttribute$LWS, this, args$LWS);
    }];
  };
}
function initDistortionElementSetAttributeNode$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNode: originalSetAttributeNode$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNode$LWS(record$LWS) {
    return [originalSetAttributeNode$LWS, function setAttributeNode$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
      }
      // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test
      if (shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, attr$LWS, [])) {
        return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
      }
      const attrName$LWS = sharedDom$LWS.normalizeNamespacedAttributeName(shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, attr$LWS, []));
      const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
      if (distortion$LWS) {
        const oldAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNode, this, [attrName$LWS]);
        if (oldAttr$LWS) {
          // Disconnect old attribute.
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [oldAttr$LWS]);
        }
        const attrValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, attr$LWS, []);
        shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNode, this, [attrName$LWS]);
        if (newAttr$LWS) {
          // Remove distorted attribute.
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [newAttr$LWS]);
        }
        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
        }
        if (newAttr$LWS) {
          const newValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, newAttr$LWS, []);
          // Set the distorted attr value.
          shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueSetter, attr$LWS, [newValue$LWS]);
          // Replace old attr.
          return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, [attr$LWS]);
        }
        return undefined;
      }
      return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
    }];
  };
}
function initDistortionElementSetAttributeNodeNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNodeNS: originalSetAttributeNodeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
    return [originalSetAttributeNodeNS$LWS, function setAttributeNodeNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, args$LWS);
      }
      // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test
      if (shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, attr$LWS, [])) {
        return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, args$LWS);
      }
      const attrName$LWS = sharedDom$LWS.normalizeNamespacedAttributeName(shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, attr$LWS, []));
      const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
      if (distortion$LWS) {
        const oldAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNodeNS, this, [attrNamespace$LWS, attrName$LWS]);
        if (oldAttr$LWS) {
          // Disconnect the old attribute.
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [oldAttr$LWS]);
        }
        const attrValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, attr$LWS, []);
        shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNodeNS, this, [attrNamespace$LWS, attrName$LWS]);
        if (newAttr$LWS) {
          // Remove the distorted attribute.
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [newAttr$LWS]);
        }
        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
        }
        if (newAttr$LWS) {
          const newValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, newAttr$LWS, []);
          // Set the distorted attr value.
          shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueSetter, attr$LWS, [newValue$LWS]);
          // Replace old attr.
          return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
        }
        return null;
      }
      return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
    }];
  };
}
function initDistortionElementSetAttributeNS$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttributeNS: originalSetAttributeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNS$LWS(record$LWS) {
    return [originalSetAttributeNS$LWS, function setAttributeNS$LWS(...args$LWS) {
      // istanbul ignore next: needs default platform behavior test
      if (args$LWS.length < 3) {
        shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, args$LWS);
        return;
      }
      let {
        0: attrNamespace$LWS
      } = args$LWS;
      if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
        attrNamespace$LWS = shared$LWS.toString(attrNamespace$LWS);
      }
      const attrName$LWS = sharedDom$LWS.normalizeNamespacedAttributeName(shared$LWS.toString(args$LWS[1]));
      const attrValue$LWS = shared$LWS.toString(args$LWS[2]);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
      // istanbul ignore else: needs default platform behavior test
      if (distortion$LWS) {
        shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
        return;
      }
      // istanbul ignore next: needs default platform behavior test
      // eslint-disable-next-line no-lone-blocks
      {
        // This is in a block to avoid requiring an
        // "istanbul ignore next" for all for lines.
        // We could avoid this entirely by testing the default
        // platform behavior.
        args$LWS[0] = attrNamespace$LWS;
        // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        args$LWS[1] = attrName$LWS;
        args$LWS[2] = attrValue$LWS;
        shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, args$LWS);
      }
    }];
  };
}
const {
  isSharedElement: isSharedElement$a$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionElementSetHTML$LWS({
  document: document$LWS,
  globalObject: {
    Element: {
      prototype: {
        setHTML: originalSetHTML$LWS
      }
    },
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  }
}) {
  if (typeof originalSetHTML$LWS !== 'function') {
    // istanbul ignore next: only runs in browsers without property
    return shared$LWS.noop;
  }
  return function distortionElementSetHTML$LWS({
    key: key$LWS
  }) {
    return [originalSetHTML$LWS, function setHTML$LWS(...args$LWS) {
      const isOwnerXMLDocument$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, this, []) instanceof XMLDocument$LWS;
      if (!isOwnerXMLDocument$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$a$LWS(this)) {
          throw new shared$LWS.LockerSecurityError(`Cannot setHTML of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        // If options not specified, the default Sanitizer object is used.
        // This will be in addition to the sanitization we have.
        const value$LWS = args$LWS[0];
        const contentType$LWS = this instanceof SVGElement$LWS ? internalPolicy$LWS.ContentType.SVG : internalPolicy$LWS.ContentType.HTML;
        args$LWS[0] = internalPolicy$LWS.lwsInternalPolicy.createHTML(value$LWS, key$LWS, contentType$LWS);
      }
      shared$LWS.ReflectApply(originalSetHTML$LWS, this, args$LWS);
    }];
  };
}
function alwaysNull$LWS() {
  return null;
}
function initDistortionElementShadowRootGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalShadowRootGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Element$LWS.prototype, 'shadowRoot');
  const distortionEntry$LWS = [originalShadowRootGetter$LWS, alwaysNull$LWS];
  return function distortionElementShadowRootGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementToggleAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        hasAttribute: ElementProtoHasAttribute$LWS,
        toggleAttribute: originalToggleAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementToggleAttribute$LWS(record$LWS) {
    return [originalToggleAttribute$LWS, function toggleAttribute$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (length$LWS > 0) {
        const attrName$LWS = shared$LWS.toString(args$LWS[0]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (distortion$LWS) {
          const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : [];
          // Calling the distortion may end this execution entirely,
          // if the distortion throws.
          shared$LWS.ReflectApply(distortion$LWS, this, distortionArgs$LWS);
          // If the distortion does not throw, then we need to
          // return true | false, based on the presence or absence
          // of this attribute.
          return shared$LWS.ReflectApply(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
        }
        // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        // istanbul ignore next: needs default platform behavior test
        args$LWS[0] = attrName$LWS;
      }
      // istanbul ignore next: needs default platform behavior test
      return shared$LWS.ReflectApply(originalToggleAttribute$LWS, this, args$LWS);
    }];
  };
}
function initDistortionEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    eval: originalEval$LWS
  }
}) {
  return function distortionEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalEval$LWS, sourceText$LWS => sandboxEvaluator$LWS(sharedDom$LWS.transformSourceText(shared$LWS.toString(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS)];
  };
}
function composedPath$LWS() {
  return createDistortedComposedPath$LWS(this);
}
function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = shared$LWS.ReflectApply(sharedDom$LWS.EventProtoCurrentTargetGetter, event$LWS, []);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = shared$LWS.ReflectApply(originalComposedPath$LWS, event$LWS, []);
  const currentTargetIndex$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoIndexOf, rawComposedPath$LWS, [currentTarget$LWS]);
  let distortedComposedPath$LWS = rawComposedPath$LWS;
  for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];
    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoSlice, rawComposedPath$LWS, [i$LWS + 1]);
      break;
    }
  }
  return distortedComposedPath$LWS;
}
function initDistortionEventComposedPath$LWS({
  globalObject: {
    Event: {
      prototype: {
        composedPath: originalComposedPath$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalComposedPath$LWS, composedPath$LWS];
  return function distortionEventComposedPath$LWS() {
    return distortionEntry$LWS;
  };
}
function path$LWS() {
  return createDistortedComposedPath$LWS(this);
}
function initDistortionEventPathGetter$LWS({
  globalObject: {
    Event: Event$LWS
  }
}) {
  const originalPathGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Event$LWS.prototype, 'path');
  // Chromium 109 removed Event.prototype.path:
  // https://chromestatus.com/feature/5726124632965120
  // istanbul ignore else: currently unreachable via tests
  if (typeof originalPathGetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalPathGetter$LWS, path$LWS];
  return function distortionEventPathGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionEventTargetAddEventListener$LWS({
  globalObject: {
    EventTarget: {
      prototype: {
        addEventListener: originalAddEventListener$LWS
      }
    }
  }
}) {
  return function distortionEventTargetAddEventListener$LWS(record$LWS) {
    function addEventListener$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // Ensure that we fallback to the default platform behavior which
      // should fail if less than 2 arguments are provided.
      // istanbul ignore else: needs default platform behavior test
      if (length$LWS > 1) {
        const eventName$LWS = shared$LWS.toString(args$LWS[0]);
        if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
          throw new shared$LWS.LockerSecurityError(createEventListenerExceptionMessage$LWS(this, eventName$LWS));
        }
        args$LWS[0] = eventName$LWS;
      }
      return shared$LWS.ReflectApply(originalAddEventListener$LWS, this, args$LWS);
    }
    return [originalAddEventListener$LWS, addEventListener$LWS];
  };
}
function initDistortionFunction$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    Function: originalFunction$LWS
  }
}) {
  const funcFooterRegExp$LWS = /\n?}[^}]*$/;
  return function distortionFunction$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalFunction$LWS, function Function$LWS(...args$LWS) {
      // The `arguments` object has `Symbol.iterator` as an own
      // property, not inherited, so it avoids prototype pollution
      // attacks.
      const sandboxFuncCtor$LWS = sandboxEvaluator$LWS('(function() {return Function(...arguments)})');
      const {
        length: length$LWS
      } = args$LWS;
      if (!length$LWS) {
        return shared$LWS.ReflectApply(sandboxFuncCtor$LWS, this, []);
      }
      const lastIndex$LWS = length$LWS - 1;
      const funcBody$LWS = shared$LWS.toString(args$LWS[lastIndex$LWS]);
      // Validate parsing the function body.
      shared$LWS.ReflectApply(sandboxFuncCtor$LWS, this, [funcBody$LWS]);
      // Make function body empty to create the wire-frame.
      args$LWS[lastIndex$LWS] = '';
      const wireFunc$LWS = shared$LWS.ReflectApply(sandboxFuncCtor$LWS, this, args$LWS);
      const prefix$LWS = `${sharedDom$LWS.generateContextAssignmentCodeFromContextNames(sharedDom$LWS.UNIVERSAL_CONTEXT_NAMES)};`;
      const header$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, `${wireFunc$LWS}`, [funcFooterRegExp$LWS, '']);
      const code$LWS = sharedDom$LWS.compileSourceText(funcBody$LWS);
      // NOTE: Function constructor and eval are controlled by the
      // same CSP rules, which means we can rely on eval to fulfill
      // the behavior of the Function constructor.
      return sandboxEvaluator$LWS(`${prefix$LWS}(${header$LWS}${code$LWS}\n})`, UNCOMPILED_CONTEXT$LWS);
    }];
  };
}
function initDistortionHistoryPushState$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    History: {
      prototype: {
        pushState: originalPushState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPushState$LWS, function pushState$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalPushState$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const state$LWS = args$LWS[0];
        if (shared$LWS.isObject(state$LWS)) {
          args$LWS[0] = shared$LWS.partialStructuredClone(state$LWS);
          return shared$LWS.ReflectApply(originalPushState$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionHistoryPushState$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHistoryReplaceState$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    History: {
      prototype: {
        replaceState: originalReplaceState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceState$LWS, function replaceState$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalReplaceState$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const state$LWS = args$LWS[0];
        if (shared$LWS.isObject(state$LWS)) {
          args$LWS[0] = shared$LWS.partialStructuredClone(state$LWS);
          return shared$LWS.ReflectApply(originalReplaceState$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionHistoryReplaceState$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLBodyElementOnrejectionhandled$LWS({
  globalObject: {
    HTMLBodyElement: HTMLBodyElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'rejectionhandled');
}
function initDistortionHTMLBodyElementOnstorage$LWS({
  globalObject: {
    HTMLBodyElement: HTMLBodyElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'storage');
}
function initDistortionHTMLBodyElementOnunhandledrejection$LWS({
  globalObject: {
    HTMLBodyElement: HTMLBodyElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'unhandledrejection');
}
function initDistortionHTMLElementCtor$LWS({
  document: document$LWS,
  globalObject: {
    HTMLElement: originalHTMLElementCtor$LWS
  }
}) {
  // We MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  return function distortionHTMLElementCtor$LWS({
    key: key$LWS
  }) {
    let registry$LWS;
    return [originalHTMLElementCtor$LWS, function HTMLElement$LWS() {
      if (new.target === undefined) {
        throw new shared$LWS.TypeErrorCtor(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
      }
      if (new.target === HTMLElement$LWS) {
        throw new shared$LWS.TypeErrorCtor(ERR_ILLEGAL_CONSTRUCTOR$LWS);
      }
      if (registry$LWS === undefined) {
        registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      }
      return registry$LWS.newCtor(this, new.target, originalHTMLElementCtor$LWS);
    }];
  };
}
function initDistortionHTMLElementDatasetGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return shared$LWS.trackAsLiveTarget(shared$LWS.ReflectApply(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionHTMLElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$9$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionHTMLElementInnerTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalInnerTextSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLElement$LWS.prototype, 'innerText');
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalInnerTextSetter$LWS, function innerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$9$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set innerText of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
    }
    shared$LWS.ReflectApply(originalInnerTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementInnerTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$8$LWS
} = sharedDom$LWS.rootValidator;
// The outerText property is non-standard, so the descriptor could be undefined,
// like in the case of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility
function initDistortionHTMLElementOuterTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalOuterTextSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLElement$LWS.prototype, 'outerText');
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalOuterTextSetter$LWS, function outerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$8$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set outerText of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
    }
    shared$LWS.ReflectApply(originalOuterTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementOuterTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLElementStyleGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return shared$LWS.trackAsLiveTarget(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }];
  return function distortionHTMLElementStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLFrameSetElementOnrejectionhandled$LWS({
  globalObject: {
    HTMLFrameSetElement: HTMLFrameSetElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'rejectionhandled');
}
function initDistortionHTMLFrameSetElementOnstorage$LWS({
  globalObject: {
    HTMLFrameSetElement: HTMLFrameSetElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'storage');
}
function initDistortionHTMLFrameSetElementOnunhandledrejection$LWS({
  globalObject: {
    HTMLFrameSetElement: HTMLFrameSetElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'unhandledrejection');
}
function initDistortionIFrameElementContentDocumentGetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalContentDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLIFrameElement$LWS.prototype, 'contentDocument');
  const distortionEntry$LWS = [originalContentDocumentGetter$LWS, function get$LWS() {
    // The contentDocument proxy object of a kept alive sandbox iframe is revoked.
    return shared$LWS.isRevokedProxy(this) ? null : shared$LWS.ReflectApply(originalContentDocumentGetter$LWS, this, []);
  }];
  return function distortionIFrameElementContentDocument$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionIFrameElementContentWindowGetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalContentWindowGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLIFrameElement$LWS.prototype, 'contentWindow');
  const distortionEntry$LWS = [originalContentWindowGetter$LWS, function get$LWS() {
    // The contentWindow proxy object of a kept alive sandbox iframe is revoked.
    return shared$LWS.isRevokedProxy(this) ? null : shared$LWS.ReflectApply(originalContentWindowGetter$LWS, this, []);
  }];
  return function distortionIFrameElementContentWindow$LWS() {
    return distortionEntry$LWS;
  };
}
function src$LWS(value$LWS) {
  const urlString$LWS = sharedUrl$LWS.sanitizeURLForElement(value$LWS);
  if (!sharedUrl$LWS.isValidURLScheme(urlString$LWS)) {
    throw new shared$LWS.LockerSecurityError('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
  }
  shared$LWS.ReflectApply(sharedDom$LWS.HTMLIFrameElementProtoSrcSetter, this, [urlString$LWS]);
}
function initDistortionHTMLIFrameElementSrcSetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLIFrameElement$LWS.prototype, 'src');
  const distortionMapEntry$LWS = [originalSrcSetter$LWS, src$LWS];
  return function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', sharedDom$LWS.NAMESPACE_DEFAULT, src$LWS);
    return distortionMapEntry$LWS;
  };
}
const importRegExp$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';
function isValidRelValue$LWS(value$LWS) {
  return typeof value$LWS !== 'string' || !shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, importRegExp$LWS, [value$LWS]);
}
function initDistortionHTMLLinkElementRelSetter$LWS({
  globalObject: {
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLLinkElement$LWS.prototype, 'rel');
  function rel$LWS(value$LWS) {
    const valueAsString$LWS = shared$LWS.toString(value$LWS);
    if (isValidRelValue$LWS(valueAsString$LWS)) {
      shared$LWS.ReflectApply(originalRelSetter$LWS, this, [valueAsString$LWS]);
      return;
    }
    shared$LWS.consoleWarn(WARN_MESSAGE$LWS);
  }
  const distortionEntry$LWS = [originalRelSetter$LWS, rel$LWS];
  return function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', sharedDom$LWS.NAMESPACE_DEFAULT, rel$LWS);
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLLinkElementRelListSetter$LWS({
  globalObject: {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelListSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLLinkElement$LWS.prototype, 'relList');
  const distortionEntry$LWS = [originalRelListSetter$LWS, function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? /* istanbul ignore next: needs default platform behavior test */shared$LWS.ReflectApply(sharedDom$LWS.DOMTokenListProtoValueGetter, relListValue$LWS, []) : shared$LWS.toString(relListValue$LWS);
    if (isValidRelValue$LWS(string$LWS)) {
      shared$LWS.ReflectApply(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }
    shared$LWS.consoleWarn(WARN_MESSAGE$LWS);
  }];
  return function distortionHTMLLinkElementRelListSetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLObjectElementDataSetter$LWS({
  globalObject: {
    HTMLObjectElement: HTMLObjectElement$LWS
  }
}) {
  const originalDataSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLObjectElement$LWS.prototype, 'data');
  function data$LWS(value$LWS) {
    const urlString$LWS = sharedUrl$LWS.sanitizeURLForElement(value$LWS);
    if (!sharedUrl$LWS.isValidURLScheme(urlString$LWS)) {
      throw new shared$LWS.LockerSecurityError('HTMLObjectElement.data supports http://, https:// schemes and relative urls.');
    }
    const parsedURL$LWS = sharedUrl$LWS.parseURL(urlString$LWS);
    if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
      throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
    }
    shared$LWS.ReflectApply(originalDataSetter$LWS, this, [trustedTypes$LWS.trusted.createScriptURL(urlString$LWS)]);
  }
  const distortionEntry$LWS = [originalDataSetter$LWS, data$LWS];
  return function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', sharedDom$LWS.NAMESPACE_DEFAULT, data$LWS);
    return distortionEntry$LWS;
  };
}
const descriptorCaches$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
function createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributeName$LWS) {
  return function initDistortionBlockedAttribute$LWS() {
    const enquotedAttributeName$LWS = shared$LWS.enquote(attributeName$LWS);
    const distortionName$LWS = `blocked${shared$LWS.capitalizeFirstChar(attributeName$LWS)}Attribute`;
    // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.
    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS]: () => {
        throw new shared$LWS.LockerSecurityError(`Attribute ${enquotedAttributeName$LWS} not allowed on ${ctorName$LWS}.`);
      }
    };
    return function distortionBlockedAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, sharedDom$LWS.NAMESPACE_DEFAULT, distortion$LWS);
    };
  };
}
function createGetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalGet$LWS = shared$LWS.ObjectLookupOwnGetter(proto$LWS, key$LWS);
  const keyAsString$LWS = shared$LWS.toSafeTemplateStringValue(key$LWS);
  const distortionEntry$LWS = [originalGet$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function get$LWS() {
    throw new shared$LWS.LockerSecurityError(`Cannot access ${keyAsString$LWS}.`);
  }];
  function getThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }
  return function getThrowerDistortionFactoryInitializer$LWS() {
    return getThrowerDistortionFactory$LWS;
  };
}
function createSetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalSet$LWS = shared$LWS.ObjectLookupOwnSetter(proto$LWS, key$LWS);
  const keyAsString$LWS = shared$LWS.toSafeTemplateStringValue(key$LWS);
  const distortionEntry$LWS = [originalSet$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function set$LWS() {
    throw new shared$LWS.LockerSecurityError(`Cannot access ${keyAsString$LWS}.`);
  }];
  function setThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }
  return function setThrowerDistortionFactoryInitializer$LWS() {
    return setThrowerDistortionFactory$LWS;
  };
}
function createValueThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const {
    [key$LWS]: originalValue$LWS
  } = proto$LWS;
  const keyAsString$LWS = shared$LWS.toSafeTemplateStringValue(key$LWS);
  const distortionEntry$LWS = [originalValue$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function value$LWS() {
    throw new shared$LWS.LockerSecurityError(`Cannot access ${keyAsString$LWS}.`);
  }];
  function valueThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }
  return function valueThrowerDistortionFactoryInitializer$LWS() {
    return valueThrowerDistortionFactory$LWS;
  };
}
function addBlockedAttributeDistortionFactoryInitializers$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS[i$LWS]);
  }
}
function addBlockedPropertyDistortionFactoryInitializers$LWS({
  document: document$LWS
}, proto$LWS, properties$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;
  let descsCache$LWS = descriptorCaches$LWS.get(document$LWS);
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (descsCache$LWS === undefined) {
    descsCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
    descriptorCaches$LWS.set(document$LWS, descsCache$LWS);
  }
  let safeDescs$LWS = descsCache$LWS.get(proto$LWS);
  // istanbul ignore else: need a test for this on the same document but different namespace
  if (safeDescs$LWS === undefined) {
    safeDescs$LWS = {
      __proto__: null
    };
    descsCache$LWS.set(proto$LWS, safeDescs$LWS);
  }
  for (let i$LWS = 0, {
      length: length$LWS
    } = properties$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = properties$LWS[i$LWS];
    let safeDesc$LWS = safeDescs$LWS[prop$LWS];
    if (safeDesc$LWS === undefined) {
      var _shared$ReflectGetOwn$LWS;
      safeDesc$LWS = (_shared$ReflectGetOwn$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(proto$LWS, prop$LWS)) != null ? _shared$ReflectGetOwn$LWS : null;
      if (safeDesc$LWS) {
        shared$LWS.ReflectSetPrototypeOf(safeDesc$LWS, null);
      }
      safeDescs$LWS[prop$LWS] = safeDesc$LWS;
    }
    if (safeDesc$LWS) {
      const {
        value: value$LWS
      } = safeDesc$LWS;
      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;
        // istanbul ignore else
        if (getter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createGetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
        if (setter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createSetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      } else {
        // The following if statement is enclosed in a dedicated else {}
        // because prettier won't allow a multi-line comment between
        // "else" and "if", which is where the istanbul ignore directive
        // must go to be effective.
        // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
        if (typeof value$LWS === 'function') {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createValueThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      }
    }
  }
}
const scriptURLs$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
function trackScriptURL$LWS(targetElement$LWS, url$LWS) {
  scriptURLs$LWS.set(targetElement$LWS, url$LWS);
}
function getScriptURL$LWS(targetElement$LWS) {
  return scriptURLs$LWS.get(targetElement$LWS);
}
function createScriptDistortion$LWS({
  sandboxEvaluator: sandboxEvaluator$LWS
}, attributeName$LWS) {
  const distortionName$LWS = `script${shared$LWS.capitalizeFirstChar(attributeName$LWS)}`;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  // Use a computed property to dynamically set the distortion function name
  // without using `Reflect.defineProperty()`.
  const {
    [distortionName$LWS]: distortion$LWS
  } = {
    [distortionName$LWS](url$LWS) {
      trackScriptURL$LWS(this, sharedUrl$LWS.resolveURL(url$LWS));
      const targetElement$LWS = this;
      const evaluator$LWS = function evaluator$LWS(sourceText$LWS) {
        const ownerDoc$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, targetElement$LWS, []);
        const defaultView$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDefaultViewGetter, ownerDoc$LWS, []);
        const context$LWS = {
          [shared$LWS.UNCOMPILED_LOCATION_NAME]: defaultView$LWS.location,
          [shared$LWS.UNCOMPILED_TOP_NAME]: defaultView$LWS.top
        };
        sourceText$LWS = sharedDom$LWS.transformSourceText(sourceText$LWS);
        return sandboxEvaluator$LWS(sourceText$LWS, context$LWS, defaultView$LWS, ownerDoc$LWS);
      };
      internalPolicy$LWS.lwsInternalPolicy.createScriptURL(url$LWS, evaluator$LWS, targetElement$LWS);
    }
  };
  return distortion$LWS;
}
function initDistortionHTMLScriptElementSrcGetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const originalSrcGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLScriptElement$LWS.prototype, 'src');
  const distortionEntry$LWS = [originalSrcGetter$LWS, function src$LWS() {
    var _getScriptURL$LWS;
    return (_getScriptURL$LWS = getScriptURL$LWS(this)) != null ? _getScriptURL$LWS : shared$LWS.ReflectApply(originalSrcGetter$LWS, this, []);
  }];
  return function distortionHTMLScriptElementSrcGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLScriptElementSrcSetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const {
    set: originalSrcSetter$LWS
  } = shared$LWS.ReflectGetOwnPropertyDescriptor(HTMLScriptElement$LWS.prototype, 'src');
  return function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
    const src$LWS = createScriptDistortion$LWS(record$LWS, 'src');
    registerAttributeDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', sharedDom$LWS.NAMESPACE_DEFAULT, src$LWS);
    return [originalSrcSetter$LWS, src$LWS];
  };
}
function initDistortionHTMLScriptElementTextSetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  const {
    get: originalTextGetter$LWS,
    set: originalTextSetter$LWS
  } = shared$LWS.ReflectGetOwnPropertyDescriptor(HTMLScriptElement$LWS.prototype, 'text');
  return function distortionHTMLScriptElementTextSetter$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalTextSetter$LWS, function text$LWS(value$LWS) {
      if (this instanceof HTMLScriptElement$LWS) {
        const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'text', trustedTypes$LWS.trusted.createScript(value$LWS), originalTextGetter$LWS, originalTextSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trustedTypes$LWS.trusted.createScript(sharedDom$LWS.SCRIPT_HOOK_SOURCE_TEXT));
        if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
          return;
        }
      }
      shared$LWS.ReflectApply(originalTextSetter$LWS, this, [value$LWS]);
    }];
  };
}
function initDistortionIDBObjectStoreAdd$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    IDBObjectStore: {
      prototype: {
        add: originalAdd$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAdd$LWS, function add$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalAdd$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const value$LWS = args$LWS[0];
        if (shared$LWS.isObject(value$LWS)) {
          args$LWS[0] = shared$LWS.partialStructuredClone(value$LWS);
          return shared$LWS.ReflectApply(originalAdd$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionIDBObjectStoreAdd$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionIDBObjectStorePut$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    IDBObjectStore: {
      prototype: {
        put: originalPut$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPut$LWS, function put$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalPut$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const value$LWS = args$LWS[0];
        if (shared$LWS.isObject(value$LWS)) {
          args$LWS[0] = shared$LWS.partialStructuredClone(value$LWS);
          return shared$LWS.ReflectApply(originalPut$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionIDBObjectStorePut$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionMessagePortPostMessage$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    MessagePort: MessagePort$LWS
  }
}) {
  const {
    postMessage: originalPostMessage$LWS
  } = MessagePort$LWS.prototype;
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalPostMessage$LWS, this, args$LWS);
    } catch (error) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS && error instanceof DOMException$LWS) {
        const message$LWS = args$LWS[0];
        if (shared$LWS.isObject(message$LWS)) {
          if (length$LWS > 1) {
            // MDN document providing a transfer list array
            // while the WHATWG documents providing an options
            // object with a 'transfer' property. To cover both
            // cases we structurally clone the entire `args` array.
            // https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage#parameters
            // https://html.spec.whatwg.org/multipage/web-messaging.html#dom-structuredserializeoptions-transfer
            args$LWS = shared$LWS.partialStructuredClone(args$LWS);
          } else {
            args$LWS[0] = shared$LWS.partialStructuredClone(message$LWS);
          }
          return shared$LWS.ReflectApply(originalPostMessage$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionMessagePortPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNamedNodeMapSetNamedItem$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItem: originalSetNamedItem$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
    return [originalSetNamedItem$LWS, function setNamedItem$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
      }
      return shared$LWS.ReflectApply(originalSetNamedItem$LWS, this, args$LWS);
    }];
  };
}
function initDistortionNamedNodeMapSetNamedItemNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItemNS: originalSetNamedItemNS$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
    return [originalSetNamedItemNS$LWS, function setNamedItemNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
      }
      return shared$LWS.ReflectApply(originalSetNamedItemNS$LWS, this, args$LWS);
    }];
  };
}
function initDistortionNavigatorSendBeacon$LWS({
  globalObject: {
    Navigator: {
      prototype: {
        sendBeacon: originalSendBeacon$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSendBeacon$LWS, function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(args$LWS[0]));
      if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }
      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }
    return shared$LWS.ReflectApply(originalSendBeacon$LWS, this, args$LWS);
  }];
  return function distortionNavigatorSendBeacon$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNavigatorServiceWorkerGetter$LWS({
  globalObject: {
    Navigator: Navigator$LWS
  }
}) {
  const originalServiceWorkerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Navigator$LWS.prototype, 'serviceWorker');
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalServiceWorkerGetter$LWS, shared$LWS.noop];
  return function distortionNavigatorServiceWorkerGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$7$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$1$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionNodeInsertBefore$LWS({
  globalObject: {
    Node: {
      prototype: {
        insertBefore: originalInsertBefore$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertBefore$LWS, function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$7$LWS(this) && !isAllowedSharedElementChild$1$LWS(node$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert child ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, node$LWS, [])} into ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])},`);
      }
    }
    return shared$LWS.ReflectApply(originalInsertBefore$LWS, this, args$LWS);
  }];
  return function distortionNodeInsertBefore$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNodeValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS
  }
}) {
  const originalNodeValueSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Node$LWS.prototype, 'nodeValue');
  return function distortionNodeValueSetter$LWS(record$LWS) {
    return [originalNodeValueSetter$LWS, function nodeValue$LWS(value$LWS) {
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the nodeValue property.
      // istanbul ignore else: needs default platform behavior test
      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, this, []);
        // istanbul ignore if: needs default platform behavior test
        if (ownerEl$LWS === null) {
          shared$LWS.ReflectApply(originalNodeValueSetter$LWS, this, [value$LWS]);
          return;
        }
        const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, this, []);
        const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, ownerEl$LWS, [value$LWS]);
          return;
        }
      }
      // istanbul ignore next: needs default platform behavior test
      shared$LWS.ReflectApply(originalNodeValueSetter$LWS, this, [value$LWS]);
    }];
  };
}
const {
  isSharedElement: isSharedElement$6$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionNodeRemoveChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        removeChild: originalRemoveChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemoveChild$LWS, function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception
    // is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: child$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$6$LWS(child$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot remove ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, child$LWS, [])}.`);
      }
    }
    // istanbul ignore next: needs default platform behavior test
    return shared$LWS.ReflectApply(originalRemoveChild$LWS, this, args$LWS);
  }];
  return function distortionNodeRemoveChild$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$5$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionNodeReplaceChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        replaceChild: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments.
    // If the "old element" argument is a valid shared element, an
    // exception is thrown.
    const {
      length: length$LWS
    } = args$LWS;
    // istanbul ignore else: needs default platform behavior test
    if (length$LWS > 1) {
      const {
        1: child$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$5$LWS(child$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot replace ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, child$LWS, [])}.`);
      }
    }
    // istanbul ignore next: needs default platform behavior test
    return shared$LWS.ReflectApply(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionNodeReplaceChild$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNodeTextContentGetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS,
    Node: Node$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  const originalTextContentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Node$LWS.prototype, 'textContent');
  const distortionEntry$LWS = [originalTextContentGetter$LWS, function textContent$LWS() {
    if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
      var _sharedDom$getOrigina$LWS;
      return (_sharedDom$getOrigina$LWS = sharedDom$LWS.getOriginalScriptProperty(this)) != null ? _sharedDom$getOrigina$LWS : shared$LWS.ReflectApply(originalTextContentGetter$LWS, this, []);
    }
    return shared$LWS.ReflectApply(originalTextContentGetter$LWS, this, []);
  }];
  return function distortionHTMLScriptElementSrcGetter$LWS() {
    return distortionEntry$LWS;
  };
}

// IMPORTANT! This validator MUST use the top "window" global object, and not
// the provided "globalObject" because magenta objects (arbitrary user-code
// created global objects) must be allowed to interact with their OWN <html>,
// <head> and <body> (within the iframe content window). Using the provided
// "globalObject" here would result in receiving a validator bound to the
// magenta global object, which would erroneously prevent code from interacting
// with that document's <html>, <head> and <body>.
const {
  isSharedElement: isSharedElement$4$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionNodeTextContentSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  const {
    get: originalTextContentGetter$LWS,
    set: originalTextContentSetter$LWS
  } = shared$LWS.ReflectGetOwnPropertyDescriptor(Node$LWS.prototype, 'textContent');
  return function distortionNodeTextContentSetter$LWS(record$LWS) {
    const {
      sandboxEvaluator: sandboxEvaluator$LWS
    } = record$LWS;
    return [originalTextContentSetter$LWS, function textContent$LWS(value$LWS) {
      const valueAsString$LWS = trustedTypes$LWS.trusted.createScript(value$LWS);
      // There are two existence of the attribute textContent, one on
      // Attr and one on Node. This first if statement is checking to
      // figure out which distortion should be applied. The instanceof
      // operator tests to see if the current global object, this,
      // is of the type Attr, while also taking inheritance into
      // consideration.
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the textContent property.
      // istanbul ignore else: needs default platform behavior test
      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, this, []);
        // istanbul ignore if: needs default platform behavior test
        if (ownerEl$LWS === null) {
          shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
          return;
        }
        const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, this, []);
        const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
          return;
        }
      } else if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
        const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'textContent', valueAsString$LWS, originalTextContentGetter$LWS, originalTextContentSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trustedTypes$LWS.trusted.createScript(sharedDom$LWS.SCRIPT_HOOK_SOURCE_TEXT));
        if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
          return;
        }
      }
      // istanbul ignore else: needs default platform behavior test
      else if (isSharedElement$4$LWS(this)) {
        throw new shared$LWS.LockerSecurityError(`Cannot set textContent of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])} elements.`);
      }
      shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
    }];
  };
}
function initDistortionNotificationCtor$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    Notification: originalNotificationCtor$LWS
  }
}) {
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalNotificationCtor$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalNotificationCtor$LWS, function Notification$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectConstruct(originalNotificationCtor$LWS, args$LWS);
    } catch (error) {
      if (args$LWS.length > 1 && error instanceof DOMException$LWS) {
        const providedOptions$LWS = args$LWS[1];
        if (shared$LWS.isObjectLike(providedOptions$LWS)) {
          const {
            data: data$LWS
          } = providedOptions$LWS;
          if (shared$LWS.isObject(data$LWS)) {
            args$LWS[1] = {
              // The Notification constructor accepts
              // inherited options property values.
              __proto__: providedOptions$LWS,
              // Shadow any inherited value.
              data: shared$LWS.partialStructuredClone(data$LWS)
            };
            return shared$LWS.ReflectConstruct(originalNotificationCtor$LWS, args$LWS);
          }
        }
      }
      throw error;
    }
  }];
  return function distortionNotificationCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionRangeCreateContextualFragment$LWS({
  document: document$LWS,
  globalObject: {
    Range: {
      prototype: {
        createContextualFragment: originalCreateContextualFragment$LWS
      }
    }
  }
}) {
  return function distortionRangeCreateContextualFragment$LWS({
    key: key$LWS
  }) {
    return [originalCreateContextualFragment$LWS, function createContextualFragment$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: tagString$LWS
        } = args$LWS;
        if (tagString$LWS !== null && tagString$LWS !== undefined) {
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created
          // MAY CONTAIN a custom element, which must be marked
          // for association to this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          args$LWS[0] = internalPolicy$LWS.lwsInternalPolicy.createHTML(tagString$LWS, key$LWS, internalPolicy$LWS.ContentType.HTML);
        }
      }
      return shared$LWS.ReflectApply(originalCreateContextualFragment$LWS, this, args$LWS);
    }];
  };
}
const {
  isSharedElement: isSharedElement$3$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionRangeDeleteContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        deleteContents: originalDeleteContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalDeleteContents$LWS, function deleteContents$LWS(...args$LWS) {
    const containers$LWS = [shared$LWS.ReflectApply(originalEndContainerGetter$LWS, this, []), shared$LWS.ReflectApply(originalStartContainerGetter$LWS, this, [])];
    for (let i$LWS = 0, {
        length: length$LWS
      } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];
      if (isSharedElement$3$LWS(container$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot delete contents of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, container$LWS, [])}.`);
      }
    }
    return shared$LWS.ReflectApply(originalDeleteContents$LWS, this, args$LWS);
  }];
  return function distortionRangeDeleteContents$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$2$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionRangeExtractContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        extractContents: originalExtractContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalExtractContents$LWS, function extractContents$LWS(...args$LWS) {
    const containers$LWS = [shared$LWS.ReflectApply(originalEndContainerGetter$LWS, this, []), shared$LWS.ReflectApply(originalStartContainerGetter$LWS, this, [])];
    for (let i$LWS = 0, {
        length: length$LWS
      } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];
      if (isSharedElement$2$LWS(container$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot extract contents of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, container$LWS, [])}.`);
      }
    }
    return shared$LWS.ReflectApply(originalExtractContents$LWS, this, args$LWS);
  }];
  return function distortionRangeExtractContents$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$1$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
} = sharedDom$LWS.rootValidator;
function initDistortionRangeInsertNode$LWS({
  globalObject: {
    Range: {
      prototype: {
        insertNode: originalInsertNode$LWS
      }
    }
  }
}) {
  const originalCommonAncestorContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Range.prototype, 'commonAncestorContainer');
  const distortionEntry$LWS = [originalInsertNode$LWS, function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const commonAncestorContainer$LWS = shared$LWS.ReflectApply(originalCommonAncestorContainerGetter$LWS, this, []);
      if (commonAncestorContainer$LWS && isSharedElement$1$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(args$LWS[0])) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert a new child node of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, commonAncestorContainer$LWS, [])}.`);
      }
    }
    return shared$LWS.ReflectApply(originalInsertNode$LWS, this, args$LWS);
  }];
  return function distortionRangeInsertNode$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$LWS
} = sharedDom$LWS.rootValidator;
function createRangeProtoMethodDistortionFactoryInitializer$LWS(methodName$LWS) {
  return function initDistortionContentWindowGetter$LWS({
    globalObject: {
      Range: {
        // @ts-ignore: Prevent index type error.
        prototype: {
          [methodName$LWS]: originalMethod$LWS
        }
      }
    }
  }) {
    // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.
    const {
      [methodName$LWS]: distortion$LWS
    } = {
      [methodName$LWS](...args$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (args$LWS.length) {
          const {
            0: node$LWS
          } = args$LWS;
          // istanbul ignore else: needs default platform behavior test
          if (isSharedElement$LWS(node$LWS)) {
            throw new shared$LWS.LockerSecurityError(`Cannot call ${methodName$LWS} with ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, node$LWS, [])}.`);
          }
        }
        return shared$LWS.ReflectApply(originalMethod$LWS, this, args$LWS);
      }
    };
    const distortionEntry$LWS = [originalMethod$LWS, distortion$LWS];
    return function distortionContentWindowGetter$LWS() {
      return distortionEntry$LWS;
    };
  };
}
const initDistortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEnd');
const initDistortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNode');
const initDistortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNodeContents');
const initDistortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndAfter');
const initDistortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndBefore');
const initDistortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStart');
const initDistortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartAfter');
const initDistortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartBefore');
const initDistortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('surroundContents');
function initDistortionServiceWorkerContainerProto$LWS({
  globalObject: {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
  return function distortionServiceWorkerContainerProto$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionShadowRootInnerHTMLSetter$LWS({
  document: document$LWS,
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalInnerHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(ShadowRoot$LWS.prototype, 'innerHTML');
  return function distortionShadowRootInnerHTMLSetter$LWS({
    key: key$LWS
  }) {
    return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      shared$LWS.ReflectApply(originalInnerHTMLSetter$LWS, this, [internalPolicy$LWS.lwsInternalPolicy.createHTML(value$LWS, key$LWS, internalPolicy$LWS.ContentType.HTML)]);
    }];
  };
}
function mode$LWS() {
  return 'closed';
}
function initDistortionShadowRootModeGetter$LWS({
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalModeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(ShadowRoot$LWS.prototype, 'mode');
  const distortionEntry$LWS = [originalModeGetter$LWS, mode$LWS];
  return function distortionShadowRootModeGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function SharedWorker$LWS(scriptURL$LWS) {
  throw new shared$LWS.LockerSecurityError(`Cannot create SharedWorker with ${shared$LWS.toSafeTemplateStringValue(scriptURL$LWS)}.`);
}
function initDistortionSharedWorkerCtor$LWS({
  globalObject: {
    SharedWorker: originalSharedWorkerCtor$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
  return function distortionSharedWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionSharedWorkerProto$LWS({
  globalObject: {
    SharedWorker: SharedWorker$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof SharedWorker$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
  return function distortionSharedWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}
function getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS) {
  const storageKeys$LWS = shared$LWS.ObjectKeys(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;
  for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];
    if (shared$LWS.startsWithStorageNamespaceMarker(key$LWS, namespace$LWS)) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }
  return keys$LWS;
}
function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = shared$LWS.ArrayCtor(length$LWS);
  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = shared$LWS.removeStorageNamespaceMarker(key$LWS, namespace$LWS);
  }
  return keys$LWS;
}
const storageToMetaMap$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (storageMeta$LWS === undefined) {
    throw new shared$LWS.LockerSecurityError(ERR_ILLEGAL_INVOCATION$LWS);
  }
  return storageMeta$LWS;
}
function createStorageProxy$LWS(storageTarget$LWS) {
  const proxy$LWS = new shared$LWS.ProxyCtor(storageTarget$LWS, {
    // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
    get(target$LWS, key$LWS, receiver$LWS) {
      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = shared$LWS.prependStorageNamespaceMarker(key$LWS, namespace$LWS);
      if (shared$LWS.ObjectHasOwn(storage$LWS, markedKey$LWS)) {
        return shared$LWS.ReflectGet(storage$LWS, markedKey$LWS);
      }
      const proto$LWS = shared$LWS.ReflectGetPrototypeOf(target$LWS);
      return proto$LWS === null ? undefined : shared$LWS.ReflectGet(proto$LWS, key$LWS, receiver$LWS);
    },
    set(target$LWS, key$LWS, value$LWS) {
      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectSet(target$LWS, key$LWS, value$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = shared$LWS.prependStorageNamespaceMarker(key$LWS, namespace$LWS);
      shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoSetItem, storage$LWS, [markedKey$LWS, value$LWS]);
      return true;
    },
    defineProperty(target$LWS, key$LWS, unsafePartialDesc$LWS) {
      const safeDesc$LWS = unsafePartialDesc$LWS;
      shared$LWS.ReflectSetPrototypeOf(safeDesc$LWS, null);
      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectDefineProperty(target$LWS, key$LWS, safeDesc$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = shared$LWS.prependStorageNamespaceMarker(key$LWS, namespace$LWS);
      return shared$LWS.ReflectDefineProperty(storage$LWS, markedKey$LWS, safeDesc$LWS);
    },
    deleteProperty(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectDeleteProperty(target$LWS, key$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = shared$LWS.prependStorageNamespaceMarker(key$LWS, namespace$LWS);
      return shared$LWS.ReflectDeleteProperty(storage$LWS, markedKey$LWS);
    },
    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      let safeDesc$LWS;
      if (typeof key$LWS === 'symbol') {
        safeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(target$LWS, key$LWS);
      } else {
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = shared$LWS.prependStorageNamespaceMarker(key$LWS, namespace$LWS);
        safeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(storage$LWS, markedKey$LWS);
      }
      if (safeDesc$LWS) {
        shared$LWS.ReflectSetPrototypeOf(safeDesc$LWS, null);
      }
      return safeDesc$LWS;
    },
    ownKeys(target$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS);
      const localSymbolKeys$LWS = shared$LWS.ObjectGetOwnPropertySymbols(target$LWS);
      return shared$LWS.ArrayConcat(storageKeys$LWS, localSymbolKeys$LWS);
    },
    // istanbul ignore next: suspicious gap, currently unreachable via tests
    has(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectHas(target$LWS, key$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = shared$LWS.prependStorageNamespaceMarker(key$LWS, namespace$LWS);
      if (shared$LWS.ObjectHasOwn(storage$LWS, markedKey$LWS)) {
        return true;
      }
      const proto$LWS = shared$LWS.ReflectGetPrototypeOf(target$LWS);
      if (proto$LWS === null) {
        return false;
      }
      return shared$LWS.ReflectHas(proto$LWS, key$LWS);
    },
    preventExtensions(_target$LWS) {
      return false;
    }
  });
  return proxy$LWS;
}
class PatchedStorage$LWS {
  // istanbul ignore next: currently unreachable via tests
  constructor() {
    throw new shared$LWS.LockerSecurityError(ERR_ILLEGAL_CONSTRUCTOR$LWS);
  }
  get length() {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
    return storageKeysForNamespace$LWS.length;
  }
  key(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;
      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }
      return shared$LWS.removeStorageNamespaceMarker(resolvedKey$LWS, namespace$LWS);
    }
    return shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoKey, storage$LWS, args$LWS);
  }
  getItem(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length) {
      args$LWS[0] = shared$LWS.prependStorageNamespaceMarker(shared$LWS.toString(args$LWS[0]), namespace$LWS);
    }
    return shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoGetItem, storage$LWS, args$LWS);
  }
  setItem(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length > 1) {
      args$LWS[0] = shared$LWS.prependStorageNamespaceMarker(shared$LWS.toString(args$LWS[0]), namespace$LWS);
      args$LWS[1] = shared$LWS.toString(args$LWS[1]);
    }
    shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoSetItem, storage$LWS, args$LWS);
  }
  removeItem(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length) {
      args$LWS[0] = shared$LWS.prependStorageNamespaceMarker(shared$LWS.toString(args$LWS[0]), namespace$LWS);
    }
    shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoRemoveItem, storage$LWS, args$LWS);
  }
  clear() {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
    for (let i$LWS = 0, {
        length: length$LWS
      } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoRemoveItem, storage$LWS, [key$LWS]);
    }
  }
}
function createStorage$LWS(storage$LWS, namespace$LWS) {
  const proxy$LWS = createStorageProxy$LWS({
    __proto__: PatchedStorage$LWS.prototype
  });
  shared$LWS.trackAsLiveTarget(proxy$LWS);
  storageToMetaMap$LWS.set(proxy$LWS, {
    namespace: namespace$LWS,
    storage: storage$LWS
  });
  return proxy$LWS;
}
const {
  prototype: PatchedStorageProto$LWS
} = PatchedStorage$LWS;
const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorageProto$LWS;
const patchedStorageProtoLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(PatchedStorageProto$LWS, 'length');
function createDistortionStorageFactoryInitializer$LWS(storageName$LWS) {
  return function initDistortionStorageFactory$LWS({
    globalObject: globalObject$LWS
  }) {
    // Depending on browser configuration the storage object may be `null`
    // or throw an exception when its getter is accessed.
    let originalStorageObject$LWS;
    try {
      originalStorageObject$LWS = globalObject$LWS[storageName$LWS];
      // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
    // istanbul ignore if: currently unreachable via tests
    if (!shared$LWS.isObject(originalStorageObject$LWS)) {
      return shared$LWS.noop;
    }
    return function distortionStorageFactory$LWS({
      key: key$LWS
    }) {
      return [originalStorageObject$LWS, createStorage$LWS(originalStorageObject$LWS, key$LWS)];
    };
  };
}
function initDistortionStorageLength$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const originalLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Storage$LWS.prototype, 'length');
  const distortionEntry$LWS = [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
  return function distortionStorageLength$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageGetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        getItem: originalStorageGetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageSetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        setItem: originalStorageSetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageKey$LWS({
  globalObject: {
    Storage: {
      prototype: {
        key: originalStorageKey$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
  return function distortionStorageKey$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageRemoveItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        removeItem: originalStorageRemoveItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
  return function distortionStorageRemoveItem$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageClear$LWS({
  globalObject: {
    Storage: {
      prototype: {
        clear: originalStorageClear$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
  return function distortionStorageClear$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorage$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const distortionEntry$LWS = [Storage$LWS, PatchedStorage$LWS];
  return function distortionStorage$LWS() {
    return distortionEntry$LWS;
  };
}
const initDistortionLocalStorage$LWS = createDistortionStorageFactoryInitializer$LWS('localStorage');
const initDistortionSessionStorage$LWS = createDistortionStorageFactoryInitializer$LWS('sessionStorage');
function initDistortionSVGAnimateElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  return function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, el$LWS, [attrName$LWS]);
        // istanbul ignore else: needs default platform behavior test
        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
          // istanbul ignore else: needs default platform behavior test
          if (distortion$LWS) {
            shared$LWS.ReflectApply(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', sharedDom$LWS.NAMESPACE_DEFAULT, function attributeName$LWS(value$LWS) {
      shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);
      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'from');
        distortAttribute$LWS(this, 'to');
        distortAttribute$LWS(this, 'values');
      }
    });
  };
}
function initDistortionSVGAnimateElementFromAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function from$LWS(value$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }
  return function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', sharedDom$LWS.NAMESPACE_DEFAULT, from$LWS);
  };
}
function initDistortionSVGAnimateElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }
  return function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', sharedDom$LWS.NAMESPACE_DEFAULT, to$LWS);
  };
}
function initDistortionSVGAnimateElementValuesAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      const valuesSplit$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, value$LWS, [';']);
      const {
        length: length$LWS
      } = valuesSplit$LWS;
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = htmlSanitizer$LWS.sanitizeSvgHref(valuesSplit$LWS[i$LWS]);
      }
      returnValues$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, valuesSplit$LWS, [';']);
    }
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }
  return function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', sharedDom$LWS.NAMESPACE_DEFAULT, values$LWS);
  };
}
function initDistortionSVGElementDatasetGetter$LWS({
  globalObject: {
    SVGElement: SVGElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return shared$LWS.trackAsLiveTarget(shared$LWS.ReflectApply(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionSVGElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionSVGElementStyleGetter$LWS({
  globalObject: {
    SVGElement: SVGElement$LWS
  }
}) {
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGElement$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return shared$LWS.trackAsLiveTarget(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }];
  return function distortionSVGElementStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const script$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElementNS, document, [sharedDom$LWS.NAMESPACE_SVG, 'script']);
function initDistortionSVGScriptElementHrefGetter$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  const originalHrefGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGScriptElement$LWS.prototype, 'href');
  const distortionEntry$LWS = [originalHrefGetter$LWS, function href$LWS() {
    const url$LWS = getScriptURL$LWS(this);
    if (typeof url$LWS === 'string') {
      shared$LWS.ReflectApply(originalSetAttribute$LWS, script$LWS, ['href', trustedTypes$LWS.trusted.createScriptURL(url$LWS)]);
      return shared$LWS.ReflectApply(originalHrefGetter$LWS, script$LWS, []);
    }
    return shared$LWS.ReflectApply(originalHrefGetter$LWS, this, []);
  }];
  return function distortionSVGScriptElementHrefGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionSVGScriptElementHrefSetter$LWS({
  globalObject: {
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  return function distortionSVGScriptElementHrefSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', sharedDom$LWS.NAMESPACE_XLINK, createScriptDistortion$LWS(record$LWS, 'href'));
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', sharedDom$LWS.NAMESPACE_XLINK, createScriptDistortion$LWS(record$LWS, 'xlink:href'));
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', sharedDom$LWS.NAMESPACE_DEFAULT, createScriptDistortion$LWS(record$LWS, 'href'));
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', sharedDom$LWS.NAMESPACE_DEFAULT, createScriptDistortion$LWS(record$LWS, 'xlink:href'));
  };
}
function initDistortionSVGSetElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  return function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, el$LWS, [attrName$LWS]);
        // istanbul ignore else: needs default platform behavior test
        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
          // istanbul ignore else: needs default platform behavior test
          if (distortion$LWS) {
            shared$LWS.ReflectApply(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }
    function attributeName$LWS(value$LWS) {
      shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);
      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'to');
      }
    }
    registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', sharedDom$LWS.NAMESPACE_DEFAULT, attributeName$LWS);
  };
}
function initDistortionSVGSetElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }
  return function distortionSVGSetElementToAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', sharedDom$LWS.NAMESPACE_DEFAULT, to$LWS);
  };
}
function createDistortionHrefAttributeFactoryInitializer$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactoryInitializer$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS,
          setAttributeNS: originalSetAttributeNS$LWS
        }
      },
      SVGUseElement: SVGUseElement$LWS
    }
  }) {
    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? /* istanbul ignore next: needs default platform behavior test */value$LWS : htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
      shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, [sharedDom$LWS.NAMESPACE_XLINK, attributeName$LWS, returnValue$LWS]);
    }
    return function distortionHrefAttributeFactory$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, sharedDom$LWS.NAMESPACE_XLINK, xlinkNamespaceDistortion$LWS);
      if (attributeName$LWS === 'href') {
        const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
          const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? /* istanbul ignore next: needs default platform behavior test */value$LWS : htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
          shared$LWS.ReflectApply(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
        };
        registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, sharedDom$LWS.NAMESPACE_DEFAULT, defaultNamespaceDistortion$LWS);
      }
    };
  };
}
const initDistortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('href');
const initDistortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('xlink:href');
function initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS({
  globalObject: {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  }
}) {
  var _TrustedTypePolicyFac$LWS;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCreatePolicy$LWS = TrustedTypePolicyFactory$LWS == null ? void 0 : (_TrustedTypePolicyFac$LWS = TrustedTypePolicyFactory$LWS.prototype) == null ? void 0 : _TrustedTypePolicyFac$LWS.createPolicy;
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalCreatePolicy$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalCreatePolicy$LWS, function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] : /* istanbul ignore next: needs default platform behavior test */undefined;
    // istanbul ignore else: needs default platform behavior test
    if (name$LWS === 'default') {
      throw new shared$LWS.LockerSecurityError(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    }
    // istanbul ignore next: needs default platform behavior test
    return shared$LWS.ReflectApply(originalCreatePolicy$LWS, this, args$LWS);
  }];
  return function distortionTrustedTypePolicyFactoryCreatePolicy$LWS() {
    return distortionEntry$LWS;
  };
}
const HTML_MIME_TYPES_LIST$LWS = shared$LWS.toSafeArray(['text/html', 'image/svg+xml', 'text/xml']);
function initDistortionURLCreateObjectURL$LWS({
  document: document$LWS,
  globalObject: globalObject$LWS,
  globalObject: {
    MediaSource: MediaSource$LWS,
    URL: {
      createObjectURL: originalCreateObjectURL$LWS
    }
  }
}) {
  // IMPORTANT! This validator MUST use the record's global object to create
  // a validator and not rely on the `rootValidator` because the validator
  // needs to be bound to the global object of the magenta object (arbitrary
  // user-code created global objects).
  const {
    isEqualDomString: isEqualDomString$LWS
  } = sharedDom$LWS.getValidator(document$LWS, globalObject$LWS);
  return function distortionURLCreateObjectURL$LWS({
    key: key$LWS
  }) {
    const sanitizer$LWS = htmlSanitizer$LWS.blobSanitizer(key$LWS);
    return [originalCreateObjectURL$LWS, function createObjectURL$LWS(blobObject$LWS) {
      // Create a URL object first using the native APIs.
      // This will ensure native validation against undefined and other
      // non-accepted types.
      let outURL$LWS = shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [blobObject$LWS]);
      if (
      // MediaSource may not be defined in some browsers.
      // https://caniuse.com/mdn-api_mediasource
      MediaSource$LWS &&
      // MediaSource does not share the same prototype as Blob or File.
      // It can still be used with `createObjectURL()` however we need
      // to treat it separately. MediaSource does not accept plain text
      // input as Blob or File and does not have a MIME type.
      blobObject$LWS instanceof MediaSource$LWS) {
        return outURL$LWS;
      }
      const blobType$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoTypeGetter, blobObject$LWS, []);
      if (blobType$LWS === '') {
        // Browsers interpret the empty MIME type differently.
        // Chrome makes it text/plain.
        // Firefox attempts to guess the content.
        // Safari makes it application/octet-stream effectively forcing a download of the content.
        // We need to normalize the behavior here.
        const plainTextBlob$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoSlice, blobObject$LWS, [0, undefined, 'text/plain']);
        return shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
      }
      const loweredBlobType$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, blobType$LWS, []);
      if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
        const blobSize$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoSizeGetter, blobObject$LWS, []);
        const normalizedBlob$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoSlice, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
        sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
        outURL$LWS = shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
        const xhr$LWS = new sharedDom$LWS.XhrCtor();
        shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoOpen, xhr$LWS, ['GET', outURL$LWS, false]);
        try {
          shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoSend, xhr$LWS, []);
        } catch (_unused3$LWS) {
          throw new shared$LWS.LockerSecurityError(`Unable to verify ${shared$LWS.toSafeTemplateStringValue(blobObject$LWS)} is secure.`);
        }
        const responseText$LWS = shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoResponseTextGetter, xhr$LWS, []);
        const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);
        if (!isEqualDomString$LWS(trustedTypes$LWS.trusted.createHTML(responseText$LWS), trustedTypes$LWS.trusted.createHTML(sanitized$LWS))) {
          sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot 'createObjectURL' using an unsecure ${shared$LWS.toSafeTemplateStringValue(blobObject$LWS)}.`);
        }
        return outURL$LWS;
      }
      if (sharedUrl$LWS.isMIMETypeAllowed(loweredBlobType$LWS)) {
        return outURL$LWS;
      }
      sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
      throw new shared$LWS.LockerSecurityError('Unsupported MIME type.');
    }];
  };
}
function initDistortionWindowFetch$LWS({
  globalObject: {
    fetch: originalFetch$LWS
  }
}) {
  const distortionEntry$LWS = [originalFetch$LWS, function fetch$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;
    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;
      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.ReflectApply(sharedDom$LWS.RequestProtoURLGetter, url$LWS, []));
      } else {
        parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }
      if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
        const {
          normalizedURL: normalizedURL$LWS
        } = parsedURL$LWS;
        return shared$LWS.PromiseReject(new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${shared$LWS.toSafeTemplateStringValue(normalizedURL$LWS)}`));
      }
    }
    return shared$LWS.ReflectApply(originalFetch$LWS, this, args$LWS);
  }];
  return function distortionWindowFetch$LWS() {
    return distortionEntry$LWS;
  };
}

// The rules for this proxy are as follows:
//
// If the key is a string...
//      ...And the key is a valid index that matches an existing
//      index in the frame list or matches the value of a name
//      property of a frame in the frame list, then return the
//      appropriate frame from the frame list.
//
//      ...Or the key's value is "length", then return the number of
//      frames in the in the frame list.
//  Else,
//      ...Return the value of the key from the shadow target
class BaseFrameHandler$LWS {
  defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
    return true;
  }
  deleteProperty(_target$LWS, _key$LWS) {
    return true;
  }
  getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
    return undefined;
  }
  isExtensible(_target$LWS) {
    return true;
  }
  ownKeys(_target$LWS) {
    return [];
  }
  preventExtensions(_target$LWS) {
    return true;
  }
  set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
    return true;
  }
  setPrototypeOf(_target$LWS) {
    return false;
  }
}
shared$LWS.ReflectSetPrototypeOf(BaseFrameHandler$LWS.prototype, null);
class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}
function initDistortionWindowFramesGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalWindowFramesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'frames');
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const createFramesProxy$LWS = () => {
    const WindowPrototype$LWS = shared$LWS.ReflectGetPrototypeOf(globalObject$LWS);
    const WindowProperties$LWS = shared$LWS.ReflectGetPrototypeOf(WindowPrototype$LWS);
    // Wrap `WindowLengthGetter` in bound function to obscure the getter
    // source as "[native code]".
    const framesLengthGetter$LWS = shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, sharedDom$LWS.WindowLengthGetter, [globalObject$LWS]);
    // Wrap `noop` in bound function to obscure the setter source as
    // "[native code]".
    const framesLengthSetter$LWS = shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, shared$LWS.noop, []);
    const getFrameByIndexKey$LWS = key$LWS => {
      const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;
      if (possibleIndex$LWS > -1 && shared$LWS.NumberIsInteger(possibleIndex$LWS) && possibleIndex$LWS < shared$LWS.ReflectApply(sharedDom$LWS.WindowLengthGetter, globalObject$LWS, [])) {
        const value$LWS = shared$LWS.ObjectLookupOwnValue(globalObject$LWS, key$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (sharedDom$LWS.isWindow(value$LWS)) {
          return value$LWS;
        }
      }
      return undefined;
    };
    const getFrameByNameKey$LWS = key$LWS => {
      if (typeof key$LWS === 'string' &&
      // Don't shadow properties on the global object...
      !shared$LWS.ObjectHasOwn(globalObject$LWS, key$LWS) &&
      // ...Or its prototype.
      !shared$LWS.ObjectHasOwn(WindowPrototype$LWS, key$LWS)) {
        const value$LWS = shared$LWS.ObjectLookupOwnValue(WindowProperties$LWS, key$LWS);
        if (sharedDom$LWS.isWindow(value$LWS)) {
          return value$LWS;
        }
      }
      return undefined;
    };
    const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? shared$LWS.ReflectApply(sharedDom$LWS.WindowLengthGetter, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);
    class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getValueByKey$LWS(key$LWS);
        return value$LWS === undefined ?
        // window.frames.foo when iframe.name is 'foo'
        shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS) :
        // window.frames.length
        // window.frames[n]
        // window.frames['n']
        value$LWS;
      }
      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        if (key$LWS === 'length') {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            get: framesLengthGetter$LWS,
            set: framesLengthSetter$LWS
          };
        }
        const value$LWS = getFrameByIndexKey$LWS(key$LWS);
        if (value$LWS) {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }
        return undefined;
      }
      // istanbul ignore next: suspicious gap, currently unreachable via tests
      has(target$LWS, key$LWS) {
        return shared$LWS.ReflectHas(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
      }
      ownKeys() {
        const {
          length: length$LWS
        } = globalObject$LWS;
        const keys$LWS = shared$LWS.ArrayCtor(length$LWS + 1);
        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          keys$LWS[i$LWS] = `${i$LWS}`;
        }
        keys$LWS[length$LWS] = 'length';
        return keys$LWS;
      }
    }
    class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);
        return value$LWS === undefined ?
        // window.frames.foo when iframe.name is 'foo'
        shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS) : /* istanbul ignore next: needs default platform behavior test */value$LWS;
      }
      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);
        if (value$LWS === undefined) {
          return value$LWS;
        }
        return {
          __proto__: null,
          configurable: true,
          enumerable: true,
          value: value$LWS,
          writable: false
        };
      }
      // istanbul ignore next: suspicious gap, currently unreachable via tests
      has(target$LWS, key$LWS) {
        return shared$LWS.ReflectHas(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
      }
      ownKeys() {
        const keys$LWS = [];
        let keysOffset$LWS = 0;
        const unsafeDescs$LWS = shared$LWS.ObjectGetOwnPropertyDescriptors(WindowProperties$LWS);
        shared$LWS.ReflectSetPrototypeOf(unsafeDescs$LWS, null);
        for (const key$LWS in unsafeDescs$LWS) {
          // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
          if (typeof key$LWS === 'string') {
            const unsafeDesc$LWS = unsafeDescs$LWS[key$LWS];
            if (shared$LWS.ObjectHasOwn(unsafeDesc$LWS, 'value') && sharedDom$LWS.isWindow(unsafeDesc$LWS.value)) {
              keys$LWS[keysOffset$LWS++] = key$LWS;
            }
          }
        }
        return keys$LWS;
      }
    }
    // In order to preserve window.frames === window.frames, create a
    // shadow target object, to be used with the proxy object that is
    // returned by accesses to window.frames.
    const shadowFrames$LWS = {};
    const shadowFramesPrototype$LWS = {};
    const shadowWindowProperties$LWS = {};
    const shadowFramesHandler$LWS = new ShadowFrameHandler$LWS();
    const shadowFramesPrototypeHandler$LWS = new ShadowFramesPrototypeHandler$LWS();
    const shadowWindowPropertiesHandler$LWS = new ShadowWindowPropertiesHandler$LWS();
    const framesPrototypeProxy$LWS = new shared$LWS.ProxyCtor(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
    const windowPropertiesProxy$LWS = new shared$LWS.ProxyCtor(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
    shared$LWS.ReflectSetPrototypeOf(shadowFrames$LWS, framesPrototypeProxy$LWS);
    shared$LWS.ReflectSetPrototypeOf(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
    return new shared$LWS.ProxyCtor(shadowFrames$LWS, shadowFramesHandler$LWS);
  };
  let framesProxy$LWS;
  const distortionEntry$LWS = [originalWindowFramesGetter$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function frames$LWS() {
    if (framesProxy$LWS === undefined) {
      framesProxy$LWS = createFramesProxy$LWS();
    }
    return framesProxy$LWS;
  }];
  return function distortionWindowFramesGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowGetComputedStyle$LWS({
  globalObject: {
    getComputedStyle: originalGetComputedStyle$LWS
  }
}) {
  const distortionEntry$LWS = [originalGetComputedStyle$LWS, function getComputedStyle$LWS(...args$LWS) {
    return shared$LWS.trackAsLiveTarget(shared$LWS.ReflectApply(originalGetComputedStyle$LWS, this, args$LWS));
  }];
  return function distortionWindowGetComputedStyle$LWS() {
    return distortionEntry$LWS;
  };
}
function length$LWS() {
  return 0;
}
function initDistortionWindowLengthGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'length');
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalLengthGetter$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalLengthGetter$LWS, length$LWS];
  return function distortionWindowLengthGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowOnrejectionhandled$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'rejectionhandled');
}
function initDistortionWindowOnsecuritypolicyviolation$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'securitypolicyviolation');
}
function initDistortionWindowOnstorage$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'storage');
}
function initDistortionWindowOnunhandledrejection$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'unhandledrejection');
}
function initDistortionWindowOpen$LWS({
  globalObject: {
    open: originalWindowOpen$LWS
  }
}) {
  const distortionEntry$LWS = [originalWindowOpen$LWS, function open$LWS(...args$LWS) {
    const normalizedArgs$LWS = sharedDom$LWS.normalizeWindowOpenArguments(args$LWS);
    const childWindow$LWS = shared$LWS.ReflectApply(originalWindowOpen$LWS, this, normalizedArgs$LWS);
    if (childWindow$LWS && normalizedArgs$LWS.length) {
      sharedDom$LWS.initWindowOpenChildWindow(childWindow$LWS, normalizedArgs$LWS[0]);
    }
    return childWindow$LWS;
  }];
  return function distortionWindowOpen$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowPostMessage$LWS({
  globalObject: {
    postMessage: originalPostMessage$LWS
  }
}) {
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalPostMessage$LWS, this, args$LWS);
    } catch (error) {
      // We don't check if `error instance of DOMException` because
      // accessing `DOMException` of the `globalObject` will throw
      // an error for opaque windows.
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS) {
        const message$LWS = args$LWS[0];
        if (shared$LWS.isObject(message$LWS)) {
          // Calling `window.postMessage(message, target, transfer)`
          // is equivalent to `window.postMessage(message, { targetOrigin, transfer })`.
          const providedOptions$LWS = length$LWS > 1 ? args$LWS[1] : undefined;
          if (shared$LWS.isObjectLike(providedOptions$LWS)) {
            const {
              transfer: transfer$LWS
            } = providedOptions$LWS;
            args$LWS[1] = {
              // The postMessage function accepts inherited
              // options property values.
              __proto__: providedOptions$LWS,
              // Shadow any inherited value.
              transfer: transfer$LWS
            };
            // Structured clone all arguments so that `transfer`
            // is referenced correctly within `message`.
            args$LWS = shared$LWS.partialStructuredClone(args$LWS);
          } else {
            args$LWS[0] = shared$LWS.partialStructuredClone(message$LWS);
          }
          return shared$LWS.ReflectApply(originalPostMessage$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionWindowPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowSetInterval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setInterval: originalSetInterval$LWS
  }
}) {
  return function distortionWndowSetInterval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalSetInterval$LWS, function setInterval$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;
        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = shared$LWS.toString(callback$LWS);
          // Defer transforming source text asynchronously.
          let transformedSourceText$LWS;
          // Replace callback parameter.
          args$LWS[0] = () => {
            // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
            if (transformedSourceText$LWS === undefined) {
              transformedSourceText$LWS = sharedDom$LWS.transformSourceText(sourceText$LWS);
            }
            sandboxEvaluator$LWS(transformedSourceText$LWS, UNCOMPILED_CONTEXT$LWS);
          };
        }
      }
      return shared$LWS.ReflectApply(originalSetInterval$LWS, this, args$LWS);
    }];
  };
}
function initDistortionWindowSetTimeout$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setTimeout: originalSetTimeout$LWS
  }
}) {
  return function distortionWindowSetTimeout$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalSetTimeout$LWS, function setTimeout$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;
        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = shared$LWS.toString(callback$LWS);
          // Replace callback parameter.
          args$LWS[0] = () => {
            // Defer transforming source text asynchronously.
            sandboxEvaluator$LWS(sharedDom$LWS.transformSourceText(sourceText$LWS), UNCOMPILED_CONTEXT$LWS);
          };
        }
      }
      return shared$LWS.ReflectApply(originalSetTimeout$LWS, this, args$LWS);
    }];
  };
}
function initDistortionWindowStructuredClone$LWS({
  // @ts-ignore: Prevent property existence error.
  globalObject: {
    DOMException: DOMException$LWS,
    structuredClone: originalStructuredClone$LWS
  }
}) {
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalStructuredClone$LWS !== 'function') {
    return shared$LWS.noop;
  }
  const distortionEntry$LWS = [originalStructuredClone$LWS, function structuredClone$LWS(...args$LWS) {
    try {
      return shared$LWS.ReflectApply(originalStructuredClone$LWS, this, args$LWS);
    } catch (error) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS && error instanceof DOMException$LWS) {
        const message$LWS = args$LWS[0];
        if (shared$LWS.isObject(message$LWS)) {
          const providedOptions$LWS = length$LWS > 1 ? args$LWS[1] : undefined;
          if (shared$LWS.isObjectLike(providedOptions$LWS)) {
            const {
              transfer: transfer$LWS
            } = providedOptions$LWS;
            args$LWS[1] = {
              // The structuredClone function accepts inherited
              // options property values.
              __proto__: providedOptions$LWS,
              // Shadow any inherited value.
              transfer: transfer$LWS
            };
            // Structured clone all arguments so that `options.transfer`
            // is referenced correctly within `value`.
            args$LWS = shared$LWS.partialStructuredClone(args$LWS);
          } else {
            args$LWS[0] = shared$LWS.partialStructuredClone(message$LWS);
          }
          return shared$LWS.ReflectApply(originalStructuredClone$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionWindowStructuredClone$LWS() {
    return distortionEntry$LWS;
  };
}
function Worker$LWS(scriptURL$LWS) {
  throw new shared$LWS.LockerSecurityError(`Cannot create Worker with ${shared$LWS.toSafeTemplateStringValue(scriptURL$LWS)}.`);
}
function initDistortionWorkerCtor$LWS({
  globalObject: {
    Worker: originalWorkerCtor$LWS
  }
}) {
  const distortionEntry$LWS = [originalWorkerCtor$LWS, Worker$LWS];
  return function distortionWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWorkerProto$LWS({
  globalObject: {
    Worker: {
      prototype: originalPrototype$LWS
    }
  }
}) {
  const distortionEntry$LWS = [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
  return function distortionWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionXMLHttpRequestOpen$LWS({
  globalObject: {
    XMLHttpRequest: {
      prototype: {
        open: originalOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalOpen$LWS, function open$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;
    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));
      if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }
      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }
    shared$LWS.ReflectApply(originalOpen$LWS, this, args$LWS);
  }];
  return function distortionXMLHttpRequestOpen$LWS() {
    return distortionEntry$LWS;
  };
}
function replaceDocumentContent$LWS(doc$LWS, content$LWS) {
  const docImpl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoImplementationGetter, doc$LWS, []);
  const newDoc$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DOMImplementationProtoCreateDocument, docImpl$LWS, [sharedDom$LWS.NAMESPACE_XHTML, 'html']);
  const newDocEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDocumentElementGetter, newDoc$LWS, []);
  shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoInnerHTMLSetter, newDocEl$LWS, [content$LWS]);
  return newDoc$LWS;
}
function initDistortionXMLHttpRequestResponseGetter$LWS({
  document: document$LWS,
  globalObject: {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XMLHttpRequest$LWS.prototype, 'response');
  return function distortionXMLHttpRequestResponseGetter$LWS({
    key: key$LWS
  }) {
    return [originalResponseGetter$LWS, function response$LWS() {
      const rawResponse$LWS = shared$LWS.ReflectApply(originalResponseGetter$LWS, this, []);
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      if (rawResponse$LWS instanceof Document$LWS) {
        const docEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDocumentElementGetter, rawResponse$LWS, []);
        const content$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoOuterHTMLGetter, docEl$LWS, []);
        return replaceDocumentContent$LWS(rawResponse$LWS, internalPolicy$LWS.lwsInternalPolicy.createHTML(content$LWS, key$LWS, internalPolicy$LWS.ContentType.HTML));
      }
      return rawResponse$LWS;
    }];
  };
}
function initDistortionXMLHttpRequestResponseXMLGetter$LWS({
  document: document$LWS,
  globalObject: {
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseXMLGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XMLHttpRequest$LWS.prototype, 'responseXML');
  return function distortionXMLHttpRequestResponseXMLGetter$LWS({
    key: key$LWS
  }) {
    return [originalResponseXMLGetter$LWS, function responseXML$LWS() {
      const rawResponseXML$LWS = shared$LWS.ReflectApply(originalResponseXMLGetter$LWS, this, []);
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      const docEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDocumentElementGetter, rawResponseXML$LWS, []);
      const content$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoOuterHTMLGetter, docEl$LWS, []);
      return replaceDocumentContent$LWS(rawResponseXML$LWS, internalPolicy$LWS.lwsInternalPolicy.createHTML(content$LWS, key$LWS, internalPolicy$LWS.ContentType.HTML));
    }];
  };
}

/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/
const internalDistortionFactoryInitializers$LWS = [
// CSSStyleRule
initDistortionCSSStyleRuleStyleGetter$LWS,
// Document
initDistortionDocumentDomainSetter$LWS, initDistortionDocumentOnsecuritypolicyviolation$LWS, initDistortionDocumentOpen$LWS,
// Element
initDistortionElementAttachShadow$LWS, initDistortionElementAttributesGetter$LWS, initDistortionElementGetInnerHTML$LWS, initDistortionElementRemove$LWS, initDistortionElementReplaceChildren$LWS, initDistortionElementReplaceWith$LWS,
// Function
initDistortionFunction$LWS,
// History
initDistortionHistoryPushState$LWS, initDistortionHistoryReplaceState$LWS,
// HTMLElement
initDistortionHTMLElementDatasetGetter$LWS, initDistortionHTMLElementInnerTextSetter$LWS, initDistortionHTMLElementOuterTextSetter$LWS, initDistortionHTMLElementStyleGetter$LWS,
// HTMLIFrameElement
initDistortionIFrameElementContentDocumentGetter$LWS, initDistortionIFrameElementContentWindowGetter$LWS, initDistortionHTMLIFrameElementSrcSetter$LWS,
// HTMLLinkElement
initDistortionHTMLLinkElementRelSetter$LWS, initDistortionHTMLLinkElementRelListSetter$LWS,
// HTMLObjectElement
initDistortionHTMLObjectElementDataSetter$LWS,
// HTMLScriptElement
initDistortionHTMLScriptElementSrcGetter$LWS, initDistortionHTMLScriptElementTextSetter$LWS,
// IDBObjectStore
initDistortionIDBObjectStoreAdd$LWS, initDistortionIDBObjectStorePut$LWS,
// MessagePort
initDistortionMessagePortPostMessage$LWS,
// Navigator
initDistortionNavigatorSendBeacon$LWS, initDistortionNavigatorServiceWorkerGetter$LWS,
// Node
initDistortionNodeRemoveChild$LWS, initDistortionNodeReplaceChild$LWS,
// Notification
initDistortionNotificationCtor$LWS,
// Range
initDistortionRangeDeleteContents$LWS, initDistortionRangeExtractContents$LWS, initDistortionRangeInsertNode$LWS, initDistortionRangeSelectNode$LWS, initDistortionRangeSelectNodeContents$LWS, initDistortionRangeSetEnd$LWS, initDistortionRangeSetEndAfter$LWS, initDistortionRangeSetEndBefore$LWS, initDistortionRangeSetStart$LWS, initDistortionRangeSetStartAfter$LWS, initDistortionRangeSetStartBefore$LWS, initDistortionRangeSurroundContents$LWS,
// ServiceWorkerContainer
initDistortionServiceWorkerContainerProto$LWS,
// ShadowRoot
initDistortionShadowRootModeGetter$LWS,
// SharedWorker
initDistortionSharedWorkerCtor$LWS, initDistortionSharedWorkerProto$LWS,
// Storage
initDistortionStorage$LWS, initDistortionStorageClear$LWS, initDistortionStorageGetItem$LWS, initDistortionStorageKey$LWS, initDistortionStorageLength$LWS, initDistortionStorageRemoveItem$LWS, initDistortionStorageSetItem$LWS,
// SVGAnimateElement
initDistortionSVGAnimateElementFromAttribute$LWS, initDistortionSVGAnimateElementToAttribute$LWS, initDistortionSVGAnimateElementValuesAttribute$LWS,
// SVGElement
initDistortionSVGElementDatasetGetter$LWS, initDistortionSVGElementStyleGetter$LWS,
// SVGSetElement
initDistortionSVGSetElementToAttribute$LWS,
// SVGUseElement
initDistortionSVGUseElementHrefAttribute$LWS, initDistortionSVGUseElementXlinkHrefAttribute$LWS,
// TrustedTypePolicyFactory
initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS,
// Window
initDistortionWindowFetch$LWS, initDistortionWindowFramesGetter$LWS, initDistortionWindowGetComputedStyle$LWS, initDistortionWindowLengthGetter$LWS, initDistortionWindowOpen$LWS, initDistortionWindowPostMessage$LWS, initDistortionWindowStructuredClone$LWS,
// Worker
initDistortionWorkerCtor$LWS, initDistortionWorkerProto$LWS,
// XHR
initDistortionXMLHttpRequestOpen$LWS];
const internalKeyedDistortionFactoryInitializers$LWS = [
// Attr
initDistortionAttrValueSetter$LWS,
// Aura
initDistortionAuraUtilGlobalEval$LWS,
// CacheStorage
initDistortionCacheStorageDelete$LWS, initDistortionCacheStorageHas$LWS, initDistortionCacheStorageKeys$LWS, initDistortionCacheStorageMatch$LWS, initDistortionCacheStorageOpen$LWS,
// CookieStore
initDistortionCookieStoreDelete$LWS, initDistortionCookieStoreGet$LWS, initDistortionCookieStoreGetAll$LWS, initDistortionCookieStoreOnChange$LWS, initDistortionCookieStoreSet$LWS,
// CustomElementRegistry
initDistortionCustomElementRegistryDefine$LWS, initDistortionCustomElementRegistryGet$LWS, initDistortionCustomElementRegistryWhenDefined$LWS,
// Document
initDistortionDocumentCookieGetter$LWS, initDistortionDocumentCookieSetter$LWS, initDistortionDocumentCreateElement$LWS, initDistortionDocumentCreateElementNS$LWS, initDistortionDocumentExecCommand$LWS, initDistortionDocumentReplaceChildren$LWS,
// DOMParser
initDistortionDOMParserParseFromString$LWS,
// Element
initDistortionElementInnerHTMLSetter$LWS, initDistortionElementInsertAdjacentHTML$LWS, initDistortionElementOuterHTMLSetter$LWS, initDistortionElementSetAttribute$LWS, initDistortionElementSetAttributeNode$LWS, initDistortionElementSetAttributeNodeNS$LWS, initDistortionElementSetAttributeNS$LWS, initDistortionElementSetHTML$LWS, initDistortionElementToggleAttribute$LWS,
// Eval
initDistortionEval$LWS,
// Event
initDistortionEventComposedPath$LWS, initDistortionEventPathGetter$LWS,
// EventTarget
initDistortionEventTargetAddEventListener$LWS,
// HTMLBodyElement
initDistortionHTMLBodyElementOnrejectionhandled$LWS, initDistortionHTMLBodyElementOnstorage$LWS, initDistortionHTMLBodyElementOnunhandledrejection$LWS,
// HTMLElement
initDistortionHTMLElementCtor$LWS,
// HTMLFrameSetElement
initDistortionHTMLFrameSetElementOnrejectionhandled$LWS, initDistortionHTMLFrameSetElementOnstorage$LWS, initDistortionHTMLFrameSetElementOnunhandledrejection$LWS,
// HTMLScriptElement,
initDistortionHTMLScriptElementSrcSetter$LWS, initDistortionHTMLScriptElementTextSetter$LWS,
// NamedNodeMap
initDistortionNamedNodeMapSetNamedItem$LWS, initDistortionNamedNodeMapSetNamedItemNS$LWS,
// Node
initDistortionNodeValueSetter$LWS, initDistortionNodeTextContentGetter$LWS, initDistortionNodeTextContentSetter$LWS,
// Range
initDistortionRangeCreateContextualFragment$LWS,
// ShadowRoot
initDistortionShadowRootInnerHTMLSetter$LWS,
// Storage
initDistortionLocalStorage$LWS, initDistortionSessionStorage$LWS,
// SVGAnimationElement
initDistortionSVGAnimateElementAttributeNameAttribute$LWS,
// SVGScriptElement
initDistortionSVGScriptElementHrefGetter$LWS, initDistortionSVGScriptElementHrefSetter$LWS,
// SVGSetElement
initDistortionSVGSetElementAttributeNameAttribute$LWS,
// URL
initDistortionURLCreateObjectURL$LWS,
// Window
initDistortionWindowOnrejectionhandled$LWS, initDistortionWindowOnsecuritypolicyviolation$LWS, initDistortionWindowOnstorage$LWS, initDistortionWindowOnunhandledrejection$LWS, initDistortionWindowSetInterval$LWS, initDistortionWindowSetTimeout$LWS,
// XHR
initDistortionXMLHttpRequestResponseGetter$LWS, initDistortionXMLHttpRequestResponseXMLGetter$LWS];
const externalDistortionFactoryInitializers$LWS = shared$LWS.ArrayConcat(internalDistortionFactoryInitializers$LWS, [
// Element
initDistortionElementAfter$LWS, initDistortionElementAppend$LWS, initDistortionElementBefore$LWS, initDistortionElementInsertAdjacentElement$LWS, initDistortionElementPrepend$LWS, initDistortionElementShadowRootGetter$LWS,
// Node
// The initDistortionNodeAppendChild distortion is temporarily disabled
// until W-10409618 is resolved..
// initDistortionNodeAppendChild,
initDistortionNodeInsertBefore$LWS]);
const externalKeyedDistortionFactoryInitializers$LWS = internalKeyedDistortionFactoryInitializers$LWS;
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'getSelection', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const EventBlockedProperties$LWS = ['originalTarget', 'explicitOriginalTarget'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument'];

// https://www.w3schools.com/tags/tag_iframe.asp
const HTMLIFrameElementBlockedAttributes$LWS = ['allowpaymentrequest', 'referrerpolicy', 'srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const UIEventBlockedProperties$LWS = ['rangeParent'];
const WindowBlockedProperties$LWS = ['find', 'getSelection'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];
exports.DocumentBlockedProperties = DocumentBlockedProperties$LWS;
exports.ElementBlockedProperties = ElementBlockedProperties$LWS;
exports.EventBlockedProperties = EventBlockedProperties$LWS;
exports.HTMLElementBlockedAttributes = HTMLElementBlockedAttributes$LWS;
exports.HTMLElementBlockedProperties = HTMLElementBlockedProperties$LWS;
exports.HTMLEmbedElementBlockedProperties = HTMLEmbedElementBlockedProperties$LWS;
exports.HTMLIFrameElementBlockedAttributes = HTMLIFrameElementBlockedAttributes$LWS;
exports.HTMLIFrameElementBlockedProperties = HTMLIFrameElementBlockedProperties$LWS;
exports.HTMLObjectElementBlockedProperties = HTMLObjectElementBlockedProperties$LWS;
exports.HTMLScriptElementBlockedAttributes = HTMLScriptElementBlockedAttributes$LWS;
exports.HTMLScriptElementBlockedProperties = HTMLScriptElementBlockedProperties$LWS;
exports.SVGElementBlockedAttributes = SVGElementBlockedAttributes$LWS;
exports.SVGElementBlockedProperties = SVGElementBlockedProperties$LWS;
exports.UIEventBlockedProperties = UIEventBlockedProperties$LWS;
exports.WindowBlockedProperties = WindowBlockedProperties$LWS;
exports.XSLTProcessorBlockedProperties = XSLTProcessorBlockedProperties$LWS;
exports.addBlockedAttributeDistortionFactoryInitializers = addBlockedAttributeDistortionFactoryInitializers$LWS;
exports.addBlockedPropertyDistortionFactoryInitializers = addBlockedPropertyDistortionFactoryInitializers$LWS;
exports.externalDistortionFactoryInitializers = externalDistortionFactoryInitializers$LWS;
exports.externalKeyedDistortionFactoryInitializers = externalKeyedDistortionFactoryInitializers$LWS;
exports.finalizeAttributeDistortions = finalizeAttributeDistortions$LWS;
exports.initDistortionWindowPostMessage = initDistortionWindowPostMessage$LWS;
exports.internalDistortionFactoryInitializers = internalDistortionFactoryInitializers$LWS;
exports.internalKeyedDistortionFactoryInitializers = internalKeyedDistortionFactoryInitializers$LWS;
exports.patchGlobalObject = patchGlobalObject$LWS;
exports.unpatchGlobalObject = unpatchGlobalObject$LWS;
/*! version: 0.19.12 */
