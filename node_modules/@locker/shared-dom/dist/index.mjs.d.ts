/// <reference types="cacheable-request" />
import { Getter, Setter } from "@locker/shared";
import { SandboxRecord as SandboxRecordBase } from "@locker/shared";
declare const AbortControllerCtor: {
    new (): AbortController;
    prototype: AbortController;
};
declare const AbortControllerProto: AbortController;
declare const AbortControllerProtoAbort: {
    (reason?: any): void;
    (): void;
};
declare const AbortControllerProtoSignalGetter: import("@locker/shared").Getter;
declare const AttrProtoNameGetter: import("@locker/shared").Getter;
declare const AttrProtoNamespaceURIGetter: import("@locker/shared").Getter;
declare const AttrProtoOwnerElementGetter: import("@locker/shared").Getter;
declare const AttrProtoValueGetter: import("@locker/shared").Getter, AttrProtoValueSetter: import("@locker/shared").Setter;
declare function normalizeNamespacedAttributeName(attrName: string): string;
// This is necessary for the non-standard `Event.prototype.path` getter
// distortion, which only exists in Chrome.
declare global {
    interface Element {
        getInnerHTML(options?: any): string;
        setHTML(value: string, options?: any): void;
    }
    interface Event {
        path: EventTarget[];
    }
    interface Window {
        CookieStore?: CookieStore;
    }
}
interface AttributeNameToResolvedURLRegistry {
    [key: string]: string;
}
interface CookieStore extends EventTarget {
    prototype: {
        delete: Function;
        get: Function;
        getAll: Function;
        set: Function;
    };
}
type GlobalObject = Window & typeof globalThis;
type SandboxEvaluator = (sourceText: string, context?: any, globalObject?: GlobalObject, document?: Document) => any;
interface SandboxRecord extends SandboxRecordBase {
    document: Document;
    globalObject: GlobalObject;
    sandboxEvaluator: SandboxEvaluator;
}
type ScriptElement = HTMLScriptElement | SVGScriptElement;
type ScriptEvaluatorPropertyCallback = (context: any, globalObject: GlobalObject, document: Document) => void;
/* eslint-disable no-underscore-dangle */
declare class Validator {
    _document: Document;
    _constructors: any;
    _templates: {
        left: HTMLTemplateElement;
        right: HTMLTemplateElement;
    };
    isAllowedSharedElementChild: (element: Element | HTMLElement | Node | string) => boolean;
    isEqualDomString: (leftString: string, rightString: string) => boolean;
    isSharedElement: (element: Element | HTMLElement | Node) => boolean;
    constructor(document: Document, { HTMLLinkElement, HTMLScriptElement, HTMLStyleElement }: GlobalObject);
}
declare const rootValidator: Validator;
declare function getValidator(document: Document, globalObject: GlobalObject): any;
declare const BlobCtor: {
    new (blobParts?: BlobPart[] | undefined, options?: BlobPropertyBag | undefined): Blob;
    prototype: Blob;
};
declare const BlobProtoSlice: {
    (start?: number | undefined, end?: number | undefined, contentType?: string | undefined): Blob;
    (start?: number | undefined, end?: number | undefined, contentType?: string | undefined): Blob;
};
declare const BlobProtoSizeGetter: import("@locker/shared").Getter;
declare const BlobProtoTypeGetter: import("@locker/shared").Getter;
declare const CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME = "lskey";
// Used by '@locker/near-membrane-dom'.
declare const IS_CHROMIUM_BROWSER: boolean;
// Used by '@locker/near-membrane-dom'.
declare const IS_OLD_CHROMIUM_BROWSER: boolean;
declare const IS_WEBKIT_BROWSER: boolean;
declare const CustomElementRegistryProtoDefine: ((name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions | undefined) => void) | undefined;
declare const CustomElementRegistryProtoGet: ((name: string) => CustomElementConstructor | undefined) | undefined;
declare const CustomElementRegistryProtoWhenDefined: ((name: string) => Promise<CustomElementConstructor>) | undefined;
declare const rootDocument: Document;
// Used by '@locker/near-membrane/dom'.
declare const DocumentProtoClose: () => void, DocumentProtoOpen: {
    (unused1?: string | undefined, unused2?: string | undefined): Document;
    (url: string | URL, name: string, features: string): Window | null;
};
declare const DocumentProtoCreateComment: (data: string) => Comment, DocumentProtoCreateElement: {
    <K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions | undefined): HTMLElementTagNameMap[K];
    <K_1 extends keyof HTMLElementDeprecatedTagNameMap>(tagName: K_1, options?: ElementCreationOptions | undefined): HTMLElementDeprecatedTagNameMap[K_1];
    (tagName: string, options?: ElementCreationOptions | undefined): HTMLElement;
}, DocumentProtoCreateElementNS: {
    (namespaceURI: "http://www.w3.org/1999/xhtml", qualifiedName: string): HTMLElement;
    <K extends keyof SVGElementTagNameMap>(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: K): SVGElementTagNameMap[K];
    (namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: string): SVGElement;
    (namespaceURI: string | null, qualifiedName: string, options?: ElementCreationOptions | undefined): Element;
    (namespace: string | null, qualifiedName: string, options?: string | ElementCreationOptions | undefined): Element;
}, DocumentProtoGetElementById: (elementId: string) => HTMLElement | null;
declare const DocumentProtoBodyGetter: import("@locker/shared").Getter;
declare const DocumentProtoCookieGetter: import("@locker/shared").Getter, DocumentProtoCookieSetter: import("@locker/shared").Setter;
declare const DocumentProtoDefaultViewGetter: import("@locker/shared").Getter;
declare const DocumentProtoDocumentElementGetter: import("@locker/shared").Getter;
declare const DocumentProtoHeadGetter: import("@locker/shared").Getter;
declare const DocumentProtoImplementationGetter: import("@locker/shared").Getter;
declare const DocumentFragmentProtoGetElementById: (elementId: string) => HTMLElement | null;
// Used by '@locker/near-membrane-shared-dom'.
// The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
declare const DOMExceptionCtor: {
    new (message?: string | undefined, name?: string | undefined): DOMException;
    prototype: DOMException;
    readonly ABORT_ERR: number;
    readonly DATA_CLONE_ERR: number;
    readonly DOMSTRING_SIZE_ERR: number;
    readonly HIERARCHY_REQUEST_ERR: number;
    readonly INDEX_SIZE_ERR: number;
    readonly INUSE_ATTRIBUTE_ERR: number;
    readonly INVALID_ACCESS_ERR: number;
    readonly INVALID_CHARACTER_ERR: number;
    readonly INVALID_MODIFICATION_ERR: number;
    readonly INVALID_NODE_TYPE_ERR: number;
    readonly INVALID_STATE_ERR: number;
    readonly NAMESPACE_ERR: number;
    readonly NETWORK_ERR: number;
    readonly NOT_FOUND_ERR: number;
    readonly NOT_SUPPORTED_ERR: number;
    readonly NO_DATA_ALLOWED_ERR: number;
    readonly NO_MODIFICATION_ALLOWED_ERR: number;
    readonly QUOTA_EXCEEDED_ERR: number;
    readonly SECURITY_ERR: number;
    readonly SYNTAX_ERR: number;
    readonly TIMEOUT_ERR: number;
    readonly TYPE_MISMATCH_ERR: number;
    readonly URL_MISMATCH_ERR: number;
    readonly VALIDATION_ERR: number;
    readonly WRONG_DOCUMENT_ERR: number;
};
declare const DATA_CLONE_ERROR_CODE: number;
declare const DOMExceptionProtoCodeGetter: import("@locker/shared").Getter;
declare const DOMImplementationProtoCreateDocument: (namespace: string | null, qualifiedName: string | null, doctype?: DocumentType | null | undefined) => XMLDocument;
declare const DOMTokenListProtoValueGetter: import("@locker/shared").Getter;
declare const ElementAriaAttributesToPropertyName: Record<string, string>;
// Used by '@locker/near-membrane-dom'.
declare const ElementProtoRemove: () => void;
declare const ElementProtoClosest: {
    <K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K] | null;
    <K_1 extends keyof SVGElementTagNameMap>(selector: K_1): SVGElementTagNameMap[K_1] | null;
    <E extends Element = Element>(selectors: string): E | null;
}, ElementProtoGetAttribute: (qualifiedName: string) => string | null, ElementProtoGetAttributeNode: (qualifiedName: string) => Attr | null, ElementProtoGetAttributeNodeNS: (namespace: string | null, localName: string) => Attr | null, ElementProtoHasAttribute: (qualifiedName: string) => boolean, ElementProtoQuerySelector: {
    <K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    <K_1 extends keyof SVGElementTagNameMap>(selectors: K_1): SVGElementTagNameMap[K_1] | null;
    <E extends Element = Element>(selectors: string): E | null;
}, ElementProtoQuerySelectorAll: {
    <K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
    <K_1 extends keyof SVGElementTagNameMap>(selectors: K_1): NodeListOf<SVGElementTagNameMap[K_1]>;
    <E extends Element = Element>(selectors: string): NodeListOf<E>;
}, ElementProtoRemoveAttribute: (qualifiedName: string) => void, ElementProtoRemoveAttributeNode: (attr: Attr) => Attr, ElementProtoRemoveAttributeNS: (namespace: string | null, localName: string) => void, ElementProtoSetAttribute: (qualifiedName: string, value: string) => void, ElementProtoSetAttributeNS: (namespace: string | null, qualifiedName: string, value: string) => void, ElementProtoToggleAttribute: (qualifiedName: string, force?: boolean | undefined) => boolean;
declare const ElementProtoInnerHTMLGetter: import("@locker/shared").Getter, ElementProtoInnerHTMLSetter: import("@locker/shared").Setter;
declare const ElementProtoNamespaceURIGetter: import("@locker/shared").Getter;
declare const ElementProtoOuterHTMLGetter: import("@locker/shared").Getter;
declare const ElementProtoTagNameGetter: import("@locker/shared").Getter;
declare const EventCtor: {
    new (type: string, eventInitDict?: EventInit | undefined): Event;
    prototype: Event;
    readonly AT_TARGET: number;
    readonly BUBBLING_PHASE: number;
    readonly CAPTURING_PHASE: number;
    readonly NONE: number;
};
declare const ErrorEventCtor: {
    new (type: string, eventInitDict?: ErrorEventInit | undefined): ErrorEvent;
    prototype: ErrorEvent;
};
declare const EventProtoStopPropagation: () => void;
declare const EventProtoCurrentTargetGetter: import("@locker/shared").Getter;
declare const EventTargetProtoAddEventListener: (type: string, callback: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions | undefined) => void, EventTargetProtoDispatchEvent: (event: Event) => boolean, EventTargetProtoRemoveEventListener: (type: string, callback: EventListenerOrEventListenerObject | null, options?: boolean | EventListenerOptions | undefined) => void;
declare const HTMLAnchorElementProtoHostnameGetter: import("@locker/shared").Getter;
declare const HTMLAnchorElementProtoHrefGetter: any, HTMLAnchorElementProtoHrefSetter: any;
declare const HTMLAnchorElementProtoPathnameGetter: import("@locker/shared").Getter;
declare const HTMLAnchorElementProtoProtocolGetter: import("@locker/shared").Getter;
declare const HTMLElementProto: HTMLElement;
// Used by '@locker/near-membrane-dom'.
declare const HTMLElementProtoStyleGetter: import("@locker/shared").Getter;
declare const HTMLElementGlobalAttributesToPropertyName: Record<string, string>;
// Used by '@locker/near-membrane-dom'.
declare const HTMLIFrameElementProtoContentWindowGetter: import("@locker/shared").Getter;
declare const HTMLIFrameElementProtoSrcSetter: import("@locker/shared").Setter;
declare const HTMLScriptElementCtor: {
    new (): HTMLScriptElement;
    prototype: HTMLScriptElement;
    supports(type: string): boolean;
};
declare const HTMLScriptElementProto: HTMLScriptElement;
declare const HTMLScriptElementProtoSrcGetter: import("@locker/shared").Getter, HTMLScriptElementProtoSrcSetter: import("@locker/shared").Setter;
declare const HTMLTemplateElementProtoContentGetter: import("@locker/shared").Getter;
declare const NAMESPACE_DEFAULT = "default";
declare const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
declare const NAMESPACE_XHTML = "http://www.w3.org/1999/xhtml";
declare const NAMESPACE_XLINK = "http://www.w3.org/1999/xlink";
declare const NodeProtoAppendChild: <T extends Node>(node: T) => T, NodeProtoCloneNode: (deep?: boolean | undefined) => Node, NodeProtoIsEqualNode: (otherNode: Node | null) => boolean;
declare const NodeProtoChildNodesGetter: import("@locker/shared").Getter;
declare const NodeProtoFirstChildGetter: import("@locker/shared").Getter;
declare const NodeProtoIsConnectedGetter: import("@locker/shared").Getter;
// Used by '@locker/near-membrane-dom'.
declare const NodeProtoLastChildGetter: import("@locker/shared").Getter;
declare const NodeProtoNodeNameGetter: import("@locker/shared").Getter;
declare const NodeProtoOwnerDocumentGetter: import("@locker/shared").Getter;
declare const NodeProtoTextContentGetter: import("@locker/shared").Getter, NodeProtoTextContentSetter: import("@locker/shared").Setter;
declare const RangeProtoCreateContextualFragment: (fragment: string) => DocumentFragment;
declare const RequestProtoURLGetter: import("@locker/shared").Getter;
declare const ResponseCtor: {
    new (body?: BodyInit | null | undefined, init?: ResponseInit | undefined): Response;
    prototype: Response;
    error(): Response;
    redirect(url: string | URL, status?: number | undefined): Response;
};
declare const ResponseProtoOkGetter: import("@locker/shared").Getter;
declare const ResponseProtoStatus: import("@locker/shared").Getter;
declare const ResponseProtoStatusText: import("@locker/shared").Getter;
declare const ResponseProtoText: () => Promise<string>;
declare const SCRIPT_HOOK_SOURCE_TEXT: string;
declare function defineScriptAccessorProperty(script: ScriptElement, propKey: PropertyKey, getter: Getter, setter: Setter): void;
declare function defineScriptEvaluatorProperty(script: ScriptElement, callback: ScriptEvaluatorPropertyCallback): void;
declare function deleteOriginalScriptProperty(script: ScriptElement): void;
declare function deleteResolvedScriptURL(script: ScriptElement): void;
declare function deleteScriptEvaluatorProperty(script: ScriptElement): void;
declare function getOriginalScriptProperty(script: ScriptElement): string | undefined;
declare function getResolvedScriptURL(script: ScriptElement, attributeName: string): string | undefined;
declare function getScriptSrcEvaluatorHookURL(): string;
declare function isScriptEvaluated(script: ScriptElement): boolean;
declare function isScriptPropertyEvaluatorHookDefined(script: ScriptElement): boolean;
declare function isScriptURLEvaluatorHookDefined(script: ScriptElement): boolean;
declare function setOriginalScriptScriptProperty(script: ScriptElement, scriptProperty: string): WeakMap<ScriptElement, string>;
declare function setResolvedScriptURL(script: ScriptElement, attributeName: string, resolvedURL: string): void;
declare function trackScriptAsEvaluated(script: ScriptElement): void;
// While fully qualified member expression access can be unambiguously detected,
// ie. window.location or window.top, bare-word references to location and top
// cannot. This means that code containing the fully qualified member expressions
// can have all occurrences replaced by transforms and given special names controlled
// by LWS in Aura. This process will also result in the program knowing that it
// applied a given transform, which it can then use to populate a context names
// list to be used in the declaration assignment code injected into wrapped Aura
// component code. Because the unqualified member expressions cannot be unambiguously
// detected, there is no way for the program to know that, eg. location.search was
// used in the Aura component code and subsequently transformed, which means it
// cannot be relied upon to when populating a context names list to be used in
// the declaration assignment code. As a result, location and top must be universally
// and explicitly included in the context object, and universally and explicitly
// included in the context names list.
declare const UNIVERSAL_CONTEXT_NAMES: string[];
declare function compileSourceText(sourceText: string): string;
declare function generateContextAssignmentCodeFromContextNames(names: string[]): string;
declare function transformSourceText(sourceText: string): string;
declare const StorageProtoKey: (index: number) => string | null, StorageProtoGetItem: (key: string) => string | null, StorageProtoRemoveItem: (key: string) => void, StorageProtoSetItem: (key: string, value: string) => void;
declare const SVGScriptElementProtoHrefGetter: import("@locker/shared").Getter, SVGScriptElementProtoHrefSetter: import("@locker/shared").Setter;
declare const URLCreateObjectURL: (obj: Blob | MediaSource) => string, URLRevokeObjectURL: (url: string) => void;
declare const rootWindow: Window & typeof globalThis;
declare const WindowClearInterval: ((id: number | undefined) => void) & typeof clearInterval, WindowDecodeURIComponent: typeof decodeURIComponent, WindowEncodeURIComponent: typeof encodeURIComponent, WindowFetch: ((input: URL | RequestInfo, init?: RequestInit | undefined) => Promise<Response>) & typeof fetch, rootWindowLocation: Location, WindowSetInterval: ((handler: TimerHandler, timeout?: number | undefined, ...arguments: any[]) => number) & typeof setInterval, rootWindowTop: Window | null;
declare const WindowQueueMicrotask: ((callback: VoidFunction) => void) & typeof queueMicrotask;
declare const WindowDocumentGetter: import("@locker/shared").Getter;
declare const WindowFrameElementGetter: import("@locker/shared").Getter;
declare const WindowLengthGetter: import("@locker/shared").Getter;
declare const WindowLocationGetter: import("@locker/shared").Getter;
declare function initWindowOpenChildWindow<T extends GlobalObject>(win: T, url: string | undefined): T;
declare function isWindow(value: any): boolean;
declare function normalizeWindowOpenArguments(args: Parameters<typeof window.open>): [
    url?: string | undefined,
    target?: string | undefined,
    features?: string | undefined
];
// This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.mjs.js containing the directive and subsequently being
// ignored.
// istanbul ignore next
declare const XhrCtor: {
    new (): XMLHttpRequest;
    prototype: XMLHttpRequest;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
};
declare const XhrProtoAbort: () => void, XhrProtoOpen: {
    (method: string, url: string | URL): void;
    (method: string, url: string | URL, async: boolean, username?: string | null | undefined, password?: string | null | undefined): void;
}, XhrProtoSend: (body?: Document | XMLHttpRequestBodyInit | null | undefined) => void;
declare const XhrProtoResponseTextGetter: import("@locker/shared").Getter;
declare const XhrProtoStatusGetter: import("@locker/shared").Getter;
declare const XhrProtoWithCredentialsSetter: import("@locker/shared").Setter;
export { AbortControllerCtor, AbortControllerProto, AbortControllerProtoAbort, AbortControllerProtoSignalGetter, AttrProtoNameGetter, AttrProtoNamespaceURIGetter, AttrProtoOwnerElementGetter, AttrProtoValueGetter, AttrProtoValueSetter, normalizeNamespacedAttributeName, rootValidator, getValidator, BlobCtor, BlobProtoSlice, BlobProtoSizeGetter, BlobProtoTypeGetter, CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME, IS_CHROMIUM_BROWSER, IS_OLD_CHROMIUM_BROWSER, IS_WEBKIT_BROWSER, CustomElementRegistryProtoDefine, CustomElementRegistryProtoGet, CustomElementRegistryProtoWhenDefined, rootDocument, DocumentProtoClose, DocumentProtoOpen, DocumentProtoCreateComment, DocumentProtoCreateElement, DocumentProtoCreateElementNS, DocumentProtoGetElementById, DocumentProtoBodyGetter, DocumentProtoCookieGetter, DocumentProtoCookieSetter, DocumentProtoDefaultViewGetter, DocumentProtoDocumentElementGetter, DocumentProtoHeadGetter, DocumentProtoImplementationGetter, DocumentFragmentProtoGetElementById, DOMExceptionCtor, DATA_CLONE_ERROR_CODE, DOMExceptionProtoCodeGetter, DOMImplementationProtoCreateDocument, DOMTokenListProtoValueGetter, ElementAriaAttributesToPropertyName, ElementProtoRemove, ElementProtoClosest, ElementProtoGetAttribute, ElementProtoGetAttributeNode, ElementProtoGetAttributeNodeNS, ElementProtoHasAttribute, ElementProtoQuerySelector, ElementProtoQuerySelectorAll, ElementProtoRemoveAttribute, ElementProtoRemoveAttributeNode, ElementProtoRemoveAttributeNS, ElementProtoSetAttribute, ElementProtoSetAttributeNS, ElementProtoToggleAttribute, ElementProtoInnerHTMLGetter, ElementProtoInnerHTMLSetter, ElementProtoNamespaceURIGetter, ElementProtoOuterHTMLGetter, ElementProtoTagNameGetter, EventCtor, ErrorEventCtor, EventProtoStopPropagation, EventProtoCurrentTargetGetter, EventTargetProtoAddEventListener, EventTargetProtoDispatchEvent, EventTargetProtoRemoveEventListener, HTMLAnchorElementProtoHostnameGetter, HTMLAnchorElementProtoHrefGetter, HTMLAnchorElementProtoHrefSetter, HTMLAnchorElementProtoPathnameGetter, HTMLAnchorElementProtoProtocolGetter, HTMLElementProto, HTMLElementProtoStyleGetter, HTMLElementGlobalAttributesToPropertyName, HTMLIFrameElementProtoContentWindowGetter, HTMLIFrameElementProtoSrcSetter, HTMLScriptElementCtor, HTMLScriptElementProto, HTMLScriptElementProtoSrcGetter, HTMLScriptElementProtoSrcSetter, HTMLTemplateElementProtoContentGetter, NAMESPACE_DEFAULT, NAMESPACE_SVG, NAMESPACE_XHTML, NAMESPACE_XLINK, NodeProtoAppendChild, NodeProtoCloneNode, NodeProtoIsEqualNode, NodeProtoChildNodesGetter, NodeProtoFirstChildGetter, NodeProtoIsConnectedGetter, NodeProtoLastChildGetter, NodeProtoNodeNameGetter, NodeProtoOwnerDocumentGetter, NodeProtoTextContentGetter, NodeProtoTextContentSetter, RangeProtoCreateContextualFragment, RequestProtoURLGetter, ResponseCtor, ResponseProtoOkGetter, ResponseProtoStatus, ResponseProtoStatusText, ResponseProtoText, SCRIPT_HOOK_SOURCE_TEXT, defineScriptAccessorProperty, defineScriptEvaluatorProperty, deleteOriginalScriptProperty, deleteResolvedScriptURL, deleteScriptEvaluatorProperty, getOriginalScriptProperty, getResolvedScriptURL, getScriptSrcEvaluatorHookURL, isScriptEvaluated, isScriptPropertyEvaluatorHookDefined, isScriptURLEvaluatorHookDefined, setOriginalScriptScriptProperty, setResolvedScriptURL, trackScriptAsEvaluated, UNIVERSAL_CONTEXT_NAMES, compileSourceText, generateContextAssignmentCodeFromContextNames, transformSourceText, StorageProtoKey, StorageProtoGetItem, StorageProtoRemoveItem, StorageProtoSetItem, SVGScriptElementProtoHrefGetter, SVGScriptElementProtoHrefSetter, AttributeNameToResolvedURLRegistry, CookieStore, GlobalObject, SandboxEvaluator, SandboxRecord, ScriptElement, ScriptEvaluatorPropertyCallback, URLCreateObjectURL, URLRevokeObjectURL, rootWindow, WindowClearInterval, WindowDecodeURIComponent, WindowEncodeURIComponent, WindowFetch, rootWindowLocation, WindowSetInterval, rootWindowTop, WindowQueueMicrotask, WindowDocumentGetter, WindowFrameElementGetter, WindowLengthGetter, WindowLocationGetter, initWindowOpenChildWindow, isWindow, normalizeWindowOpenArguments, XhrCtor, XhrProtoAbort, XhrProtoOpen, XhrProtoSend, XhrProtoResponseTextGetter, XhrProtoStatusGetter, XhrProtoWithCredentialsSetter };
