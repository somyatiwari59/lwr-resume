import { Instrumentation } from "@locker/instrumentation";
import { SandboxKey, Getter, ProxyTarget, SandboxType } from "@locker/shared";
import { SandboxRecord as SandboxRecordBase } from "@locker/distortion";
import { GlobalObject } from "@locker/shared-dom";
declare const CORE_SANDBOX_KEY = "lws-core-sandbox";
type DependencyRegistry = Record<OriginalDep, WrappedDep>;
type EvalHelperBaseGenToAsync = (genNextWrapper: GeneratorMethodWrapper, genThrowWrapper: GeneratorMethodWrapper) => Promise<any>;
type EvalHelperForAwaitOf = (index: number, stage: number, object?: object) => any;
type EvalHelperLoadScript = (_thisArg: any, url: string | URL) => Promise<any>;
type EvalHelperLoadStyle = (_thisArg: any, url: string | URL) => Promise<any>;
interface EvalHelpers {
    // @TODO: Remove the 'asyncToGen' and 'makeRedResyncImports' aliases after
    // the LWS compiler update makes its way through the LWC deployment pipeline.
    asyncToGen: (func: GeneratorFunction, thisArg: any) => Promise<any>;
    makeRedResyncImports: (bindings: RedBindings) => () => RedBindings;
    forAwaitOf: (index: number, stage: number, object?: object) => any;
    genToAsync: (func: GeneratorFunction, thisArg: any) => Promise<any>;
    loadScript: (thisArg: any, url: string | URL) => Promise<any>;
    loadStyle: (thisArg: any, url: string | URL) => Promise<any>;
    makeRedGet: (...bindings: RedBindings) => RedBindings;
    makeRedSyncImports: (bindings: RedBindings) => () => RedBindings;
    namespace: <T extends object>(object: T) => Readonly<T>;
    spreadable: <T extends any[]>(array: T) => T;
    super: (target: ProxyTarget, key: PropertyKey, thisArgOrReceiver: any, args?: ArrayLike<any>) => any;
}
type EvalHelpersFactory = (...args: EvalHelpersFactoryArguments) => EvalHelpers;
type EvalHelpersFactoryArguments = [
    EvalHelperBaseGenToAsync,
    EvalHelperForAwaitOf,
    EvalHelperLoadScript,
    EvalHelperLoadStyle
];
interface EvaluateOptions {
    context: any;
    document: Document;
    endowments: object;
    globalObject: GlobalObject;
    instrumentation: Instrumentation;
    key: SandboxKey;
    source: Function | string;
    sourceType: SourceType;
    type: SandboxType;
    verboseInstrumentation: boolean;
}
interface ForOfState {
    iterable: IterableIterator<any>;
    step: IteratorResult<any> | undefined;
    sync: boolean;
}
type GeneratorMethod = (...args: any[]) => IteratorReturnResult<any>;
type GeneratorMethodWrapper = (value: any) => ReturnType<GeneratorMethod>;
// Subject to change but this is an internal structure.
interface LWSTrustedTypesOptions {
    lwsKey: SandboxKey;
    targetElement?: Element;
}
interface OpaqueWindowRecordOptions {
    globalObject: GlobalObject;
    key: SandboxKey;
    type?: SandboxType;
}
type OriginalDep = any;
interface RootWindowRecordOptions {
    context?: any;
    endowments?: object;
    instrumentation?: Instrumentation;
    key: SandboxKey;
    type?: SandboxType;
    verboseInstrumentation?: boolean;
}
type RedBindings = Getter[];
interface SandboxRecord extends SandboxRecordBase {
    helpers: EvalHelpers;
    root: SandboxRecord;
    type: SandboxType;
    virtualEnvironmentEvaluator: VirtualEnvironmentEvaluator;
}
// eslint-disable-next-line no-shadow
declare const enum ResourceLoaderStatus {
    None = 0,
    Errored = 1,
    Loading = 2,
    Loaded = 3
}
type SandboxRegistry = Record<SandboxKey, SandboxRecord>;
type Scope = Record<string, any>;
// eslint-disable-next-line no-shadow
declare const enum SourceType {
    Script = 0,
    Module = 1
}
interface SecondaryWindowRecordOptions {
    context?: any;
    document: Document;
    globalObject: GlobalObject;
    key: SandboxKey;
    type?: SandboxType;
}
type VirtualEnvironmentEvaluator = (sourceText: string) => any;
type WrappedDep = any;
declare function evaluateInCoreSandbox(_key: SandboxKey, source: Function | string, context?: any, endowments?: object, instrumentation?: Instrumentation, verboseInstrumentation?: boolean): any;
declare function evaluateInSandbox(key: SandboxKey, source: Function | string, context?: any, endowments?: object, instrumentation?: Instrumentation, verboseInstrumentation?: boolean): any;
declare function evaluateFunction(key: SandboxKey, fn: Function, scope?: Scope, sourceURL?: string, endowments?: object, instrumentation?: Instrumentation, verboseInstrumentation?: boolean): Function;
declare function wrapDependency(dep: any, depName: string, key: string): any;
declare function createRootWindowSandboxRecord({ context, endowments, instrumentation, key, type, verboseInstrumentation }: RootWindowRecordOptions): SandboxRecord;
export { CORE_SANDBOX_KEY, evaluateInCoreSandbox, evaluateInSandbox, evaluateFunction, DependencyRegistry, EvalHelperBaseGenToAsync, EvalHelperForAwaitOf, EvalHelperLoadScript, EvalHelperLoadStyle, EvalHelpers, EvalHelpersFactory, EvalHelpersFactoryArguments, EvaluateOptions, ForOfState, GeneratorMethod, GeneratorMethodWrapper, LWSTrustedTypesOptions, OpaqueWindowRecordOptions, OriginalDep, RootWindowRecordOptions, RedBindings, SandboxRecord, ResourceLoaderStatus, SandboxRegistry, Scope, SourceType, SecondaryWindowRecordOptions, VirtualEnvironmentEvaluator, WrappedDep, wrapDependency, createRootWindowSandboxRecord };
export { trusted } from '@locker/trusted-types';
