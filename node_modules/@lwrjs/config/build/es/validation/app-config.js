import { parseTree, printParseErrorCode, findNodeAtLocation as findNode, } from 'jsonc-parser';
import { createSingleDiagnosticError, descriptions, LwrConfigValidationError } from '@lwrjs/diagnostics';
import { ASSET_DIR_ATTRIBUTE_KEYS, ASSET_FILE_ATTRIBUTE_KEYS, BOOTSTRAP_ATTRIBUTE_KEYS, ERROR_ROUTE_ATTRIBUTE_KEYS, LOCKER_ATTRIBUTE_KEYS, ROOT_ATTRIBUTE_KEYS, ROUTE_ATTRIBUTE_KEYS, ValidationContext, } from './app-config-context.js';
import { calculatePositionFromSource } from './helpers.js';
import { DEFAULT_ESM_BUNDLE_EXCLUSIONS, DEFAULT_AMD_BUNDLE_EXCLUSIONS } from '../defaults.js';
import { ConfigSpan, getTracer } from '@lwrjs/instrumentation';
export const SOURCE_BY_PHASE = {
    file: 'lwr.config.json',
    pre: 'argument passed to createServer',
    post: 'configuration hooks',
};
/**
 * Check config.routes[x].bootstrap:
 *      - services: optional array of specifiers
 *      - autoBoot: optional boolean
 *      - syntheticShadow: optional boolean
 *      - workers: optional map of string:specifier pairs
 *      - ssr: optional boolean
 *      - configAsSrc: optional boolean to include the client bootstrap config as src via in-lined
 *      - module: optional string specifier
 */
function validateBootstrap(node, validationContext, propPrefix) {
    if (node) {
        validationContext.assertIsObject(node, 'bootstrap');
        validationContext.assertValidKeys(node, 'bootstrap', BOOTSTRAP_ATTRIBUTE_KEYS);
        validationContext.assertArrayOfSpecifiers(findNode(node, ['services']), `${propPrefix}.services`);
        validationContext.assertArrayOfSpecifiers(findNode(node, ['preloadModules']), `${propPrefix}.preloadModules`);
        validationContext.assertIsBoolean(findNode(node, ['autoBoot']), `${propPrefix}.autoBoot`);
        validationContext.assertIsBoolean(findNode(node, ['ssr']), `${propPrefix}.ssr`);
        validationContext.assertIsBoolean(findNode(node, ['configAsSrc']), `${propPrefix}.configAsSrc`);
        validationContext.assertIsSpecifier(findNode(node, ['module']), `${propPrefix}.module`);
        validationContext.assertIsBoolean(findNode(node, ['syntheticShadow']), `${propPrefix}.syntheticShadow`);
        // Each value in the worker map msut be a specifier
        const workers = findNode(node, ['workers']);
        if (workers && workers.children) {
            workers.children.forEach((w, index) => {
                if (w.children && w.children.length > 1) {
                    // get the value in a map entry: { "key": "value" }
                    validationContext.assertIsSpecifier(w.children[1], `${propPrefix}.workers[${index}]`);
                }
            });
        }
    }
}
/**
 * Check common properties of config.routes[] and config.errorRoutes[]:
 *      - id: required string
 *      - each route must have at least 1 of the following:
 *          - rootComponent
 *          - contentTemplate
 *          - routeHandler
 *      - rootComponent: optional specifier
 *      - contentTemplate: optional string
 *      - layoutTemplate: optional string
 *      - routeHandler: optional string
 *      - optional bootstrap...
 */
function validateRouteCommon(node, validationContext, propPrefix) {
    validationContext.assertHasOneOrMore(node, propPrefix, [
        'rootComponent',
        'contentTemplate',
        'routeHandler',
    ]);
    validationContext.assertNotEmptyString(findNode(node, ['id']), `${propPrefix}.id`);
    validationContext.assertIsSpecifier(findNode(node, ['rootComponent']), `${propPrefix}.rootComponent`);
    validationContext.assertNotEmptyString(findNode(node, ['contentTemplate']), `${propPrefix}.contentTemplate`);
    validationContext.assertNotEmptyString(findNode(node, ['layoutTemplate']), `${propPrefix}.layoutTemplate`);
    validationContext.assertIsService(findNode(node, ['routeHandler']), `${propPrefix}.routeHandler`);
    validateBootstrap(findNode(node, ['bootstrap']), validationContext, `${propPrefix}.bootstrap`);
}
/**
 * Check config.routes[]:
 *      - must have length > 0
 *      - path: required path segment string
 *      - method: optional 'get' | 'post'
 */
function validateRoutes(node, validationContext, preMerge) {
    if (node) {
        // routes may not be defined until after config hooks are applied
        // note: there are 2 "post" hooks (onConfig/onStart) that routes can be applied.
        // We need to ensure that we only validate after the last one (if both are used)
        if (!preMerge) {
            validationContext.assertNotEmptyArray(node, 'routes');
        }
        if (node.children) {
            node.children.forEach((n, index) => {
                const propPrefix = `routes[${index}]`;
                validationContext.assertIsObject(n, 'routes');
                validationContext.assertValidKeys(n, 'routes', ROUTE_ATTRIBUTE_KEYS);
                validationContext.assertRequiredKeys(n, propPrefix, ['id', 'path']);
                validationContext.assertIsPath(findNode(n, ['path']), `${propPrefix}.path`);
                validationContext.assertIsMethod(findNode(n, ['method']), `${propPrefix}.method`);
                validateRouteCommon(n, validationContext, propPrefix);
            });
        }
    }
}
function validateBundleConfig(node, validationContext) {
    if (node) {
        validationContext.assertIsObject(node, 'bundleConfig');
        // keep track of dupes
        const dupeMap = new Map();
        const dupes = new Set();
        const excludeNode = findNode(node, ['exclude']);
        validationContext.assertArrayOfSpecifiers(excludeNode, 'bundleConfig.exclude');
        excludeNode?.children?.forEach((n) => {
            dupeMap.set(n.value, true);
        });
        const external = findNode(node, ['external']);
        if (external) {
            external?.children?.forEach((n) => {
                const specifier = (n?.children && n.children[0])?.value;
                if (specifier && dupeMap.has(specifier)) {
                    dupes.add(specifier);
                }
                else {
                    dupeMap.set(specifier, true);
                }
            });
            // TODO: add RHS externals validation once we finish support for externals in <>
        }
        const groups = findNode(node, ['groups']);
        if (groups) {
            validationContext.assertIsObject(groups, 'bundleConfig.groups');
            groups?.children?.forEach((n) => {
                const groupKey = n?.children && n.children[0];
                const group = n?.children && n.children[1];
                if (group && groupKey) {
                    validationContext.assertNotEmptyArray(group, `bundleConfig.groups.${groupKey.value}`);
                    validationContext.assertArrayOfSpecifiers(group, `bundleConfig.groups.${groupKey.value}`);
                    const groupies = group?.children;
                    groupies?.forEach((n) => {
                        if (dupeMap.has(n.value)) {
                            dupes.add(n.value);
                        }
                    });
                }
            });
        }
        // For now, allow dupes w/ default excludes
        // TODO W-13651948: remove this once we get rid of UNSAFE_lwrDefaultExcludes
        const defaultExcludes = new Set([...DEFAULT_AMD_BUNDLE_EXCLUSIONS, ...DEFAULT_ESM_BUNDLE_EXCLUSIONS]);
        const dupesFiltered = Array.from(dupes).filter((specifier) => !defaultExcludes.has(specifier));
        validationContext.assertNoBundleConfigDupes(node, dupesFiltered);
    }
}
/**
 * Check config.errorRoutes[]:
 *      - status: required 404 | 500
 */
function validateErrorRoutes(node, validationContext) {
    if (node) {
        validationContext.assertIsArray(node, 'errorRoutes');
        if (node.children) {
            node.children.forEach((n, index) => {
                const propPrefix = `errorRoutes[${index}]`;
                validationContext.assertIsObject(n, 'errorRoutes');
                validationContext.assertValidKeys(n, 'errorRoutes', ERROR_ROUTE_ATTRIBUTE_KEYS);
                validationContext.assertRequiredKeys(n, propPrefix, ['id', 'status']);
                validationContext.assertIsStatus(findNode(n, ['status']), `${propPrefix}.status`);
                validateRouteCommon(n, validationContext, propPrefix);
            });
        }
    }
}
function validateRouteHandlers(node, validationContext) {
    if (node) {
        validationContext.assertIsObject(node, 'routeHandlers');
    }
}
/**
 * Check string config.asset OR
 * Check array config.assets[]:
 *      - must have length > 0
 *      - must have either dir or file, NOT both
 *      - dir: optional string
 *      - file: optional string
 *      - urlPath: required path segment string
 *      - alias: optional string
 */
function validateAssets(node, validationContext, preMerge) {
    if (node) {
        // assets can only be a string before the config is merged and normalized
        if (preMerge && node.type === 'string') {
            validationContext.assertNotEmptyString(node, 'assets');
        }
        else {
            validationContext.assertNotEmptyArray(node, 'assets');
            if (node.children) {
                node.children.forEach((n, index) => {
                    const rootDirNode = findNode(n, ['root']);
                    const dirNode = findNode(n, ['dir']);
                    const fileNode = findNode(n, ['file']);
                    if (rootDirNode?.type === 'boolean') {
                        validationContext.assertIsObject(n, 'assetDir');
                        validationContext.assertValidKeys(n, 'assetDir', ASSET_DIR_ATTRIBUTE_KEYS);
                    }
                    else if (dirNode?.type === 'string') {
                        validationContext.assertIsObject(n, 'assetDir');
                        validationContext.assertValidKeys(n, 'assetDir', ASSET_DIR_ATTRIBUTE_KEYS);
                        validationContext.assertRequiredKeys(n, `assets[${index}]`, ['urlPath']);
                        validationContext.assertIsPath(findNode(n, ['urlPath']), `assets[${index}].urlPath`);
                    }
                    else if (fileNode?.type === 'string') {
                        validationContext.assertIsObject(n, 'assetFile');
                        validationContext.assertValidKeys(n, 'assetFile', ASSET_FILE_ATTRIBUTE_KEYS);
                        validationContext.assertRequiredKeys(n, `assets[${index}]`, ['urlPath']);
                        validationContext.assertIsPath(findNode(n, ['urlPath']), `assets[${index}].urlPath`);
                    }
                    validationContext.assertHasOnlyOne(n, `assets[${index}]`, ['dir', 'file']);
                    validationContext.assertNotEmptyString(dirNode, `assets[${index}].dir`);
                    validationContext.assertNotEmptyString(fileNode, `assets[${index}].file`);
                    validationContext.assertIsBoolean(rootDirNode, `assets[${index}].root`);
                    validationContext.assertNotEmptyString(findNode(n, ['alias']), `assets[${index}].alias`);
                });
            }
        }
    }
}
/**
 * Check config.locker:
 *      - enabled: required boolean
 *      - trustedComponents: optional array of strings
 */
function validateLocker(node, validationContext) {
    if (node) {
        validationContext.assertIsObject(node, 'locker');
        validationContext.assertValidKeys(node, 'locker', LOCKER_ATTRIBUTE_KEYS);
        validationContext.assertRequiredKeys(node, 'locker', ['enabled']);
        validationContext.assertIsBoolean(findNode(node, ['enabled']), 'locker.enabled');
        validationContext.assertArrayOfStrings(findNode(node, ['trustedComponents']), 'locker.trustedComponents');
    }
}
/**
 * Check the normalized application configuration:
 *      - post-normalization, all properties are required
 *      - routes...
 *      - errorRoutes...
 *      - assets...
 *      - locker...
 *      - SSR is only used with clientOnly locker (or locker is disabled)
 *      - route and errorRoute ids must be unique
 *      - apiVersion: string
 *      - lwrVersion: string
 *      - amdLoader: specifier
 *      - esmLoader: specifier
 *      - port: number, 0 to 65353
 *      - serverMode: string
 *      - serverType: string
 *      - rootDir, cacheDir, contentDir, layoutsDir, globalDataDir: strings
 *      - hooks: array of strings
 *      - bundleProviders: array of services
 *      - moduleProviders: array of services
 *      - viewProviders: array of services
 *      - resourceProviders: array of services
 *      - assetProviders: array of services
 *      - lwc.modules: array
 *      - basePath: valid subdomain part
 * Notes:
 *      - specifier strings are validated for type and shape only, NOT if they are resolvable
 */
function validateRoot(node, validationContext, preMerge) {
    validationContext.assertIsObject(node, 'root');
    validationContext.assertValidKeys(node, 'root', ROOT_ATTRIBUTE_KEYS);
    !preMerge && validationContext.assertRequiredKeys(node, 'root', ROOT_ATTRIBUTE_KEYS);
    const routes = findNode(node, ['routes']);
    const errorRoutes = findNode(node, ['errorRoutes']);
    validationContext.assertUniqueIds([...(routes?.children || []), ...(errorRoutes?.children || [])], 'routes');
    const lockerNode = findNode(node, ['locker']);
    const bundleConfigNode = findNode(node, ['bundleConfig']);
    validateRoutes(routes, validationContext, preMerge);
    validateErrorRoutes(errorRoutes, validationContext);
    validateRouteHandlers(findNode(node, ['routeHandlers']), validationContext);
    validateAssets(findNode(node, ['assets']), validationContext, preMerge);
    validateLocker(lockerNode, validationContext);
    validateBundleConfig(bundleConfigNode, validationContext);
    validationContext.assertClientLockerSSR(routes, lockerNode);
    validationContext.assertNotEmptyString(findNode(node, ['apiVersion']), 'apiVersion');
    validationContext.assertNotEmptyString(findNode(node, ['lwrVersion']), 'lwrVersion');
    validationContext.assertIsSpecifier(findNode(node, ['amdLoader']), 'amdLoader');
    validationContext.assertIsSpecifier(findNode(node, ['esmLoader']), 'esmLoader');
    validationContext.assertIsPort(findNode(node, ['port']), 'port');
    validationContext.assertNotEmptyString(findNode(node, ['serverMode']), 'serverMode');
    validationContext.assertIsServerType(findNode(node, ['serverType']), 'serverType');
    validationContext.assertIsStaticSiteGenerator(findNode(node, ['staticSiteGenerator']), 'staticSiteGenerator');
    validationContext.assertNotEmptyString(findNode(node, ['rootDir']), 'rootDir');
    validationContext.assertNotEmptyString(findNode(node, ['cacheDir']), 'cacheDir');
    validationContext.assertNotEmptyString(findNode(node, ['contentDir']), 'contentDir');
    validationContext.assertNotEmptyString(findNode(node, ['layoutsDir']), 'layoutsDir');
    validationContext.assertNotEmptyString(findNode(node, ['globalDataDir']), 'globalDataDir');
    validationContext.assertArrayOfServices(findNode(node, ['hooks']), 'hooks');
    validationContext.assertArrayOfServices(findNode(node, ['bundleProviders']), 'bundleProviders');
    validationContext.assertArrayOfServices(findNode(node, ['moduleProviders']), 'moduleProviders');
    validationContext.assertArrayOfServices(findNode(node, ['viewProviders']), 'viewProviders');
    validationContext.assertArrayOfServices(findNode(node, ['resourceProviders']), 'resourceProviders');
    validationContext.assertArrayOfServices(findNode(node, ['assetProviders']), 'assetProviders');
    validationContext.assertNotEmptyArray(findNode(node, ['lwc', 'modules']), 'lwc.modules');
    validationContext.assertIsEnvironment(findNode(node, ['environment']), 'environment');
    validationContext.assertIsBasePath(findNode(node, ['basePath']), 'basePath');
}
export function validateLwrAppConfig(config, phase) {
    const span = getTracer().startSpan({ name: ConfigSpan.ValidateConfig });
    try {
        const jsonSourceText = typeof config === 'string' ? config : JSON.stringify(config);
        const errors = [];
        const preMerge = phase !== 'post'; // meaning the config has not yet been merged and normalized
        const rootNode = parseTree(jsonSourceText, errors);
        // Fatal error: JSON could not be parsed
        if (errors.length) {
            const { error, length, offset } = errors[0];
            const message = printParseErrorCode(error);
            const sourceLocation = calculatePositionFromSource(jsonSourceText, { length, offset });
            throw createSingleDiagnosticError({
                location: sourceLocation,
                description: descriptions.CONFIG_PARSER.INVALID_JSON(message),
            }, LwrConfigValidationError);
        }
        // Validate from root
        const validationContext = new ValidationContext(jsonSourceText);
        validateRoot(rootNode, validationContext, preMerge);
        // Throw an error with all diagnostics at once
        if (validationContext.diagnostics.length) {
            throw new LwrConfigValidationError(`Configuration validation errors in ${SOURCE_BY_PHASE[phase]}`, validationContext.diagnostics);
        }
        span.end();
        return;
    }
    catch (err) {
        span.end();
        if (process.env.UNSAFE_IGNORE_CONFIG_VALIDATION === 'true') {
            console.warn('ignoring config validation errors due to UNSAFE_IGNORE_CONFIG_VALIDATION flag...proceed with caution');
            console.dir(err, { depth: null });
            return;
        }
        else {
            throw err;
        }
    }
}
//# sourceMappingURL=app-config.js.map