import fs from 'fs';
import path from 'path';
import { DEFAULT_LWR_BOOTSTRAP_CONFIG, normalizeDirectory, normalizeResourcePath } from '@lwrjs/shared-utils';
export function normalizeRoutes(routes, routeHandlers) {
    return routes.map((route) => {
        // when a route handler is set, ensure it is set in the route handler config
        if (route.routeHandler) {
            const [handler, options] = typeof route.routeHandler === 'string' ? [route.routeHandler, undefined] : route.routeHandler;
            if (!routeHandlers[handler]) {
                routeHandlers[handler] = [handler, options];
            }
            return {
                ...route,
                routeHandler: [handler, options],
                bootstrap: {
                    ...DEFAULT_LWR_BOOTSTRAP_CONFIG,
                    ...route.bootstrap,
                },
            };
        }
        return {
            ...route,
            bootstrap: {
                ...DEFAULT_LWR_BOOTSTRAP_CONFIG,
                ...route.bootstrap,
            },
        };
    });
}
export function normalizeRoutePaths(routes = [], resourcePaths) {
    return routes.map((route) => {
        // route handler paths are NOT normalized here to maintain the id lookup for route handler invocation
        const { contentTemplate, layoutTemplate, subRoutes } = route;
        if (contentTemplate) {
            route.contentTemplate = path.resolve(normalizeResourcePath(contentTemplate, resourcePaths));
        }
        if (layoutTemplate) {
            route.layoutTemplate = path.resolve(normalizeResourcePath(layoutTemplate, resourcePaths));
        }
        if (subRoutes) {
            route.subRoutes = path.resolve(normalizeResourcePath(subRoutes, resourcePaths));
        }
        return route;
    });
}
export function normalizeRouteHandlers(routeHandlers) {
    for (const [id, config] of Object.entries(routeHandlers)) {
        if (typeof config === 'string') {
            routeHandlers[id] = [config, undefined];
        }
    }
    return routeHandlers;
}
export function normalizeRouteHandlerPaths(routeHandlers, resourcePaths) {
    for (const [id, [handler, options]] of Object.entries(routeHandlers)) {
        const normalizedPath = path.resolve(normalizeDirectory(handler, resourcePaths.rootDir));
        // use the normalized path if it exists; otherwise the handler is module specifier
        if (fs.existsSync(normalizedPath)) {
            routeHandlers[id] = [normalizedPath, options];
        }
    }
    return routeHandlers;
}
//# sourceMappingURL=routes.js.map