var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/config/src/validation/app-config.ts
__markAsModule(exports);
__export(exports, {
  SOURCE_BY_PHASE: () => SOURCE_BY_PHASE,
  validateLwrAppConfig: () => validateLwrAppConfig
});
var import_jsonc_parser = __toModule(require("jsonc-parser"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_app_config_context = __toModule(require("./app-config-context.cjs"));
var import_helpers = __toModule(require("./helpers.cjs"));
var import_defaults = __toModule(require("../defaults.cjs"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var SOURCE_BY_PHASE = {
  file: "lwr.config.json",
  pre: "argument passed to createServer",
  post: "configuration hooks"
};
function validateBootstrap(node, validationContext, propPrefix) {
  if (node) {
    validationContext.assertIsObject(node, "bootstrap");
    validationContext.assertValidKeys(node, "bootstrap", import_app_config_context.BOOTSTRAP_ATTRIBUTE_KEYS);
    validationContext.assertArrayOfSpecifiers((0, import_jsonc_parser.findNodeAtLocation)(node, ["services"]), `${propPrefix}.services`);
    validationContext.assertArrayOfSpecifiers((0, import_jsonc_parser.findNodeAtLocation)(node, ["preloadModules"]), `${propPrefix}.preloadModules`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["autoBoot"]), `${propPrefix}.autoBoot`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["ssr"]), `${propPrefix}.ssr`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["configAsSrc"]), `${propPrefix}.configAsSrc`);
    validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["module"]), `${propPrefix}.module`);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["syntheticShadow"]), `${propPrefix}.syntheticShadow`);
    const workers = (0, import_jsonc_parser.findNodeAtLocation)(node, ["workers"]);
    if (workers && workers.children) {
      workers.children.forEach((w, index) => {
        if (w.children && w.children.length > 1) {
          validationContext.assertIsSpecifier(w.children[1], `${propPrefix}.workers[${index}]`);
        }
      });
    }
  }
}
function validateRouteCommon(node, validationContext, propPrefix) {
  validationContext.assertHasOneOrMore(node, propPrefix, [
    "rootComponent",
    "contentTemplate",
    "routeHandler"
  ]);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["id"]), `${propPrefix}.id`);
  validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["rootComponent"]), `${propPrefix}.rootComponent`);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["contentTemplate"]), `${propPrefix}.contentTemplate`);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["layoutTemplate"]), `${propPrefix}.layoutTemplate`);
  validationContext.assertIsService((0, import_jsonc_parser.findNodeAtLocation)(node, ["routeHandler"]), `${propPrefix}.routeHandler`);
  validateBootstrap((0, import_jsonc_parser.findNodeAtLocation)(node, ["bootstrap"]), validationContext, `${propPrefix}.bootstrap`);
}
function validateRoutes(node, validationContext, preMerge) {
  if (node) {
    if (!preMerge) {
      validationContext.assertNotEmptyArray(node, "routes");
    }
    if (node.children) {
      node.children.forEach((n, index) => {
        const propPrefix = `routes[${index}]`;
        validationContext.assertIsObject(n, "routes");
        validationContext.assertValidKeys(n, "routes", import_app_config_context.ROUTE_ATTRIBUTE_KEYS);
        validationContext.assertRequiredKeys(n, propPrefix, ["id", "path"]);
        validationContext.assertIsPath((0, import_jsonc_parser.findNodeAtLocation)(n, ["path"]), `${propPrefix}.path`);
        validationContext.assertIsMethod((0, import_jsonc_parser.findNodeAtLocation)(n, ["method"]), `${propPrefix}.method`);
        validateRouteCommon(n, validationContext, propPrefix);
      });
    }
  }
}
function validateBundleConfig(node, validationContext) {
  if (node) {
    validationContext.assertIsObject(node, "bundleConfig");
    const dupeMap = new Map();
    const dupes = new Set();
    const excludeNode = (0, import_jsonc_parser.findNodeAtLocation)(node, ["exclude"]);
    validationContext.assertArrayOfSpecifiers(excludeNode, "bundleConfig.exclude");
    excludeNode?.children?.forEach((n) => {
      dupeMap.set(n.value, true);
    });
    const external = (0, import_jsonc_parser.findNodeAtLocation)(node, ["external"]);
    if (external) {
      external?.children?.forEach((n) => {
        const specifier = (n?.children && n.children[0])?.value;
        if (specifier && dupeMap.has(specifier)) {
          dupes.add(specifier);
        } else {
          dupeMap.set(specifier, true);
        }
      });
    }
    const groups = (0, import_jsonc_parser.findNodeAtLocation)(node, ["groups"]);
    if (groups) {
      validationContext.assertIsObject(groups, "bundleConfig.groups");
      groups?.children?.forEach((n) => {
        const groupKey = n?.children && n.children[0];
        const group = n?.children && n.children[1];
        if (group && groupKey) {
          validationContext.assertNotEmptyArray(group, `bundleConfig.groups.${groupKey.value}`);
          validationContext.assertArrayOfSpecifiers(group, `bundleConfig.groups.${groupKey.value}`);
          const groupies = group?.children;
          groupies?.forEach((n2) => {
            if (dupeMap.has(n2.value)) {
              dupes.add(n2.value);
            }
          });
        }
      });
    }
    const defaultExcludes = new Set([...import_defaults.DEFAULT_AMD_BUNDLE_EXCLUSIONS, ...import_defaults.DEFAULT_ESM_BUNDLE_EXCLUSIONS]);
    const dupesFiltered = Array.from(dupes).filter((specifier) => !defaultExcludes.has(specifier));
    validationContext.assertNoBundleConfigDupes(node, dupesFiltered);
  }
}
function validateErrorRoutes(node, validationContext) {
  if (node) {
    validationContext.assertIsArray(node, "errorRoutes");
    if (node.children) {
      node.children.forEach((n, index) => {
        const propPrefix = `errorRoutes[${index}]`;
        validationContext.assertIsObject(n, "errorRoutes");
        validationContext.assertValidKeys(n, "errorRoutes", import_app_config_context.ERROR_ROUTE_ATTRIBUTE_KEYS);
        validationContext.assertRequiredKeys(n, propPrefix, ["id", "status"]);
        validationContext.assertIsStatus((0, import_jsonc_parser.findNodeAtLocation)(n, ["status"]), `${propPrefix}.status`);
        validateRouteCommon(n, validationContext, propPrefix);
      });
    }
  }
}
function validateRouteHandlers(node, validationContext) {
  if (node) {
    validationContext.assertIsObject(node, "routeHandlers");
  }
}
function validateAssets(node, validationContext, preMerge) {
  if (node) {
    if (preMerge && node.type === "string") {
      validationContext.assertNotEmptyString(node, "assets");
    } else {
      validationContext.assertNotEmptyArray(node, "assets");
      if (node.children) {
        node.children.forEach((n, index) => {
          const rootDirNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["root"]);
          const dirNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["dir"]);
          const fileNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["file"]);
          if (rootDirNode?.type === "boolean") {
            validationContext.assertIsObject(n, "assetDir");
            validationContext.assertValidKeys(n, "assetDir", import_app_config_context.ASSET_DIR_ATTRIBUTE_KEYS);
          } else if (dirNode?.type === "string") {
            validationContext.assertIsObject(n, "assetDir");
            validationContext.assertValidKeys(n, "assetDir", import_app_config_context.ASSET_DIR_ATTRIBUTE_KEYS);
            validationContext.assertRequiredKeys(n, `assets[${index}]`, ["urlPath"]);
            validationContext.assertIsPath((0, import_jsonc_parser.findNodeAtLocation)(n, ["urlPath"]), `assets[${index}].urlPath`);
          } else if (fileNode?.type === "string") {
            validationContext.assertIsObject(n, "assetFile");
            validationContext.assertValidKeys(n, "assetFile", import_app_config_context.ASSET_FILE_ATTRIBUTE_KEYS);
            validationContext.assertRequiredKeys(n, `assets[${index}]`, ["urlPath"]);
            validationContext.assertIsPath((0, import_jsonc_parser.findNodeAtLocation)(n, ["urlPath"]), `assets[${index}].urlPath`);
          }
          validationContext.assertHasOnlyOne(n, `assets[${index}]`, ["dir", "file"]);
          validationContext.assertNotEmptyString(dirNode, `assets[${index}].dir`);
          validationContext.assertNotEmptyString(fileNode, `assets[${index}].file`);
          validationContext.assertIsBoolean(rootDirNode, `assets[${index}].root`);
          validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(n, ["alias"]), `assets[${index}].alias`);
        });
      }
    }
  }
}
function validateLocker(node, validationContext) {
  if (node) {
    validationContext.assertIsObject(node, "locker");
    validationContext.assertValidKeys(node, "locker", import_app_config_context.LOCKER_ATTRIBUTE_KEYS);
    validationContext.assertRequiredKeys(node, "locker", ["enabled"]);
    validationContext.assertIsBoolean((0, import_jsonc_parser.findNodeAtLocation)(node, ["enabled"]), "locker.enabled");
    validationContext.assertArrayOfStrings((0, import_jsonc_parser.findNodeAtLocation)(node, ["trustedComponents"]), "locker.trustedComponents");
  }
}
function validateRoot(node, validationContext, preMerge) {
  validationContext.assertIsObject(node, "root");
  validationContext.assertValidKeys(node, "root", import_app_config_context.ROOT_ATTRIBUTE_KEYS);
  !preMerge && validationContext.assertRequiredKeys(node, "root", import_app_config_context.ROOT_ATTRIBUTE_KEYS);
  const routes = (0, import_jsonc_parser.findNodeAtLocation)(node, ["routes"]);
  const errorRoutes = (0, import_jsonc_parser.findNodeAtLocation)(node, ["errorRoutes"]);
  validationContext.assertUniqueIds([...routes?.children || [], ...errorRoutes?.children || []], "routes");
  const lockerNode = (0, import_jsonc_parser.findNodeAtLocation)(node, ["locker"]);
  const bundleConfigNode = (0, import_jsonc_parser.findNodeAtLocation)(node, ["bundleConfig"]);
  validateRoutes(routes, validationContext, preMerge);
  validateErrorRoutes(errorRoutes, validationContext);
  validateRouteHandlers((0, import_jsonc_parser.findNodeAtLocation)(node, ["routeHandlers"]), validationContext);
  validateAssets((0, import_jsonc_parser.findNodeAtLocation)(node, ["assets"]), validationContext, preMerge);
  validateLocker(lockerNode, validationContext);
  validateBundleConfig(bundleConfigNode, validationContext);
  validationContext.assertClientLockerSSR(routes, lockerNode);
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["apiVersion"]), "apiVersion");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["lwrVersion"]), "lwrVersion");
  validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["amdLoader"]), "amdLoader");
  validationContext.assertIsSpecifier((0, import_jsonc_parser.findNodeAtLocation)(node, ["esmLoader"]), "esmLoader");
  validationContext.assertIsPort((0, import_jsonc_parser.findNodeAtLocation)(node, ["port"]), "port");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["serverMode"]), "serverMode");
  validationContext.assertIsServerType((0, import_jsonc_parser.findNodeAtLocation)(node, ["serverType"]), "serverType");
  validationContext.assertIsStaticSiteGenerator((0, import_jsonc_parser.findNodeAtLocation)(node, ["staticSiteGenerator"]), "staticSiteGenerator");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["rootDir"]), "rootDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["cacheDir"]), "cacheDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["contentDir"]), "contentDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["layoutsDir"]), "layoutsDir");
  validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["globalDataDir"]), "globalDataDir");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["hooks"]), "hooks");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["bundleProviders"]), "bundleProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["moduleProviders"]), "moduleProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["viewProviders"]), "viewProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["resourceProviders"]), "resourceProviders");
  validationContext.assertArrayOfServices((0, import_jsonc_parser.findNodeAtLocation)(node, ["assetProviders"]), "assetProviders");
  validationContext.assertNotEmptyArray((0, import_jsonc_parser.findNodeAtLocation)(node, ["lwc", "modules"]), "lwc.modules");
  validationContext.assertIsEnvironment((0, import_jsonc_parser.findNodeAtLocation)(node, ["environment"]), "environment");
  validationContext.assertIsBasePath((0, import_jsonc_parser.findNodeAtLocation)(node, ["basePath"]), "basePath");
}
function validateLwrAppConfig(config, phase) {
  const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.ConfigSpan.ValidateConfig});
  try {
    const jsonSourceText = typeof config === "string" ? config : JSON.stringify(config);
    const errors = [];
    const preMerge = phase !== "post";
    const rootNode = (0, import_jsonc_parser.parseTree)(jsonSourceText, errors);
    if (errors.length) {
      const {error, length, offset} = errors[0];
      const message = (0, import_jsonc_parser.printParseErrorCode)(error);
      const sourceLocation = (0, import_helpers.calculatePositionFromSource)(jsonSourceText, {length, offset});
      throw (0, import_diagnostics.createSingleDiagnosticError)({
        location: sourceLocation,
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_JSON(message)
      }, import_diagnostics.LwrConfigValidationError);
    }
    const validationContext = new import_app_config_context.ValidationContext(jsonSourceText);
    validateRoot(rootNode, validationContext, preMerge);
    if (validationContext.diagnostics.length) {
      throw new import_diagnostics.LwrConfigValidationError(`Configuration validation errors in ${SOURCE_BY_PHASE[phase]}`, validationContext.diagnostics);
    }
    span.end();
    return;
  } catch (err) {
    span.end();
    if (process.env.UNSAFE_IGNORE_CONFIG_VALIDATION === "true") {
      console.warn("ignoring config validation errors due to UNSAFE_IGNORE_CONFIG_VALIDATION flag...proceed with caution");
      console.dir(err, {depth: null});
      return;
    } else {
      throw err;
    }
  }
}
