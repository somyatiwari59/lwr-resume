import { kebabCaseToModuleSpecifier, toImportMetadata, getModuleGraphs, getMappingUriPrefix, GraphDepth, logger, explodeSpecifier, isBundler, getHydrateDirective, } from '@lwrjs/shared-utils';
import { AppResourceEnum, getAppSpecifier } from '@lwrjs/app-service/identity';
import { generateHtmlTag, getModuleResourceByUri } from '../utils.js';
import { flattenCustomElements, getViewBootstrapConfigurationResource, getViewHmrConfigurationResource, } from './utils.js';
import { setPreloadModulesMeta, getPreloadModulesMeta } from './preload-utils.js';
export async function getHtmlResources(view, viewParams, resourceContext) {
    const { runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler, resourceRegistry, viewMetadata, } = resourceContext;
    const { lwrVersion, format, hmrEnabled, bundle, debug, minify } = runtimeEnvironment;
    const { customElements } = viewMetadata;
    const defRegistry = bundle ? moduleBundler : moduleRegistry;
    const version = lwrVersion;
    const isAMD = format === 'amd';
    const depth = isAMD
        ? { static: GraphDepth.ALL, dynamic: 1 }
        : { static: GraphDepth.NONE, dynamic: 1 };
    const { bundleConfig } = resourceContext;
    const { external = {} } = bundleConfig;
    // Bundling groups is only supported in AMD for now
    const groups = isAMD ? bundleConfig.groups || {} : {};
    const isExternal = function (rawSpecifier) {
        const { specifier } = explodeSpecifier(rawSpecifier);
        return Object.keys(external).some((e) => specifier === e);
    };
    const { id: appName, bootstrap: { services, module: bootstrapModule, preloadModules = [] } = {
        services: [],
        preloadModules: [],
    }, } = view;
    // The Application Bootstrap (ABS) module resource is EITHER
    //      - configured as routes[x].bootstrap.module OR
    //      - defaulted as "@lwrjs/app-service/{appName}/module/{format}"
    const appIdentity = {
        appName,
        format: runtimeEnvironment.format,
        resourceType: AppResourceEnum.MODULE,
    };
    const bootstrapSpecifier = bootstrapModule || getAppSpecifier(appIdentity);
    /*
        Internal module and module dependency related resources used by the view to render view related components.
     */
    const moduleResources = [];
    /*
        External resources that the view depends. These resources include ones that an ViewDefinition client are required to load
        in order to view to begin initialization.
     */
    const requiredResources = [];
    /*
        Bootstrap configuration resources -- these resources are specifically exposed as bootstrap.resources in the RenderedViewRecord
     */
    const configResources = [];
    // Cache of visited module flattened graphs
    const visitedCache = new Map();
    // Collection of import URL metadata
    const imports = {};
    // Collection of root view component specifiers
    const rootComponents = [];
    // Collection of modules specifiers that MUST be loaded in the view
    const requiredAmdModules = [];
    // Collect preload modules metadata
    const viewPreloads = {
        uris: [],
        specifiers: [],
        groups: new Map(),
    };
    // Determine if server side rendering view modules
    const isSSR = view.bootstrap?.ssr;
    // ABS module and custom element references
    let bootstrapModuleRef, versionedSpecifier = bootstrapSpecifier;
    let importMetadata = { imports: {} };
    const customElementsRecords = [];
    const flattenedElements = flattenCustomElements(customElements, isSSR);
    const viewContainsLiveElements = !isSSR || flattenedElements.some(({ props }) => getHydrateDirective(props));
    if (viewContainsLiveElements) {
        // ------ AMD Required module resources
        if (isAMD) {
            // Keep shim format in sync with legacy_view_bootstrap.ts
            const shimBundle = debug || minify === false ? 'lwr-loader-shim.bundle.js' : 'lwr-loader-shim.bundle.min.js';
            const def = (await resourceRegistry.getResource({ specifier: shimBundle, version }, runtimeEnvironment, runtimeParams));
            if (!def) {
                throw Error('Failed to find definition of resource: ' + shimBundle);
            }
            requiredResources.push(def);
            // Always inline the error shim script after the shim
            const errorShimDef = (await resourceRegistry.getResource({ specifier: 'lwr-error-shim.js', version }, runtimeEnvironment, runtimeParams));
            if (!errorShimDef) {
                throw Error('Failed to find definition of resource: lwr-error-shim.js');
            }
            requiredResources.push(errorShimDef);
        }
        // ------- Application Bootstrap module
        // Traversal of the Bootstrap Module Graph is done to get all the URLS for discoverable static dependencies.
        // Reasoning: This is to avoid unnecessary HTTP 302's during initial application module fetching.
        const bootstrapModuleGraph = await getModuleGraphs(bootstrapSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
        bootstrapModuleRef = {
            specifier: bootstrapModuleGraph.graphs[0].specifier,
            flatGraph: bootstrapModuleGraph,
            resources: configResources,
        };
        // ADD bootstrap module uri as a script resource
        versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
        const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
        moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { isPreload: false, isSSR }));
        // PRELOAD the bootstrap module static dependencies as preloaded script resources
        for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
            if (!isExternal(depSpecifier)) {
                const uri = bootstrapModuleGraph.uriMap[depSpecifier];
                setPreloadModulesMeta(depSpecifier, uri, groups, viewPreloads);
            }
        }
        // PRELOAD configured preloadModules as preloaded script resources
        if (isBundler(defRegistry)) {
            for (const specifier of preloadModules) {
                // eslint-disable-next-line no-await-in-loop
                await getPreloadModulesMeta(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
            }
        }
        if (isAMD) {
            // ADD bootstrap module as required
            requiredAmdModules.push(versionedSpecifier);
            // ADD bootstrap module uri addressability
            imports[versionedSpecifier] = uri;
            // PRELOAD bootstrap module static deps as link resource
            for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
                const uri = bootstrapModuleGraph.uriMap[staticDep];
                // ADD static module dep uri addressability
                imports[staticDep] = uri;
                // ADD bootstrap module static deps to requiredAmdModules if services, otherwise preloadModules
                if (services && services.length) {
                    requiredAmdModules.push(staticDep);
                }
            }
            // Add import mappings for known dynamic imports
            for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
                const uri = bootstrapModuleGraph.uriMap[dynamicDep];
                if (uri) {
                    imports[dynamicDep] = uri;
                }
                else {
                    logger.warn('Skipping unknown dynamic import ' + dynamicDep);
                }
            }
        }
        importMetadata = await toImportMetadata(bootstrapModuleGraph, { imports: {}, index: {} }, moduleRegistry, runtimeEnvironment, runtimeParams);
    }
    // ------- View related custom element moduleResources
    for (const { tagName: element, props } of flattenedElements) {
        // eslint-disable-next-line no-await-in-loop
        const graph = await getModuleGraphs(kebabCaseToModuleSpecifier(element), { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams ? runtimeParams : {}, visitedCache);
        // add to the viewRecord
        customElementsRecords.push({ elementName: element, flatGraph: graph });
        // Only process custom elements that are to be hydrated or are CSR-only islands
        if (!isSSR || getHydrateDirective(props)) {
            // PRELOAD the custom element module as a link resource
            const specifier = graph.graphs[0].specifier;
            const uri = graph.uriMap[specifier];
            setPreloadModulesMeta(specifier, uri, groups, viewPreloads);
            // PRELOAD custom element static deps as link resources when bundling is ON
            if (bundle) {
                for (const depSpecifier of graph.graphs[0].static) {
                    if (!isExternal(depSpecifier)) {
                        const uri = graph.uriMap[depSpecifier];
                        setPreloadModulesMeta(depSpecifier, uri, groups, viewPreloads);
                    }
                }
            }
            // ADD register custom elements as a uri addressable rootComponents
            rootComponents.push(specifier);
            imports[specifier] = uri;
            if (isAMD) {
                for (const staticDep of graph.graphs[0].static) {
                    const uri = graph.uriMap[staticDep];
                    // AMD ADD static module dep uri addressability
                    imports[staticDep] = uri;
                }
                // AMD ADD dynamic imports module dep uri addressability
                for (const dynamicDep of graph.graphs[0].dynamicRefs) {
                    const uri = graph.uriMap[dynamicDep];
                    imports[dynamicDep] = uri;
                }
            }
            // eslint-disable-next-line no-await-in-loop
            importMetadata = await toImportMetadata(graph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
        }
    }
    if (viewContainsLiveElements) {
        // ADD configuration of the bootstrapModule
        configResources.unshift(getViewBootstrapConfigurationResource({
            id: view.id,
            url: viewParams?.page?.url,
            configAsSrc: view.bootstrap?.configAsSrc || false,
        }, {
            appId: appIdentity.appName,
            bootstrapModule: versionedSpecifier,
            autoBoot: view.bootstrap?.autoBoot === false ? false : true,
            imports: importMetadata?.imports,
            index: importMetadata?.index,
            rootComponents,
            ...(isAMD && { requiredModules: requiredAmdModules }),
            // in AMD we need to tell the loader what modules we are preloading
            ...(isAMD && { preloadModules: viewPreloads.specifiers }),
        }, runtimeEnvironment, runtimeParams));
    }
    if (!isAMD && hmrEnabled) {
        configResources.unshift(getViewHmrConfigurationResource(view, viewMetadata));
    }
    // PRELOAD script resources for preload module URIs after the bootstrap module
    const dedupedUris = [...new Set(viewPreloads.uris)];
    for (const preloadUri of dedupedUris) {
        moduleResources.push(getModuleResourceByUri(preloadUri, runtimeEnvironment, { isPreload: true, isSSR }));
    }
    // generate html partial
    const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(generateHtmlTag));
    const mapping = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping,
        },
    };
    return {
        partial: htmlResources.join('\n'),
        viewRecord: {
            resources: requiredResources,
            customElements: customElementsRecords,
            endpoints,
            importMetadata,
            bootstrapModule: bootstrapModuleRef,
        },
    };
}
//# sourceMappingURL=view_bootstrap.js.map