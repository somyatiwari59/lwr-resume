import crypto from 'crypto';
import { join, relative, basename } from 'path';
import { createReadStream, existsSync, readFileSync, writeFileSync } from 'fs';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { isExternalUrl, ASSETS_CACHE_DIR, logger, isAssetSourceExternal } from '@lwrjs/shared-utils';
export class LwrAssetRegistry {
    constructor(context, lwrGlobalConfig) {
        this.name = 'lwr-asset-registry';
        this.providers = [];
        this.transformers = [];
        const { assets, basePath, rootDir, layoutsDir, contentDir, cacheDir } = lwrGlobalConfig;
        this.basePath = basePath;
        this.resourcePaths = { assets, rootDir, layoutsDir, contentDir };
        this.cacheDir = join(cacheDir, ASSETS_CACHE_DIR);
        this._memoizeResolveUri = this.resolveAssetUriWithoutLinking.bind(this);
    }
    async delegateGetAsset(assetIdentifier) {
        for (const provider of this.providers) {
            // eslint-disable-next-line no-await-in-loop
            const result = await provider.getAsset(assetIdentifier);
            if (result) {
                return result;
            }
        }
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.ASSET(assetIdentifier.specifier),
        }, LwrUnresolvableError);
    }
    // -- Public API --------------------------------------------------------------------
    // Add new resource providers
    addAssetProviders(providers) {
        this.providers.push(...providers);
    }
    // Add new asset transformers
    addAssetTransformers(transformers) {
        this.transformers.push(...transformers);
    }
    // Retrieve a resource from the providers and transform it though pipeline of plugins
    async getAsset(assetId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    runtimeEnvironment, includeMetadata) {
        const rawAsset = await this.delegateGetAsset(assetId);
        // STEP 0: Quick return if the provider ask not to transform the content
        // Check if the source says it should not be transformed
        if (rawAsset.noTransform) {
            const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
            logger.debug(`[LwrAssetRegistry][getAsset] no-transform source ${assetId.specifier} -> ${assetDef.uri}`);
            return assetDef;
        }
        // STEP 1: Check for cached asset
        const overrideFilePath = this.getHashedAssetPath(rawAsset, runtimeEnvironment);
        // Since metadata is not cached with the asset to include metadata we need to re-process
        if (existsSync(overrideFilePath)) {
            // Parse the associated metadata if available
            if (includeMetadata && existsSync(`${overrideFilePath}.meta.json`)) {
                rawAsset.metadata = JSON.parse(readFileSync(`${overrideFilePath}.meta.json`).toString());
            }
            return this.getAssetDefinition(rawAsset, runtimeEnvironment);
        }
        // STEP 2: Apply first asset source transformation
        // In this hook you can modify the source arbitrarily @include file semantics
        // INVARIANT: return must be a parsable mimetype compliant source
        // ex (SASS -> CSS, LESS -> CSS, PNG -> PNG optimized, ...)
        let transformResult;
        for (const transformPlugin of this.transformers) {
            // eslint-disable-next-line no-await-in-loop
            const curResult = await transformPlugin.transformSource?.(rawAsset, runtimeEnvironment);
            // If asset source is returned
            if (curResult) {
                transformResult = {
                    ...transformResult,
                    ...curResult,
                };
                // Override the content function for the next transformer
                rawAsset.content = () => curResult.source;
                if (curResult.metadata) {
                    rawAsset.metadata = curResult.metadata;
                }
            }
        }
        // STEP 3: Store the modified/transformed version of the asset
        if (transformResult) {
            writeFileSync(overrideFilePath, transformResult.source, 'utf-8');
            if (transformResult.metadata) {
                writeFileSync(`${overrideFilePath}.meta.json`, JSON.stringify(transformResult.metadata), 'utf-8');
            }
            logger.debug(`[LwrAssetRegistry][getAsset] cached transformed asset ${assetId.specifier}`);
        }
        else {
            // else indicate on the source it was not transformed
            rawAsset.noTransform = true;
        }
        // STEP 4: Normalize and augment the asset and return the full definition
        const newDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
        logger.debug(`[LwrAssetRegistry][getAsset] fully processed ${assetId.specifier} -> ${newDef.uri}`);
        if (includeMetadata) {
            return { ...newDef, metadata: rawAsset.metadata };
        }
        else {
            return newDef;
        }
    }
    getHashedAssetPath({ ownHash, entry, type }, runtimeEnvironment) {
        const runtimeHash = [
            this.basePath,
            runtimeEnvironment.lwrVersion,
            type || 'd',
            runtimeEnvironment.compat ? 'c' : '',
            runtimeEnvironment.immutableAssets ? 'i' : '',
            runtimeEnvironment.minify ? 'm' : '',
        ].join('');
        // Create a hash based on the full path plus the own hash from the provider.
        // The FS provider own hash is just the last time the file was saved.
        const fullPathHash = crypto.createHash('sha1').update(`${entry}:${ownHash}`).digest('hex').toString();
        const hashedPath = join(this.cacheDir, `${runtimeHash}_${fullPathHash}_${basename(entry)}`);
        logger.debug(`[LwrAssetRegistry][getHashedAssetPath] ${runtimeHash} -> ${hashedPath}`);
        return hashedPath;
    }
    async getAssetDefinition(assetSource, runtimeEnvironment) {
        const { type, uri } = this.validateSpecifier(assetSource.entry);
        const overrideFilePath = assetSource.noTransform
            ? assetSource.entry
            : this.getHashedAssetPath(assetSource, runtimeEnvironment);
        return {
            ...assetSource,
            artifactType: 'asset',
            type: assetSource.uri ? 'external' : type,
            uri: assetSource.uri || uri,
            // NOTE: The "entry" field still points to the old fs path.
            // If we were to change it, we need to reconcile it with the metadata delivery on HMR
            stream: (encoding) => createReadStream(overrideFilePath, { encoding }),
            content: (encoding) => readFileSync(overrideFilePath, encoding),
        };
    }
    // Given a resource and environment, return a resource URI
    async resolveAssetUri(assetId, runtimeEnvironment) {
        const { specifier } = assetId;
        // If the asset is an external URL there is nothing to do
        if (isExternalUrl(specifier)) {
            logger.debug(`[LwrAssetRegistry][resolveAssetUri] external url ${specifier}`);
            return {
                artifactType: 'asset',
                uri: specifier,
                entry: specifier,
                immutable: true,
                external: true,
            };
        }
        const assetDef = await this.getAsset(assetId, runtimeEnvironment);
        const ret = await this.getUriFromAsset(assetDef, runtimeEnvironment);
        logger.debug(`[LwrAssetRegistry][resolveAssetUri] getUriFromAsset ${specifier} -> ${ret.uri}`);
        return ret;
    }
    // Given a resource and environment, return a resource URI with out deep linking (which could result in cycles)
    async resolveAssetUriWithoutLinking(assetId, runtimeEnvironment) {
        const { specifier } = assetId;
        // If the asset is an external URL there is nothing to do
        if (isExternalUrl(specifier)) {
            logger.debug(`[LwrAssetRegistry][resolveAssetUriWithoutLinking] external url ${specifier}`);
            return {
                artifactType: 'asset',
                uri: specifier,
                entry: specifier,
                immutable: true,
                external: true,
            };
        }
        // Skips linking
        const rawAsset = await this.delegateGetAsset(assetId);
        const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
        const uri = await this.getUriFromAsset(assetDef, runtimeEnvironment);
        logger.debug(`[LwrAssetRegistry][resolveAssetUriWithoutLinking] getUriFromAsset ${specifier} -> ${assetDef.uri}`);
        return uri;
    }
    async getUriFromAsset(assetDef, runtimeEnvironment) {
        // Create a non transformed URI
        let uri = {
            artifactType: 'asset',
            uri: String(join(runtimeEnvironment.basePath, assetDef.uri)),
            entry: assetDef.entry,
            immutable: false,
            external: isAssetSourceExternal(assetDef),
        };
        // Perform any transforms
        for (const transformPlugin of this.transformers) {
            // eslint-disable-next-line no-await-in-loop
            const resolveUriResult = await transformPlugin.transformUri?.(uri, assetDef, runtimeEnvironment);
            if (resolveUriResult) {
                uri = resolveUriResult;
            }
        }
        return uri;
    }
    getPublicApi() {
        return {
            getAsset: this.getAsset.bind(this),
            resolveAssetUri: this.resolveAssetUri.bind(this),
        };
    }
    validateSpecifier(specifier) {
        // If is a URL
        if (isExternalUrl(specifier)) {
            return {
                type: 'external',
                uri: specifier,
            };
        }
        const { assets, contentDir } = this.resourcePaths;
        const assetsMap = assets.reduce((map, asset) => {
            const { alias, urlPath } = asset;
            if (alias) {
                const assetDir = asset;
                const fsPath = assetDir.dir ? assetDir.dir : asset.file;
                if (fsPath) {
                    map[fsPath] = urlPath;
                }
            }
            return map;
        }, {});
        if (specifier.startsWith(contentDir)) {
            return {
                type: 'content-asset',
                uri: relative(contentDir, specifier),
            };
        }
        for (const [fsPath, urlPath] of Object.entries(assetsMap)) {
            if (specifier.startsWith(fsPath)) {
                return {
                    type: 'asset',
                    uri: specifier.replace(fsPath, urlPath),
                };
            }
        }
        return {
            type: 'unknown',
            uri: specifier,
        };
    }
}
//# sourceMappingURL=index.js.map