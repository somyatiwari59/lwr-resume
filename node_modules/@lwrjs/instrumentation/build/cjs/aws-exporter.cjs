var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/instrumentation/src/aws-exporter.ts
__markAsModule(exports);
__export(exports, {
  AWSExporter: () => AWSExporter
});
var import_core = __toModule(require("@opentelemetry/core"));
var import_metrics_sender = __toModule(require("@salesforce/pwa-kit-runtime/utils/ssr-server/metrics-sender.cjs"));
var import_spans = __toModule(require("./spans.cjs"));
var DEFAULT_DIMENSIONS = {
  Project: process.env.MOBIFY_PROPERTY_ID,
  Target: process.env.DEPLOY_TARGET
};
var SUPPORTED_SPANS = new Set([import_spans.ViewSpan.Render, import_spans.ViewSpan.ServerSideRender, import_spans.ViewSpan.GetPageData]);
function toCustomMetrics(span) {
  const metrics = [];
  if (span.name === import_spans.ViewSpan.Render && span.status.code > 0) {
    metrics.push({
      name: "RenderErrors",
      dimensions: DEFAULT_DIMENSIONS,
      timestamp: new Date((0, import_core.hrTimeToTimeStamp)(span.startTime)),
      unit: "Count",
      value: 1
    });
  }
  if (span.name === import_spans.ViewSpan.ServerSideRender && span.status.code > 0) {
    metrics.push({
      name: "RenderFallbackTime",
      dimensions: DEFAULT_DIMENSIONS,
      timestamp: new Date((0, import_core.hrTimeToTimeStamp)(span.startTime)),
      unit: "Milliseconds",
      value: (0, import_core.hrTimeToMilliseconds)(span.duration)
    });
  }
  if (span.name === import_spans.ViewSpan.GetPageData) {
    const metric = {
      name: "ExternalRequestTime",
      dimensions: DEFAULT_DIMENSIONS,
      timestamp: new Date((0, import_core.hrTimeToTimeStamp)(span.startTime)),
      unit: "Milliseconds",
      value: (0, import_core.hrTimeToMilliseconds)(span.duration)
    };
    metrics.push(metric);
    if (span.status.code > 0) {
      metrics.push({
        ...metric,
        name: "ExternalRequestFailed"
      });
    }
  }
  return metrics;
}
var AWSExporter = class {
  constructor() {
    this.metricsSender = import_metrics_sender.MetricsSender.getSender();
    this.isShutdown = false;
    this.isLambda = process.env.AWS_LAMBDA_FUNCTION_NAME;
  }
  export(spans, done) {
    if (this.isShutdown) {
      done({
        code: import_core.ExportResultCode.FAILED,
        error: new Error("Failed to export spans: Exporter shutdown")
      });
      return;
    }
    this.log(spans);
    if (!this.isLambda) {
      done({code: import_core.ExportResultCode.SUCCESS});
      return;
    }
    this.send(spans.filter(({name}) => SUPPORTED_SPANS.has(name)), done);
  }
  log(spans) {
    for (const span of spans) {
      console.log(JSON.stringify({
        traceId: span.spanContext().traceId,
        parentId: span.parentSpanId,
        traceState: span.spanContext().traceState?.serialize(),
        name: span.name,
        id: span.spanContext().spanId,
        kind: span.kind,
        timestamp: (0, import_core.hrTimeToTimeStamp)(span.startTime),
        duration: (0, import_core.hrTimeToMilliseconds)(span.duration),
        attributes: span.attributes,
        status: span.status,
        events: span.events,
        links: span.links
      }));
    }
  }
  send(spans, done) {
    this.metricsSender.send(spans.map(toCustomMetrics).flat());
    done({code: import_core.ExportResultCode.SUCCESS});
  }
  async shutdown() {
    this.isShutdown = true;
  }
};
