import { explodeSpecifier, getSpecifier, logger } from '@lwrjs/shared-utils';
import path from 'path';
import { resolveStaticBundleVersion } from '../utils/static-utils.js';
export default class StaticModuleProvider {
    constructor(_config, context) {
        this.name = 'static-module-provider';
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.externals = Object.keys(context.config.bundleConfig.external || {});
        this.siteBundles = context.siteMetadata.getSiteBundles();
        this.siteRootDir = context.siteMetadata.getSiteRootDir();
        // If we are using fingerprints collect all the specifiers in the bundles and add them to an index for creating the mapping identities
        this.fingerprintIndex = buildFingerprintsIndex(context);
    }
    async getModule(moduleId) {
        const { specifier } = moduleId;
        const metadata = this.siteBundles.bundles[specifier];
        if (metadata) {
            logger.warn(`[${this.name}] We should not be asking for module source we have in our site metadata ${moduleId.specifier}`);
            // proceed to next provider
            return undefined;
        }
        // proceed to next provider
        return undefined;
    }
    async getModuleEntry(moduleId) {
        // TODO shouldn't we be passing the runtime environment here to test?
        const { specifier, version } = moduleId;
        const metadata = this.siteBundles.bundles[specifier];
        if (metadata) {
            logger.info(`[${this.name}] Module Entry request for static bundle ${specifier}`);
            // Have to make the bundle code available for SSR
            const bundlePath = path.join(this.siteRootDir, metadata.path);
            const resolvedVersion = resolveStaticBundleVersion(metadata.version, version);
            return {
                id: getSpecifier({ ...moduleId, version: resolvedVersion }),
                version: resolvedVersion,
                specifier: specifier,
                entry: 'entry-not-provided',
                src: bundlePath,
            };
        }
        else if (this.externals.includes(specifier)) {
            // Externals are not SSG'ed so hard coding definition
            const resolvedVersion = resolveStaticBundleVersion(undefined, version);
            return {
                id: getSpecifier({ ...moduleId, version: resolvedVersion }),
                version: resolvedVersion,
                specifier: specifier,
                entry: 'entry-not-provided',
            };
        }
        else if (this.fingerprintIndex[specifier]) {
            return this.fingerprintIndex[specifier];
        }
        // proceed to next provider
        return undefined;
    }
}
/**
 * Map each of the includedModules for a bundle to the bundle src
 * This enables lookup of modules which are not top-level in the bundle metadata
 */
function buildFingerprintsIndex(context) {
    const fingerprintIndex = {};
    if (!context.runtimeEnvironment.featureFlags.LEGACY_LOADER) {
        const bundles = context.siteMetadata?.getSiteBundles().bundles || {};
        for (const bundle of Object.values(bundles)) {
            const bundlePath = path.join(String(context.siteMetadata?.getSiteRootDir()), bundle.path);
            const includedModules = bundle.includedModules || [];
            for (const includedModule of includedModules) {
                const moduleId = explodeSpecifier(includedModule);
                if (!fingerprintIndex[moduleId.specifier]) {
                    fingerprintIndex[moduleId.specifier] = {
                        id: getSpecifier(moduleId),
                        version: resolveStaticBundleVersion(moduleId.version),
                        specifier: moduleId.specifier,
                        entry: 'entry-not-provided',
                        src: bundlePath,
                    };
                }
            }
        }
    }
    return fingerprintIndex;
}
//# sourceMappingURL=static-module-provider.js.map