import { explodeSpecifier, getSpecifier, logger } from '@lwrjs/shared-utils';
import path from 'path';
import fs from 'fs-extra';
import { resolveStaticBundleVersion } from '../utils/static-utils.js';
const LWR_SSR_BUNDLE_PREFIX = '@lwrjs/lwc-ssr/';
export default class StaticBundleProvider {
    constructor(_config, context) {
        this.name = 'static-bundle-provider';
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.siteBundles = context.siteMetadata.getSiteBundles();
        this.siteRootDir = context.siteMetadata.getSiteRootDir();
        this.bundleConfig = context.config.bundleConfig;
    }
    async bundle(moduleId, runtimeEnvironment) {
        const { specifier, name, namespace, version } = moduleId;
        const metadata = this.siteBundles.bundles[specifier];
        if (!metadata) {
            // ignore ssr module requests
            if (!specifier.startsWith(LWR_SSR_BUNDLE_PREFIX)) {
                logger.warn(`[${this.name}] did not find requested specifier ${specifier}`);
            }
            return undefined;
        }
        // Have to make the bundle code available for SSR
        const bundlePath = path.join(this.siteRootDir, metadata.path);
        const code = (await fs.readFile(bundlePath)).toString('utf-8');
        const imports = metadata.imports.map((specifier) => {
            const importModule = explodeSpecifier(specifier);
            if (!importModule.version) {
                // Get version from metadata for un-versioned imports
                importModule.version = resolveStaticBundleVersion(this.siteBundles.bundles[specifier]?.version);
            }
            return importModule;
        });
        const id = getSpecifier(moduleId);
        const exploded = explodeSpecifier(id);
        // Seem unlikely name was not in the moduleId but just incase set it form the exploded id
        const resolvedName = name || exploded.name;
        const resolvedNamespace = namespace || exploded.namespace;
        const resolvedVersion = resolveStaticBundleVersion(metadata.version, version);
        return {
            code,
            id: getSpecifier({
                specifier: specifier,
                version: resolvedVersion,
                name: resolvedName,
                namespace: resolvedNamespace,
            }),
            name: resolvedName,
            namespace: resolvedNamespace,
            version: resolvedVersion,
            specifier: specifier,
            config: this.bundleConfig,
            bundleRecord: {
                // TODO we need to solve include modules for fingerprints support
                includedModules: metadata.includedModules || [],
                imports,
            },
            src: bundlePath,
        };
    }
}
//# sourceMappingURL=static-bundle-provider.js.map