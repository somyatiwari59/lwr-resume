/// <reference types="node" />
/// <reference types="node" />
import type { AssetIdentifier, ResourcePaths, ViewSource } from '@lwrjs/types';
import { lookup } from 'mime-types';
import { Readable } from 'stream';
/**
 * Create a hash string for a source
 * @param source
 */
export declare function hashContent(source: string | Buffer): string;
/**
 * Read in the contents of the file path
 * @param filePath
 */
export declare function readFile(filePath: string): string;
/**
 * Given a filepath, ensure it has a file extension by checking for the file on the fs
 * @param filePath
 */
export declare function resolveFileExtension(filePath: string): string;
/**
 * Returns if view of specific type can be resolved
 *
 * @param source - path to view
 * @param type - extension of file that should be expected, i.e. 'html'
 */
export declare function canResolveView(source: string, type: string): boolean;
/**
 * Construct a ViewSource from the associated file on the fs
 * @param source - Filepath with the source (source can be an absolute or relative path)
 * @param viewFolder - File in the fs which holds the view
 */
export declare function getViewSourceFromFile(source: string): ViewSource;
export declare function normalizeDirectory(dir: string, rootDir: string): string;
export declare function normalizeResourcePath(rawPath: string, { rootDir, assets, contentDir, layoutsDir }: ResourcePaths, allowUnresolvedAlias?: boolean): string;
export { lookup as mimeLookup };
/**
 * Tries to convert any URL or $aliased path into a canonical fs path
 */
export declare function normalizeAssetSpecifier(assetId: AssetIdentifier, assetPathMap: Map<string, string>, resourcePaths: ResourcePaths, basePath: string): string;
export declare function streamToString(stream: Readable, encoding?: BufferEncoding): Promise<string>;
export declare function stringToStream(str: string | Buffer): Readable;
//# sourceMappingURL=fs.d.ts.map