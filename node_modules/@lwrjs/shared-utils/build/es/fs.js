import fs from 'fs';
import pathLib from 'path';
import crypto from 'crypto';
import { slugify } from './identity.js';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { lookup } from 'mime-types';
import { Readable } from 'stream';
import { DEBUG, logger, VERBOSE } from './logger.js';
let fileCount = 0;
const files = new Map();
/**
 * Create a hash string for a source
 * @param source
 */
export function hashContent(source) {
    return crypto.createHash('md5').update(source).digest('hex');
}
/**
 * Read in the contents of the file path
 * @param filePath
 */
export function readFile(filePath) {
    logMetrics(filePath);
    return fs.readFileSync(filePath, 'utf8');
}
/**
 * Given a filepath, ensure it has a file extension by checking for the file on the fs
 * @param filePath
 */
export function resolveFileExtension(filePath) {
    const fileName = pathLib.basename(filePath);
    const hasExt = !!pathLib.extname(fileName);
    // If it has extension just return it
    if (hasExt) {
        return filePath;
    }
    // No extension, if it exist, it can be a dir or a file
    if (fs.existsSync(filePath)) {
        if (fs.statSync(filePath).isFile()) {
            return filePath; // extension-less file, which is odd but...
        }
        else {
            filePath = pathLib.join(filePath, 'index'); // if is a dir we will be testing the extensions
        }
    }
    // At this point we have a file with no extension so we try for the default (js,ts) or fail
    if (fs.existsSync(filePath + '.js')) {
        return filePath + '.js';
    }
    else if (fs.existsSync(filePath + '.ts')) {
        return filePath + '.ts';
    }
    else {
        throw new Error(`Unable to find file "${filePath}"`);
    }
}
/**
 * Returns if view of specific type can be resolved
 *
 * @param source - path to view
 * @param type - extension of file that should be expected, i.e. 'html'
 */
export function canResolveView(source, type) {
    if (!source.endsWith(`.${type}`)) {
        return false;
    }
    if (!fs.existsSync(pathLib.resolve(source))) {
        throw new Error(`View template cannot be found: "${source}"`);
    }
    return true;
}
/**
 * Construct a ViewSource from the associated file on the fs
 * @param source - Filepath with the source (source can be an absolute or relative path)
 * @param viewFolder - File in the fs which holds the view
 */
export function getViewSourceFromFile(source) {
    const sourceFilePath = pathLib.resolve(source);
    const viewSource = readFile(sourceFilePath);
    const ext = pathLib.extname(sourceFilePath);
    const name = pathLib.basename(sourceFilePath, ext);
    return {
        name,
        slug: slugify(name),
        filePath: sourceFilePath,
        ownHash: hashContent(viewSource),
        originalSource: viewSource,
    };
}
/**
 * Replace all instances of `$rootDir` with `rootDir`
 * @param dir
 * @param rootDir
 */
const ROOT_DIR_REGEX = /\$rootDir/g;
export function normalizeDirectory(dir, rootDir) {
    return dir.replace(ROOT_DIR_REGEX, rootDir);
}
/**
 * Replace all instances of `$*Dir` with `resourcePaths.*Dir`
 * @param rawPath
 * @param param1 - root directories
 */
const RESOURCE_DIR_REGEX = /\$(\w+)|^\$(\w+)/g;
export function normalizeResourcePath(rawPath, { rootDir, assets, contentDir, layoutsDir }, allowUnresolvedAlias) {
    const assetsMap = assets.reduce((map, asset) => {
        if (asset.alias) {
            // Asset config has either a "dir" OR a "file"
            map[asset.alias] = asset.dir || asset.file;
        }
        return map;
    }, { rootDir, contentDir, layoutsDir });
    return rawPath.replace(RESOURCE_DIR_REGEX, function (fullMatch, m1, m2) {
        const alias = assetsMap[m1] || assetsMap[m2];
        if (!alias && !allowUnresolvedAlias) {
            throw createSingleDiagnosticError({
                description: descriptions.UNRESOLVABLE.DIR_ALIAS(fullMatch),
            }, LwrUnresolvableError);
        }
        return alias;
    });
}
export { lookup as mimeLookup };
function logMetrics(filePath) {
    if (logger.currentLevel == DEBUG || logger.currentLevel == VERBOSE) {
        let count = files.get(filePath) || 0;
        if (++count % 100 === 0) {
            logger.debug(`[${count}] Repeat Read ${filePath}`);
        }
        files.set(filePath, count);
        if (++fileCount % 1000 === 0) {
            logger.debug(`Open file count [${fileCount}]`);
        }
    }
}
/**
 * Tries to convert any URL or $aliased path into a canonical fs path
 */
export function normalizeAssetSpecifier(assetId, assetPathMap, resourcePaths, basePath) {
    const { specifier, importer, type } = assetId;
    if (specifier.startsWith('./') || specifier.startsWith('../')) {
        if (!importer) {
            throw Error(`Unable to resolve relative import "${specifier}" without an importer.`);
        }
        return pathLib.join(pathLib.dirname(importer), specifier);
    }
    if (type === 'content-asset') {
        const originSpecifier = !basePath ? specifier : specifier.split(basePath)[1];
        return pathLib.join(resourcePaths.contentDir, originSpecifier);
    }
    if (specifier[0] === '$') {
        // This is a fs path containing an asset alias
        return normalizeResourcePath(specifier, resourcePaths);
    }
    // This is an absolute path to the server
    // Match in 2 ways:
    //      - Directories: the prefix of the asset specifier/path matches a configured assets[i].urlPath
    //      - Individual files: the asset specifier is equal to a configured assets[i].urlPath
    for (const [urlPath, fsPath] of assetPathMap.entries()) {
        const slashPath = urlPath.endsWith('/') ? urlPath : `${urlPath}/`;
        const fsSlashPath = fsPath.endsWith('/') ? fsPath : `${fsPath}/`;
        // Matches directory
        if (specifier.startsWith(slashPath)) {
            return specifier.replace(slashPath, fsSlashPath);
            // Matches File
        }
        else if (specifier === urlPath) {
            return specifier.replace(urlPath, fsPath);
        }
    }
    return specifier;
}
export function streamToString(stream, encoding = 'utf8') {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.on('data', (c) => chunks.push(c));
        stream.on('error', reject);
        stream.on('end', () => resolve(Buffer.concat(chunks).toString(encoding)));
    });
}
export function stringToStream(str) {
    let index = 0;
    const isBuffer = Buffer.isBuffer(str);
    const readable = new Readable({
        read(size) {
            if (index >= str.length) {
                this.push(null);
                return;
            }
            let chunk;
            if (isBuffer) {
                chunk = str.subarray(index, index + size);
            }
            else {
                chunk = str.slice(index, index + size);
            }
            index += size;
            this.push(chunk);
        },
    });
    return readable;
}
//# sourceMappingURL=fs.js.map