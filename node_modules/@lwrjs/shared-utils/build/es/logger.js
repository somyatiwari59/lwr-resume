import { DiagnosticsError } from '@lwrjs/diagnostics';
export const VERBOSE = 'verbose';
export const DEBUG = 'debug';
export const INFO = 'info';
export const WARN = 'warn';
export const ERROR = 'error';
let options = {};
const DUPES = new Set();
let currentLevel = process.env.LOG_LEVEL || INFO;
function log(level, message, additionalInfo) {
    const LOG_LEVEL = process.env.LOG_LEVEL || INFO;
    if (currentLevel !== LOG_LEVEL) {
        currentLevel = LOG_LEVEL;
        console.log(`LOG_LEVEL: ${LOG_LEVEL}`);
    }
    let shouldLog = false;
    switch (level) {
        case VERBOSE:
            shouldLog = LOG_LEVEL == VERBOSE;
            break;
        case DEBUG:
            shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG;
            break;
        case INFO:
            shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO;
            break;
        case WARN:
            shouldLog = LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO || LOG_LEVEL == WARN;
            break;
        case ERROR:
            shouldLog = true;
            break;
    }
    // Check if we should suppress dupes and we have already logged this message
    if (shouldLog && options.dedupe && options.dedupe.has(level)) {
        const key = `[${level}] : ${message}`;
        if (DUPES.has(key)) {
            shouldLog = false;
        }
        else {
            // add key to de-duplicate cache
            DUPES.add(key);
        }
    }
    if (shouldLog) {
        const logMessage = `[${level}]${gap(message)}${message}`;
        const additionalMessage = additionalInfo
            ? `Additional Info: ${JSON.stringify(additionalInfo)}`
            : undefined;
        if (level == ERROR) {
            console.error('\x1b[31m%s\x1b[0m', logMessage); // red
            if (additionalInfo) {
                console.error('\n\x1b[31m%s\x1b[0m', additionalMessage); // red
            }
        }
        else if (level == WARN) {
            console.warn('\x1b[33m%s\x1b[0m', logMessage); // yellow
            if (additionalInfo) {
                console.warn('\n\x1b[33m%s\x1b[0m', additionalMessage); // yellow
            }
        }
        else if (level == DEBUG || level == VERBOSE) {
            console.log('\x1b[2m%s\x1b[0m', logMessage); // dim
            if (additionalInfo) {
                console.log('\n\x1b[2m%s\x1b[0m', additionalMessage); // dim
            }
        }
        else {
            console.log(logMessage);
            if (additionalInfo) {
                console.log(`\n${additionalMessage}`);
            }
        }
    }
}
export const stringifyError = (error) => {
    if (error instanceof DiagnosticsError) {
        return JSON.stringify({
            message: error.message,
            diagnostics: error.diagnostics,
            stack: error.stack,
        });
    }
    else if (typeof error === 'string' || error instanceof String) {
        return error;
    }
    else {
        const propertyNames = Object.getOwnPropertyNames(error);
        const retObj = {};
        for (let property, i = 0, len = propertyNames.length; i < len; ++i) {
            property = propertyNames[i];
            const descriptor = Object.getOwnPropertyDescriptor(error, property);
            retObj[property] = descriptor?.value;
        }
        return JSON.stringify(retObj);
    }
};
// Return a space if there should be a space between the message and the level
function gap(message) {
    return String(message)?.indexOf('[') === 0 ? '' : ' ';
}
function logError(err, additionalInfo) {
    if (err instanceof DiagnosticsError || !err || !err.message) {
        log(ERROR, stringifyError(err), additionalInfo);
    }
    // If this is an error with a message update the message header and log as is...
    if (err && err.message) {
        console.error('\x1b[31m%s\x1b[0m', `[${ERROR}]${gap(err.message)}${err.message}`);
        console.error('\x1b[90m%s\x1b[0m', err);
    }
}
export const logger = {
    verbose: (message, additionalInfo) => log(VERBOSE, message, additionalInfo),
    debug: (message, additionalInfo) => log(DEBUG, message, additionalInfo),
    info: (message, additionalInfo) => log(INFO, message, additionalInfo),
    warn: (message, additionalInfo) => log(WARN, message, additionalInfo),
    error: (error, additionalInfo) => logError(error, additionalInfo),
    log,
    setOptions: (opts) => {
        options = opts;
    },
    currentLevel,
};
//# sourceMappingURL=logger.js.map