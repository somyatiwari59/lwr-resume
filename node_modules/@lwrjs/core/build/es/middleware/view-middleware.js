import { descriptions } from '@lwrjs/diagnostics';
import { getClientRoutes } from '@lwrjs/router';
import { decodeViewPath, extractRequestParams, getClientBootstrapConfigurationRoutes, logger, shortestTtl, } from '@lwrjs/shared-utils';
import { handleErrors } from './utils/error-handling.js';
import { LwrViewHandler } from '@lwrjs/view-registry';
const CANONICAL_VIEW_ROUTES = [
    `/:apiVersion/application/:format/l/:locale/ai/:appId`,
    `/:apiVersion/application/:format/l/:locale/e/:environment/ai/:appId`,
    `/:apiVersion/application/:format/ai/:appId`,
    `/:apiVersion/application/:format/e/:environment/ai/:appId`,
];
function createViewMiddleware(route, errorRoutes, context, viewHandler) {
    const errorRoute = errorRoutes.find((route) => route.status === 500);
    return async (req, res) => {
        if (!req.validateEnvironmentRequest(context.appConfig)) {
            res.status(400);
            res.send(descriptions.UNRESOLVABLE.INVALID_ENVIRONMENT(req.params.environment).message);
            return;
        }
        if (!req.validateJsonRequest()) {
            res.status(400);
            res.send(descriptions.UNRESOLVABLE.INVALID_JSON().message);
            return;
        }
        const { runtimeEnvironment, runtimeParams } = req.getRuntimeContext(context.runtimeEnvironment);
        // set the default environment if an environment is configured in the app config
        const { environment: environmentConfig } = context.appConfig;
        if (!runtimeParams.environment && environmentConfig?.default) {
            runtimeParams.environment = environmentConfig.default;
        }
        const viewRequest = {
            url: req.originalUrl,
            params: req.params,
            query: req.query,
            requestPath: req.path,
        };
        const resolve = req.isJsonRequest() ? viewHandler.getViewJson : viewHandler.getViewContent;
        let viewResponse;
        let resolvedRoute;
        try {
            viewResponse = await resolve.call(viewHandler, viewRequest, route, runtimeEnvironment, runtimeParams);
            resolvedRoute = route;
        }
        catch (err) {
            if (!errorRoute) {
                throw err;
            }
            // Log Unexpected Routing Errors
            logger.error(`[view-middleware] Route Error ${req.originalUrl}`);
            logger.error(err);
            viewResponse = await resolve.call(viewHandler, viewRequest, errorRoute, runtimeEnvironment, runtimeParams);
            resolvedRoute = errorRoute;
        }
        if (req.isSiteGeneration()) {
            res.setSiteGenerationMetadata(viewResponse.metadata);
        }
        // view response will be html by default
        res.type('text/html');
        // the default content type can be overridden if specified by the view response
        if (viewResponse.headers) {
            res.set(viewResponse.headers);
        }
        // pick the shortest TTL between the view response and route object
        const cacheTtl = shortestTtl(viewResponse.cache?.ttl, resolvedRoute.cache?.ttl);
        if (cacheTtl) {
            res.setHeader('cache-control', `public, max-age=${cacheTtl}`);
        }
        const status = resolvedRoute.status || viewResponse.status || 200;
        res.status(status);
        res.send(viewResponse.body);
    };
}
function createConfigMiddleware(routes, context, viewHandler) {
    return async (req, res) => {
        const { runtimeEnvironment, runtimeParams } = req.getRuntimeContext(context.runtimeEnvironment);
        const { appId, encodedViewPath } = req.params;
        // match the app id to a route
        const route = routes.find((route) => route.id === appId);
        if (!route) {
            res.status(404).send(descriptions.UNRESOLVABLE.APP_CONFIG(appId).message);
            return;
        }
        // decode the resolved view path and extract any params.
        const url = decodeViewPath(encodedViewPath);
        const originalUrl = req.originalUrl;
        const requestPath = route.path;
        const params = extractRequestParams(requestPath, url, req.params);
        const viewRequest = {
            url,
            originalUrl,
            params,
            query: req.query,
            requestPath,
        };
        const viewResponse = await viewHandler.getViewConfiguration(viewRequest, route, runtimeEnvironment, runtimeParams);
        if (!viewResponse) {
            res.status(404).send(descriptions.UNRESOLVABLE.VIEW_CONFIG(url).message);
            return;
        }
        // Pick the shortest TTL between the view response and route object
        const cacheTtl = shortestTtl(viewResponse.cache?.ttl, route.cache?.ttl);
        if (cacheTtl) {
            res.setHeader('cache-control', `public, max-age=${cacheTtl}`);
        }
        res.status(200);
        res.type('application/javascript');
        res.status(viewResponse.status || 200);
        res.send(viewResponse.body);
    };
}
function createNotFoundMiddleware(errorRoutes, context, viewHandler) {
    const notFoundRoute = errorRoutes.find((route) => route.status === 404);
    if (notFoundRoute) {
        return createViewMiddleware(notFoundRoute, errorRoutes, context, viewHandler);
    }
    return (req, res) => {
        res.status(404).send(descriptions.UNRESOLVABLE.VIEW(req.originalUrl).message);
    };
}
export function viewMiddleware(app, context) {
    const { appConfig, viewRegistry, moduleRegistry, routeHandlers } = context;
    const { routes, errorRoutes } = appConfig;
    const viewHandler = new LwrViewHandler({ viewRegistry, moduleRegistry, routeHandlers }, appConfig);
    // create and attach middleware for each route
    for (const route of routes) {
        const paths = [route.path];
        const subRoutes = route.subRoutes && getClientRoutes(route.subRoutes);
        if (subRoutes) {
            const prefix = route.path === '/' ? '' : route.path;
            subRoutes.routes.forEach((subRoute) => subRoute.uri !== route.path && paths.push(`${prefix}${subRoute.uri}`));
        }
        paths.forEach((routePath) => paths.push(...CANONICAL_VIEW_ROUTES.map((viewRoute) => viewRoute + routePath)));
        app.get(paths, handleErrors(createViewMiddleware(route, errorRoutes, context, viewHandler)));
    }
    // create and attach middleware for bootstrap configurations
    app.get(getClientBootstrapConfigurationRoutes(), handleErrors(createConfigMiddleware(routes, context, viewHandler)));
    // create and attach a greedy middleware to handle unsupported paths
    // NOTE: a greedy `all` is used over `use` due to the way middleware is mounted in the server abstraction
    app.get('/' + app.getRegexWildcard(), handleErrors(createNotFoundMiddleware(errorRoutes, context, viewHandler)));
}
//# sourceMappingURL=view-middleware.js.map