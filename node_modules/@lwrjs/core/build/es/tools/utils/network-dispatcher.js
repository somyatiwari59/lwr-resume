import http from 'http';
import https from 'https';
import { DEBUG, isModuleOrBundleUrl, logger, VERBOSE } from '@lwrjs/shared-utils';
export default class NetworkDispatcher {
    constructor(port, internalRequestKey) {
        this.port = port || 3000;
        const httpClient = this.port == 443 ? https : http;
        this.pool = new httpClient.Agent({
            maxSockets: 25,
        });
        this.internalRequestKey = internalRequestKey || '';
    }
    dispatchUrl(url, method, lang) {
        const options = this.createRequestOptions(url, method, lang);
        return this.handleRequest(options, url, method, lang);
    }
    createRequestOptions(url, method, lang) {
        return {
            method: method,
            host: 'localhost',
            port: this.port,
            path: url,
            agent: this.pool,
            headers: {
                'Accept-Language': lang,
                // pass private key to get access to internal metadata
                'lwr-metadata-request': this.internalRequestKey,
            },
        };
    }
    handleRequest(options, url, method, lang) {
        return new Promise((resolve, reject) => {
            const httpClient = options.port == 443 ? https : http;
            const bodyChunks = [];
            logger.verbose(`[NetworkDispatcher] Request: [${method}][${lang}] ${url}`);
            const req = httpClient.request(options, (res) => {
                res.on('data', (chunk) => {
                    bodyChunks.push(chunk);
                });
                res.on('end', () => {
                    logger.verbose(`[END][NetworkDispatcher] Request: [${method}][${lang}] ${url}`);
                    if (!res.statusCode || (res.statusCode >= 200 && res.statusCode < 300)) {
                        const body = Buffer.concat(bodyChunks).toString();
                        try {
                            const jsonResponse = JSON.parse(body);
                            resolve(jsonResponse);
                        }
                        catch (err) {
                            if (logger.currentLevel == DEBUG || logger.currentLevel == VERBOSE) {
                                logger.warn(`[NetworkDispatcher] unexpected response body: [${method}][${lang}] ${url}: '${body}'`, err);
                            }
                            else {
                                logger.warn(`[NetworkDispatcher] unexpected response body: [${method}][${lang}] ${url}: '${body}'`);
                            }
                            resolve({});
                        }
                    }
                    else if (res.statusCode === 301 || res.statusCode === 302) {
                        // Lets follw if we know it is a module or bundle refrence
                        if (res.headers?.location && isModuleOrBundleUrl(res.headers?.location)) {
                            logger.debug(`[NetworkDispatcher] Follow redirect: [${method}][${lang}][${res.statusCode}] ${url} -> ${res.headers.location}`);
                            const location = res.headers.location;
                            return (this.handleRequest(this.createRequestOptions(location, method, lang), location, method, lang)
                                // Send nested response to the resolve or reject functions defined above
                                .then((resRedirect) => resolve(resRedirect))
                                // Should not happen since we are just warning on error
                                .catch((rejectRedirect) => reject(rejectRedirect)));
                        }
                        else {
                            logger.warn(`Redirect not followed: [${method}][${lang}][${res.statusCode}] ${url} -> ${res.headers.location}`);
                            resolve({});
                        }
                    }
                    // if any other status codes are returned, those needed to be added here
                    else {
                        logger.warn(`Unexpected status code: [${method}][${lang}][${res.statusCode}] ${url}`);
                        resolve({});
                    }
                });
            });
            req.on('error', (err) => {
                if (logger.currentLevel == DEBUG || logger.currentLevel == VERBOSE) {
                    logger.warn(`[NetworkDispatcher] Request Failed: [${method}][${lang}] ${url}`, err);
                }
                else {
                    logger.warn(`[NetworkDispatcher] Request  Failed: [${method}][${lang}] ${url}`);
                }
                resolve({});
            });
            req.end();
        });
    }
}
//# sourceMappingURL=network-dispatcher.js.map