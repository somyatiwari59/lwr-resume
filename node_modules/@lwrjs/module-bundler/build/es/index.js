import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { getCacheKeyFromJson, InflightTasks, TaskPool } from '@lwrjs/shared-utils';
import { join } from 'path';
const TASK_POOL = new TaskPool();
export class LwrModuleBundler {
    constructor(config, globalConfig) {
        this.cache = new Map();
        this.providers = [];
        this.transformers = [];
        // Pending bundle definitions are tracked to prevent concurrent resolution of the same bundle.
        // Subsequent requests for the same bundle will await the original promise.
        // Cache entries will be removed once the bundle is resolved.
        this.inflightBundleDefinitions = new InflightTasks();
        this.moduleRegistry = config.moduleRegistry;
        this.appObserver = config.appObserver;
        // Freeze the bundle config to make sure it is not modified
        this.bundleConfig = Object.freeze(globalConfig.bundleConfig);
        this.appObserver?.onModuleDefinitionChange(() => {
            // TODO: This is a very naive approach however
            // this would only happen in non-prod environments
            this.cache.clear();
        });
    }
    addBundleProviders(providers) {
        this.providers.push(...providers);
    }
    addBundleTransformers(transformers) {
        this.transformers.push(...transformers);
    }
    async getModuleBundle(moduleId, runtimeEnvironment, runtimeParams = {}, bundleConfigOverrides) {
        const { format, minify, debug } = runtimeEnvironment;
        const cacheKey = `${moduleId.specifier}|${moduleId.version}|${getCacheKeyFromJson({
            locale: runtimeParams.locale,
            format,
            minify,
            debug,
            bundleConfigOverrides,
        })}`;
        const cacheDisabled = process.env.NOCACHE === 'true';
        if (!cacheDisabled) {
            // Return the cached bundle definition
            if (this.cache.has(cacheKey)) {
                // TODO add to profiling
                // console.log('[INFO] Bundle Cache Hit: ', cacheKey);
                const bundleDef = this.cache.get(cacheKey);
                return bundleDef;
            }
        }
        return this.inflightBundleDefinitions.execute(cacheKey, () => {
            // TODO add to profiling
            // console.log('[INFO] Create Bundle: ', cacheKey);
            // Run theses tasks in a task pool to throttle parallel requests.
            return TASK_POOL.execute(async () => {
                for (const bundler of this.providers) {
                    // eslint-disable-next-line no-await-in-loop
                    const bundleDef = await bundler.bundle(moduleId, runtimeEnvironment, runtimeParams, bundleConfigOverrides);
                    if (bundleDef) {
                        if (!cacheDisabled) {
                            this.cache.set(cacheKey, bundleDef);
                        }
                        return bundleDef;
                    }
                }
                throw createSingleDiagnosticError({
                    description: descriptions.UNRESOLVABLE.BUNDLE(moduleId.specifier),
                }, LwrUnresolvableError);
            }, this);
        });
    }
    /**
     * Resolve the URI to the bundle rooted at the `moduleId`
     * @param moduleId - The id of the root module for the bundle
     * @param runtimeEnvironment  - The runtime operating environnment
     * @param runtimeParams  - The available runtime parameters provided in context to the request
     * @param signature - The signature of the bundle instance being referenced
     * @returns the URI
     */
    async resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, signature) {
        // First get the bundle definition to see if a src attribute is set.
        const bundleDefinition = await this.getModuleBundle(moduleId, runtimeEnvironment, runtimeParams);
        if (!bundleDefinition) {
            throw createSingleDiagnosticError({
                description: descriptions.UNRESOLVABLE.BUNDLE(moduleId.specifier),
            }, LwrUnresolvableError);
        }
        let uri;
        if (bundleDefinition.src) {
            // If source is provided on the bundle definition use that
            uri = bundleDefinition.src;
        }
        else {
            let resolvedVersion = moduleId.version || bundleDefinition.version;
            // If we do not know the version, look it up.
            if (!resolvedVersion) {
                const { version } = await this.moduleRegistry.getModuleEntry(moduleId);
                resolvedVersion = version;
            }
            uri = String(await this.moduleRegistry.resolveModuleUri({ ...moduleId, version: resolvedVersion }, runtimeEnvironment, runtimeParams, signature));
        }
        const bundleUri = {
            artifactType: 'bundle',
            uri: join(runtimeEnvironment.basePath || '', uri),
            immutable: runtimeEnvironment.immutableAssets,
            entry: uri,
        };
        // Perform any transforms
        for (const transformPlugin of this.transformers) {
            // eslint-disable-next-line no-await-in-loop
            const resolveUriResult = await transformPlugin.transformUri?.(bundleUri, bundleDefinition, runtimeEnvironment);
            if (resolveUriResult && resolveUriResult.uri) {
                uri = resolveUriResult.uri;
            }
        }
        return uri;
    }
    getPublicApi() {
        return {
            getModuleBundle: this.getModuleBundle.bind(this),
            resolveModuleUri: this.resolveModuleUri.bind(this),
        };
    }
}
//# sourceMappingURL=index.js.map