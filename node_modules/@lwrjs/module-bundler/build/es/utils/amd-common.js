import { GraphDepth, createAmdAlias, explodeSpecifier, getModuleGraphs, getSpecifier, getGroupName, isGroupie, getCacheKeyFromJson, } from '@lwrjs/shared-utils';
import { rollup } from 'rollup';
import replace from '@rollup/plugin-replace';
import { bundleDefinitions } from './rollup-amd-bundler-plugin.js';
import { overrideBundleConfig } from './bundle-common.js';
const AMD_DEFINE = 'LWR.define';
const groupieCodeCache = new Map();
function includeIdFactory(graphSpecifier, external, exclude = [], requiredImports, groups) {
    return (moduleRef) => {
        // Do not bundle externals, including the loader module, which is auto bundled
        // with the shim + loader combo
        if (external[moduleRef.specifier] !== undefined) {
            // Do not include externals in the required imports but also return false to indicate it should not be in the bundle
            return false;
        }
        const moduleRefIsGroupie = isGroupie(moduleRef.specifier, groups);
        const rootModuleIsGroupie = isGroupie(graphSpecifier, groups);
        const moduleIsNotRoot = graphSpecifier !== moduleRef.specifier;
        if (moduleRefIsGroupie) {
            // If this is part of bundle group return false to indicate it should not be in the bundle
            // but add it to the requriedImports so it shows up as a static dependency of the bundle.
            // However, skip this if the requested specifier is also part of the same group.
            if (moduleIsNotRoot && !rootModuleIsGroupie) {
                requiredImports.set(`${moduleRef.specifier}_${moduleRef.version}`, moduleRef);
            }
            return false;
        }
        else if (exclude?.includes(moduleRef.specifier)) {
            // If this is a bundle exclude return false to indicate it should not be in the bundle
            // but add it to the requriedImports so it shows up as a static dependency of the bundle.
            if (moduleIsNotRoot) {
                requiredImports.set(`${moduleRef.specifier}_${moduleRef.version}`, moduleRef);
            }
            return false;
        }
        return true;
    };
}
async function bundle(id, moduleGraphs, minify = false, unVersionedAliases = false) {
    const plugins = [bundleDefinitions({ moduleGraphs })];
    minify &&
        plugins.push(
        // terser(), // Do not minify until needed for client modules. Server/SSR modules do not need to be minified.
        replace({
            'process.env.NODE_ENV': JSON.stringify('production'),
            preventAssignment: false,
        }));
    const bundler = await rollup({ input: id, plugins });
    const { output } = await bundler.generate({
        amd: { id, define: AMD_DEFINE },
        exports: 'named',
        format: 'amd',
    });
    let code = output[0].code;
    if (unVersionedAliases) {
        const idObject = explodeSpecifier(id);
        const specifier = idObject.specifier;
        const aliasModule = createAmdAlias(specifier, id);
        code += aliasModule;
    }
    return code;
}
async function getBundleCode(rootModule, moduleGraphs, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, unVersionedAliases, includeId, moduleRegistry, runtimeEnvironment, runtimeParams = {}, visitedSpecifiers) {
    const modules = [rootModule, ...moduleGraphs.graphs[0].static];
    const { moduleRecord } = await moduleRegistry.getModule(explodeSpecifier(rootModule));
    // add static imports from the LinkedModuleDefinitions added during module linking
    // they're not in the ModuleGraph imports b/c those are based on raw module source
    if (moduleRecord.importMeta) {
        // the only use case for this is "lwr/environment", so skip the logic when it's not needed
        for (const specifier of modules) {
            const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
            const imports = linkedDefinition?.linkedModuleRecord.imports || [];
            for (const imp of imports) {
                const modId = explodeSpecifier(imp.specifier);
                if (!modules.includes(imp.specifier) && includeId(modId)) {
                    modules.push(imp.specifier);
                    if (!moduleGraphs.linkedDefinitions[imp.specifier]) {
                        // eslint-disable-next-line no-await-in-loop
                        const missingLinkedModule = await moduleRegistry.getLinkedModule({ specifier: modId.specifier, version: modId.version }, runtimeEnvironment, runtimeParams);
                        moduleGraphs.linkedDefinitions[imp.specifier] = missingLinkedModule;
                    }
                }
            }
        }
    }
    const bundles = (await Promise.all(modules
        .reduce((filteredModules, specifier) => {
        const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
        // skip modules that do not have a linked definition
        if (!linkedDefinition) {
            return filteredModules;
        }
        // add any dynamic imports from each of the linked definitions in the module graph
        linkedDefinition.linkedModuleRecord.dynamicImports?.forEach((dynamicImport) => {
            if (dynamicImport.moduleNameType !== 'unresolved') {
                dynamicImports.set(`${dynamicImport.specifier}_${dynamicImport.version}`, dynamicImport);
            }
        });
        // skip relative dependencies
        if (specifier.includes('#')) {
            return filteredModules;
        }
        // prepend the linked definition for the correct order
        filteredModules.unshift(linkedDefinition);
        return filteredModules;
    }, [])
        .map((linkedDefinition) => {
        const id = getSpecifier(linkedDefinition);
        if (visitedSpecifiers?.has(id)) {
            return false;
        }
        else {
            visitedSpecifiers?.set(id, true);
        }
        if (id !== rootModule) {
            includedModules.push(id);
        }
        else {
            // we need to still keep track of roots for bundle groups
            bundleGroupsIncludedModules.push(id);
        }
        // bundle all dependencies for the linked definition and convert to AMD
        return bundle(id, moduleGraphs, minify, unVersionedAliases);
    }))).filter((x) => typeof x === 'string');
    return bundles;
}
export async function amdBundler(rootModuleId, moduleRegistry, minify = false, runtimeEnvironment, runtimeParams = {}, { bundleConfig }, bundleConfigOverrides) {
    const { exclude, external = {}, groups = {} } = overrideBundleConfig(bundleConfig, bundleConfigOverrides);
    // Note: the maps must be cleared each time we call getModuleGraph
    const requiredImports = new Map();
    const dynamicImports = new Map();
    const groupName = getGroupName(rootModuleId.specifier, groups);
    const groupies = groupName && groups[groupName];
    // Note: in reality, bundleConfig cannot change at runtime, but
    // use it as a cacheKey anyways in case we want to support it in the future
    const cacheKey = getCacheKeyFromJson({ groupName, exclude, external });
    const cachedGroupieCode = groupName && groupieCodeCache.get(cacheKey);
    const getModuleGraphsWrapper = (graphSpecifier) => {
        const graphOptions = {
            includeLinkedDefinitions: true,
            depth: {
                static: GraphDepth.ALL,
                dynamic: 0,
                includeId: includeIdFactory(graphSpecifier, external, exclude, requiredImports, groups),
            },
        };
        return getModuleGraphs(graphSpecifier, graphOptions, moduleRegistry, moduleRegistry, runtimeEnvironment, runtimeParams);
    };
    const moduleGraphs = await getModuleGraphsWrapper(rootModuleId.specifier);
    const rootModule = moduleGraphs.graphs[0];
    // we also need to get moduleGraphs for any group members this module belongs to
    const groupModuleGraphsMap = new Map();
    if (!cachedGroupieCode && groupies && groupies.length) {
        for (const specifier of groupies) {
            if (specifier !== rootModuleId.specifier) {
                // eslint-disable-next-line no-await-in-loop
                const groupieModuleGraph = await getModuleGraphsWrapper(specifier);
                groupModuleGraphsMap.set(specifier, groupieModuleGraph);
            }
        }
    }
    let bundleCode, includedModules, bundleGroupsIncludedModules;
    // we don't need to recompute the bundle code if it already exists for this group
    const cachedBundleGroupCode = cachedGroupieCode;
    const bundledSpecifiersMap = new Map();
    if (!cachedBundleGroupCode) {
        (includedModules = []), (bundleGroupsIncludedModules = []);
        const bundles = await getBundleCode(rootModule.specifier, moduleGraphs, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, !!runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES, includeIdFactory(rootModuleId.specifier, external, exclude, requiredImports, groups), moduleRegistry, runtimeEnvironment, runtimeParams, bundledSpecifiersMap);
        if (groupName) {
            // add groupies to bundles
            for (const rawGroupieSpecifier of groupies) {
                if (rawGroupieSpecifier !== rootModuleId.specifier) {
                    const groupieModuleGraph = groupModuleGraphsMap.get(rawGroupieSpecifier);
                    const groupieSpecifer = groupieModuleGraph.graphs[0].specifier;
                    // eslint-disable-next-line no-await-in-loop
                    const groupieBundles = await getBundleCode(groupieSpecifer, groupieModuleGraph, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, !!runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES, includeIdFactory(rawGroupieSpecifier, external, exclude, requiredImports, groups), moduleRegistry, runtimeEnvironment, runtimeParams, bundledSpecifiersMap);
                    bundles.push(...groupieBundles);
                }
            }
        }
        bundleCode = bundles.join('');
        if (groupName) {
            includedModules.push(...bundleGroupsIncludedModules);
            groupieCodeCache.set(groupName, { code: bundleCode, includedModules });
        }
    }
    else {
        bundleCode = cachedBundleGroupCode.code;
        includedModules = cachedBundleGroupCode.includedModules;
    }
    const { id, name, namespace, version, specifier } = moduleGraphs.linkedDefinitions[rootModule.specifier];
    return {
        id,
        name,
        namespace,
        version,
        specifier,
        code: bundleCode,
        config: { external, exclude },
        bundleRecord: {
            imports: Array.from(requiredImports.values()),
            dynamicImports: Array.from(dynamicImports.values()),
            includedModules,
        },
    };
}
//# sourceMappingURL=amd-common.js.map